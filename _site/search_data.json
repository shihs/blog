{
  

    "python-2022-04-05-python-e8-99-9b-e6-93-ac-e7-92-b0-e5-a2-83-virtual-environment-conda-create-e8-88-87-virtualenv-e6-af-94-e8-bc-83": {
      "title": "[Python]Python 虛擬環境 (virtual environment) - conda create 與 virtualenv 比較",
      "content"	 : "Virtualenvvirtualenv是用來建立一個獨立的Python環境的工具，支援 Python2 和 Python3。  安裝 virtualenv：pip install virtualenv  建立虛擬環境：          先建立一個資料夾：mkdir myenv      路徑移到該資料夾：cd myenv      建立虛擬環境：virtualenv venv        啟動虛擬環境：source env/bin/activate  在該環境下載套件：pip install PACKAGE_NAME  停用虛擬環境：deactivateConda  Conda is an open source package management system and environment management system that runs on Windows, macOS and Linux. It was created for Python programs, but it can package and distribute software for any language.Conda 是一個開源的跨平台工具軟體，它被設計作為 Python、R、Lua、Scala 與 Java 等任何程式語言的套件、依賴性以及工作環境管理員。傳統 Python 使用者以 pip 作為套件管理員（package manager）、以 venv 作為工作環境管理員（environment manager），而 conda 則達成了「兩個願望、一次滿足」既可以管理套件亦能夠管理工作環境。在 Python 使用 conda  可以下載 Anaconda（3 GB 以上）或 Miniconda（400 MB 左右）          Miniconda installer = Python + conda      Anaconda installer = Python + conda + meta package anaconda = Miniconda installer + conda install anaconda      What are the differences between Conda and Anaconda?  conda is the package manager. Anaconda is a set of about a hundred packages including conda, numpy, scipy, ipython notebook, and so on.  Miniconda is a smaller alternative to Anaconda that is just conda and its dependencies, not those listed above.  Once you have Miniconda, you can easily install Anaconda into it with conda install anaconda.下載  下載 Miniconda  下載 AnacondaCheatsheet  Documentconda 的資訊  conda --version：檢視 conda 版本  conda update conda：更新 conda 版本  conda env list：conda 所有的環境conda basic  conda install PACKAGENAME：Install a package included in Anaconda  conda update PACKAGENAME：Update any installed program環境  conda create --name ENV_NAME python=VERSION：建立特定版本，名稱為ENV_NAME的環境          Ex. conda create --name myenv python=3.6        conda activate ENVIRONMENT：切換至指定工作環境  conda deactivate：回到 base 工作環境  conda list：active 環境中的所有套件          Build Channel的pypi表示是用pip install PACKAGENAME      pip freeze可以看到所有用pip install下載的套件        conda env remove --name ENV_NAME：刪除名稱為ENV_NAME的環境Reference:  輕鬆學習 Python：conda 的核心功能  Python — Virtualenv虛擬環境安裝",
      "url": " /python/2022/04/05/Python-%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83-(virtual-environment)-conda-create-%E8%88%87-virtualenv-%E6%AF%94%E8%BC%83/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "web-2021-08-22-web-mvc-e6-9e-b6-e6-a7-8b": {
      "title": "[Web]MVC 架構",
      "content"	 : "這篇簡單地介紹 MVC 架構，若是有任何錯誤觀念，歡迎留言。之前用 node.js 的 express 加上 MVC 架構寫了一個 TO DO LIST，也許有這個例子可以更容易理解。What is MVC?MVC 的三個字母分別表示 Model、View 和 Controller，是一種在軟體開發時的軟體架構 (architectural pattern) ，由 Trygve Reenskaug 在 1978 年提出，是為了 Smalltalk （一種程式語言）所發明的一種軟體架構（wiki）。它的設計原則是「關注點分離 (separation of concerns, SOC) 」，把不同作用的程式碼放在不同的檔案裡，讓大家各司其職。圖解 MVC下圖簡單的說明了，MVC 的流程。圖片來源使用者操作網站與網站互動，當使用者點選網頁發出 request（可能登入、點進連結、加入購物車…..等等）後，Controller 會去接收這個 User 傳來的 request，並根據請求和 Model 要資料，當 Model 吐出資料給 Controller 後，Controller 再把資料丟給 View 讓前端去顯示，這時候 User 就會看到前端顯示出剛剛送出 request 後產生的畫面。從上面的說明可以發現，Controller 扮演了重要的角色，它除了接收使用者的要求，也負責協調工作給 Model 與 View，讓每個部分都獨立專注在自己的工作，彼此之前不會直接的溝通，都是靠 Controller 傳話。我覺得可以想像成 View 和 Model 各是一個部門，兩個部門有各自負責的工作且彼此之間不會直接對話與干預彼此，而使用者就是老闆，Controller 負責把老闆的任務分配給各部門，並作為各個部門之間溝通與傳遞消息的角色，讓 View 和 Model 不用知道對方在幹嘛也能讓每個任務順利完成。舉一個例子，有一個使用者輸入帳號和密碼要登入一個網站，當使用者點選登入後會送出 request 到 Controller，這時候 Controller 將這個消息告訴 Model，並請 Model 檢查使用者輸入的帳號密碼是否正確，Model 收到指令後會去和 DB 確認，確認完之後會將結果傳回給 Controller（可能是帳號密碼正確或錯誤），Controller 再把這個結果給 View，View 就能根據結果顯示在網頁上，如果成功就順利登入，如果帳號密碼錯誤就顯示失敗。下面這個圖，加上了前端和後端，View 負責的內容會是使用者看到的畫面（前端），而 Controller 和 Model 是使用者不會注意到背後運作的東西，而與 DB 拿資料就是 Model 的任務。圖片來源Model, View, Controller下面再來詳細的介紹一下 MVC 它們的工作內容。Controller從上面的圖例我們知道 Controller 是負責接收使用者的 request 並將資料分配給 Model 和 View 的重要角色。它將使用者的 request 傳給 Model，請 Model 去拿取資料，之後再將 Model 給的資料送給 View，讓 View 將資料呈現在前端讓使用者可以看到。因此 Controller 決定了整個任務的工作流程，並決定最後如何呈現。下面幾個來自「MVC 架構是什麼？認識 Model-View-Controller 軟體設計模式」的例子  使用者是否需要先登入 (認證) 才可以看到網頁內容？  使用者是否只能閱讀資料，但不能修改或刪除？  使用者新增了資料之後，會重新導向至哪個頁面？ModelModel 主要負責和資料庫溝通以及商業邏輯有關的任務。Model 可以直接對資料庫做存取，但它並不關心資料之後如何被顯示或操作。而所謂的商業邏輯可以這樣理解，假設今天有一個滿千折打九折的折扣，像這樣的「商業邏輯」就可以使用一個 model 去處理使用者的訂單；又或者今天在寫一個部落格的網站，就可以有 post 和 comment 這兩個 model 去對資料庫寫進新的文章和留言的功能。View網頁的前端，使用者看到的部分，也就是 HTML 的部分。MVC 優點  不管是誰寫，檔案存放的邏輯不會差太多  程式碼可以重複利用（reusable）  更容易維護程式碼  方便團隊合作：團隊各在開發時可以各自負責不同部分，不會互相影響Route 與 MVC 框架前面介紹的 MVC 架構當使用者送出 request 後是直接由 Controller 去接收做處理，但如果網頁的 request 是由 Route 去處理，這樣 Controller 接收的訊息就會是由 Route 傳送過來的，但其他的工作內容基本上和前面介紹的 MVC 是一樣的。如果想要具體的了解可以看這篇「Node.js-Backend 見聞錄(10)：關於後端觀念(六)-關於 MVC 」，比較具體地介紹 node.js route 的 MVC 架構。圖片來源*上圖 Routing 上面的「Laravel」是 PHP 的一個 web framwork，因為圖片來源的文章是在講解 PHP。  Model-View-Controller (MVC)   MVC 架構是什麼？認識 Model-View-Controller 軟體設計模式  [Day 01] 什麼是 MVC？能吃嗎？   什麼是 MVC 網頁設計? 做網站一定需要 MVC 嗎?  Node.js Crash Course Tutorial #11 - Express Router &amp;amp; MVC",
      "url": " /web/2021/08/22/Web-MVC-%E6%9E%B6%E6%A7%8B/",
      "author": "Shihs",
      "categories": "Web"
    }
    ,
  

    "python-2021-08-21-python-e5-9c-a8-mac-e4-b8-8b-e8-bc-89-e8-88-87-e5-ae-89-e8-a3-9d-miniconda": {
      "title": "[Python]在 Mac 下載與安裝 Miniconda",
      "content"	 : "Conda 是除了能夠管理套件也能夠管理工作環境，是個好用的工具。之前是下載 Anaconda 來使用 Conda，但 Anaconda 在最一開始下載時就會下載很多套件，可是大多數的套件其實都用不到，卻又佔用了大量的空間（Anaconda 在刪除前在我的電腦佔用了十幾 GB），因此決定轉換使用 Miniconda 來使用 conda。刪除 Anaconda參考官網的 uninstall Anaconda 的方法。原本想使用第二種方法 conda install anaconda-clean，但在下載 anaconda-clean 時一直碰到問題，所以最後決定使用第一種方法。直接刪除整個 rm -rf ~/anaconda3 資料夾，為避免這種刪法沒有刪乾淨，再手動搜尋 anaconda 刪除所有相關的檔案。下載與安裝 Miniconda  到官網下載 Miniconda          根據步驟一直點選下一步就好        安裝完成後，Miniconda 會自動在 .zchrc 和 .bash_profile 加上路徑     # &amp;gt;&amp;gt;&amp;gt; conda initialize &amp;gt;&amp;gt;&amp;gt; # !! Contents within this block are managed by &#39;conda init&#39; !! __conda_setup=&quot;$(&#39;/Users/your_user_name/opt/miniconda3/bin/conda&#39; &#39;shell.bash&#39; &#39;hook&#39; 2&amp;gt; /dev/null)&quot; if [ $? -eq 0 ]; then     eval &quot;$__conda_setup&quot; else     if [ -f &quot;/Users/your_user_name/opt/miniconda3/etc/profile.d/conda.sh&quot; ]; then         . &quot;/Users/your_user_name/opt/miniconda3/etc/profile.d/conda.sh&quot;     else         export PATH=&quot;/Users/your_user_name/opt/miniconda3/bin:$PATH&quot;     fi fi unset __conda_setup # &amp;lt;&amp;lt;&amp;lt; conda initialize &amp;lt;&amp;lt;&amp;lt;        確認是否安裝成功          打開 terminal，conda --version 如果能正確顯示 conda 版本，就表示 conda 順利安裝完成！      conda 常用指令Cheatsheet  Documentconda 的資訊  conda --version：檢視 conda 版本  conda update conda：更新 conda 版本  conda env list：conda 所有的環境conda basic  conda install PACKAGENAME：Install a package included in Anaconda  conda update PACKAGENAME：Update any installed program環境  conda create --name ENV_NAME python=VERSION：建立特定版本，名稱為ENV_NAME的環境          Ex. conda create --name myenv python=3.6        conda activate ENVIRONMENT：切換至指定工作環境  conda deactivate：回到 base 工作環境  conda list：active 環境中的所有套件          Build Channel的pypi表示是用pip install PACKAGENAME      pip freeze可以看到所有用pip install下載的套件        conda env remove --name ENV_NAME：刪除名稱為ENV_NAME的環境",
      "url": " /python/2021/08/21/Python-%E5%9C%A8-Mac-%E4%B8%8B%E8%BC%89%E8%88%87%E5%AE%89%E8%A3%9D-Miniconda/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "sql-2021-08-16-e5-9c-a8-mac-e6-9c-ac-e6-a9-9f-e5-ae-89-e8-a3-9d-mysql-phpmyadmin": {
      "title": "[SQL]在 Mac 本機安裝 MySQL &amp; phpmyadmin",
      "content"	 : "1. 啟動 Apache  sudo apachectl start  打開瀏覽器 http://localhost/ 可以看到 It works!2. 下載 MySQL  https://dev.mysql.com/downloads/mysql/  選擇下載 .dmg 檔  下載完後安裝，安裝過程需要設定 root 的密碼  打開系統偏好設定會看到出現 MySQL 的圖示，點選後啟動 MySQL3. 使用 terminal 開啟 MySQL  mysql -u root -p（-u: user, -p: password）  出現 Enter password: 後輸入剛剛安裝時設定的 root 密碼4. 下載 phpmyadmin這個步驟不是必須，下載 phpmyadmin 是為了可以使用操作介面查看 MySQL。  下載 phpmyadmin：https://www.phpmyadmin.net/downloads/  瀏覽器打開 http://localhost/phpmyadmin/index.php5. 設定 phpmyadmin 登入密碼因為 phpmyadmin 的密碼身份驗證是 caching_sha2_password 所以會無法使用一開始設定的 root 與密碼登入，這時候需要先修改 db 的資料。  terminal 登入 MySQL（step 3）  將 root 的密碼身份驗證由 caching_sha2_password 改成 mysql_native_password          use mysql；（使用 mysql 這個 db）      ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;你的密碼&#39;;      FLUSH PRIVILEGES;        這時候 phpmyadmin 就可以使用設定好的 root 的密碼登入了新增新的 MySQL User通常不會讓所有人都使用 root 權限操作 db，這時候就需要增加新的 user 讓其他人使用。  terminal 登入 MySQL（step 3）  新增 User          use mysql；      CREATE USER &#39;USERNAME&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;PASSWORD&#39;;      ALTER USER &#39;username&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;      FLUSH PRIVILEGES;        設定完成後 phpmyadmin 和 terminal 都可以使用設定好的帳號密碼登入          mysql -u USERNAME -p / PASSWORD      設定新增 User 的權限  查看某 user 的權限：SHOW GRANTS FOR &#39;username&#39;@&#39;localhost&#39;;  GRANT 權限：GRANT type_of_permission ON database_name.table_name TO &#39;username&#39;@&#39;localhost&#39;;  REVOKE 權限：REVOKE type_of_permission ON database_name.table_name FROM &#39;username&#39;@&#39;localhost&#39;;  reload all the privileges：FLUSH PRIVILEGES;Reference  Mac 電腦執行 PHP &amp;amp; MySQL &amp;amp; phpMyadmin  phpmyadmin 連線 MySQL8.0 報錯#2054 - The server requested authentication method unknown to the client  How To Create New MySQL User and Grant Privileges  How To Create a New User and Grant Permissions in MySQL",
      "url": " /sql/2021/08/16/%E5%9C%A8-Mac-%E6%9C%AC%E6%A9%9F%E5%AE%89%E8%A3%9D-MySQL-&amp;-phpmyadmin/",
      "author": "Shihs",
      "categories": "SQL"
    }
    ,
  

    "git-2021-08-15-github-e6-96-b0-e7-9a-84-authentication-e8-a8-ad-e5-ae-9a": {
      "title": "[Git]Github 新的 authentication 設定",
      "content"	 : "Github 從 8/13 開始將以前的 password 認證方式刪除了，這裡記錄我解決的方法。  使用 ssh  使用 personal access token1. 使用 ssh情況：  之前已 clone 下來的 repo  修改後要 push 碰到下面的錯誤訊息remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.fatal: unable to access &#39;https://github.com/shihs/to-do-list-app.git/&#39;: The requested URL returned error: 403Step 1: Enabling two-factor authentication  根據錯誤訊息提供的網址，先去 Enabling two-factor authentication，照著 Configuring two-factor authentication recovery methods 的步驟做（裡面提到的 TOTP app 我是用 Salesforce Authenticator）。Step 2: 加 ssh key  確認 github 是否已經加了 ssh key ssh -t git@github.com，如果沒加會出現像這樣的訊息  在本機 gen ssh key，並在 github 頁面新增 ssh key。我主要是參考下面兩個網址：          Git 版本控制筆記 - 使用 github 及 ssh 金鑰設定      生成新 SSH 密钥并添加到 ssh-agent        完成之後在 terminal 打上 ssh -t git@github.com 會是Step 3: 重新 push  git remote set-url origin git@github.com:[your-github-name]/[repo-name].git  重新 add 和 commit 修改，就可以 push 了但這樣的方法還是很麻煩……每一支 reop 都要重新 git remote set-url origin ... 所以另一個方法是使用 personal access token。Reference:GitHub Support for password authentication was removed (August 13, 2021) - Solution2. 使用 personal access token這裡的方法是在 Mac 的操作。Step 1:  參照 github 提供的方法，Creating a personal access token。          Settings -&amp;gt; Developer settings -&amp;gt; Personal access tokens -&amp;gt; Generate new token      Step 2: 將 create 出來的 token 加到「鑰匙圈」裡  使用 spotlight 搜尋「keychain」  在 keychain 上搜尋「github」，找到 github  點選下方「顯示密碼」，並將密碼改成剛剛在 github 上 create 的 token現在可以任意地使用之前 clone 下來的 repo 了，不過如果剛剛 create token 有時間限制，之後必須要再重新建立新的密碼並修改。Reference:Solved - Support for password authentication was removed - Github - Mac and Windows",
      "url": " /git/2021/08/15/Github-%E6%96%B0%E7%9A%84-authentication-%E8%A8%AD%E5%AE%9A/",
      "author": "Shihs",
      "categories": "Git"
    }
    ,
  

    "e5-89-8d-e7-ab-af-2021-03-07-e5-89-8d-e7-ab-af-cookie-session": {
      "title": "[前端]Cookie &amp; Session",
      "content"	 : "在邊閱讀網路資訊的時候，我對於 cookie 和 session 從覺得理解到感到困惑，到後來又覺得好像懂了，但也許不是百分之百正確。我盡量把理解的東西寫下來，但如果有任何錯誤，歡迎指正。重點Session 和 Cookie 的目的是用來讓 Sever 知道 Client 的狀態，而 Cookie 是將狀態資料存在 Client 端（Browser），而 Session 則是將資料存在 Server 端（e.g Redis）HTTP 的 stateless（無狀態）前面說到「Session 和 Cookie 的目的是用來讓 Sever 知道 Client 的狀態」，但  為什麼 Server 不知道 Client 的狀態呢？  為什麼需要讓 Sever 知道 Client 的狀態呢？要回答第一個問題，就要先知道「HTTP 是 stateless（無狀態）」，而 stateless（無狀態）的定義是  Server 和 Client 不會記住（retain）之前的連線  每個 Client 送出的 request 都被視為是唯一且獨立的 connection舉個例子，https://dotblogs.com.tw/jimmyyu/2010/10/16/difference-between-stateful-and-stateless上面這個網址是我在搜尋「無狀態」時找到覺得解釋得不錯的部落格，而我從我的瀏覽器打開這個網頁，和你從你的瀏覽器輸入這個網址打開，基本是上一樣的，並不需要先連到其他網頁，像這樣子的情況就稱為 stateless（無狀態）。解決第一個問題後，那 stateless 就 stateless 啊，為什麼要讓 Server 知道 Client 的狀態呢？想想看，我們在使用 facebook 或是 instagram 等等很多網站都必須要先登入後才能觀看到想看到的頁面；或是，在網拍網站上如果我們把東西加到購物車，當下次登入時打開，還能夠看到上次加入的商品。但以剛剛 stateless（無狀態）的邏輯來思考，這件事情是不可能可以達成的，因為假如每次的 request 都是獨立且唯一的，那這樣每一次重新點選網頁都會是一個新的事件，Server 就像是失憶一樣，根本不會記得曾經發生過什麼事情，所以當 Client 端做了改變（ex. 登入、商品加入購物車…等等），Sever 端並不會知道，當我們想要做任何事情，每一次都必須要重新來一遍才行。這就是為什麼我們會想要讓 Server 知道 Client 的狀態了（Stateful）。Cookie 是什麼？Cookie 是用來記錄 Client 與 Server 目前的溝通狀態，會以 name-value 的形式呈現，並且存在 Client 端。而這個 cookie 在 Client 端第一次發送 request 後，Server 會以 Set-Cookie 的方式寫在 response header，回應給 Client，而 Client 瀏覽器就會將這個 Cookie 存在本機端，下一次要再次送 request 時，會把這個已儲存的 Cookie 已 Cookie 的方式存在 resquest header 和 request 一起送出，讓 Sever 知道這個 Client 目前的狀態。（可以用 Chrome 的開法者模式看 network 中網頁的 Response Headers 和 Request Headers 找到 Set-Cookie 和 Cookie）但這樣儲存 Cookie 又會有什麼問題呢？      Cookie size 的限制：根據 RFC-2965 的規定，一個 Cookie 最大只能是 4096 bytes。        佔據網路流量：由於每次 request 都會傳送 Cookie 資料，所以當 Cookie 資料越來越大，request 傳輸的資訊也會更著變大，這樣就會影響網路傳輸的速度。        Cookie 可能被 Client 竄改：由於 Cookie 存在 Client 端，所以 Client 是可以完整的看到 Cookie 資料的，那如果 Cookie 竄改或者是外洩，這樣就存在著資安的風險。  根據以上的問題，我們可以知道，Cookie 中不能存放有資安疑慮的資料，也不能存放太大的資訊量。所以為了彌補這些不足，就有了 Session 的出現。Session 是什麼？Session 是一種比 Cookie 更安全的狀態管理機制。既然 Session 是為了彌補 Cookie 的不足，它就必須要解決上面提到的 Cookie 可能會有的問題。所以 Session 會將狀態資訊存在 Sever 端，以避免 Client 端可以任意修改資訊，此方法也能避免儲存與傳輸的資料過大的問題。而為了要讓 Client 端知道 Session 儲存的資訊，Server 端會在 response 的 Cookie 中回傳一組 SessionID 讓 Client 儲存在 Cookie 裡，當下次 Client 送出 request 時，就在 Cookie 裡一起送出這組 SessionID，而 Server 就可以透過這組 SessionID 去驗證這個 Client 身份，並知道上一次儲存的狀態，然後回傳內容。Reference:前端三十｜27. [WEB] Cookie &amp;amp; Session 是什麼？[ASP.NET]Stateful與Stateless白話 Session 與 Cookie：從經營雜貨店開始淺談 Authentication 上集：Cookie 與 Session 介紹",
      "url": " /%E5%89%8D%E7%AB%AF/2021/03/07/%E5%89%8D%E7%AB%AF-Cookie-&amp;-Session/",
      "author": "Shihs",
      "categories": "前端"
    }
    ,
  

    "python-2021-01-22-python-asyncio-e5-92-8c-await": {
      "title": "[Python]asyncio 和 await",
      "content"	 : "import requestsimport timeimport asynciourl = &#39;https://www.google.com.tw/&#39;loop = asyncio.get_event_loop()start_time = time.time()async def send_req(url):    t = time.time()    print(&quot;Send a request at&quot;,t-start_time,&quot;seconds.&quot;)    res = await loop.run_in_executor(None,requests.get,url)    t = time.time()    print(&quot;Receive a response at&quot;,t-start_time,&quot;seconds.&quot;)tasks = []for i in range(10):    task = loop.create_task(send_req(url))    tasks.append(task)loop.run_until_complete(asyncio.wait(tasks))Reference:python的asyncio模組(一)：異步執行的好處",
      "url": " /python/2021/01/22/Python-asyncio-%E5%92%8C-await/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "javascript-2021-01-16-javascript-callbac-promise-async-and-await": {
      "title": "[javascript]同步 v.s. 非同步與callback, promise, async, and await",
      "content"	 : "之前因為在學 node.js 寫過一篇文章介紹同步非同步以及 callback，但之前沒有實際使用的經驗，有點懵懵懂懂，現在有了一些實際的應用的範例，所以想要再重新整理一次，並加上 promise、async, 與 await。JavaScript Engine 是以單執行緒（單線程/Single Thread）且同步（Synchronous）的方式執行。同步（Synchronous）  指程式必須等待前面的程式執行完才能執行。非同步（Asynchronous）  指程式不須等待前面的程式執行完就能執行。note      執行緒（thread）：執行緒是比程序（process）更小的單元，它是 CPU 的最小執行單元。是作業系統能夠進行運算排程的最小單位。一個程序（process），至少包含一個或多個執行緒。(source)        單執行緒：單執行的特性是順序執行，當遇到比較耗時的任務時，還未執行的任務就會處於等待狀態，一定要等到前面的任務完成了，才會往後執行。(source)  因為 JavaScript 是以單執行緒且同步的方式去執行，它在執行程式碼的時候會按照順序將程式碼片段在堆疊中（stack）執行，而且一次只會執行一個程式碼片段（one thing at a time），只是當碰到非同步（Asynchronous）的任務時，會把它往後放，放到事件佇列(Event Queue)中，等所有的任務完成後才會回來執行。以下面程式碼為例，// setTimeout(callbackFunction, timeToDelay)setTimeout(() =&amp;gt; {  console.log(&#39;a&#39;);}, 0);console.log(&#39;b&#39;);印出來的結果會是basetTimeout 是一個非同步的 Web API，JavaScript 執行到這段的時候會將 setTimeout 放到 Event Queue 中等待，等 stack 中的任務都執行完才回來執行，所以會先印出b再印a。Callbackcallback 是 javascript 中很常見的一種使用方式，它讓函式可以當成參數傳進另一個參數中使用，讓我們可以控制程式碼的流程。看以下範例，function test() {    console.log(&quot;This test function is done.&quot;);}function main(callback) {    console.log(&quot;This is main start.&quot;);    callback();    console.log(&quot;This is main end.&quot;);}main(test);// This is main start.// This test function is done.// This is main end.但其實更多時候 callback 會牽扯到非同步 API 的狀況，像是下面的例子，function test() {    // 這邊模擬 test 這個 function 去 call 其他 API 要等待的情況    // 等了一秒後才會執行 console.log 這個函式    setTimeout(()=&amp;gt; {        console.log(&quot;This test function is done.&quot;);    }, 1000);}function main(callback) {    console.log(&quot;This is main start.&quot;);    callback();    console.log(&quot;This is main end.&quot;);}main(test);// This is main start.// This is main end.// This test function is done.這次callback()因為會有等待的情況，所以後面的 “This is main end.” 先被執行完。那假如想要callback()執行完才執行下一行該怎麼做呢？（譬如說，這個callback()在做的是使用XMLHttpRequest()送 request 給某個網頁，而下面的程式碼必須等待網頁的 response 才可以執行下面的程式碼。）這時候只要把，執行 “This is main end.” 這行程式碼也當成 callback() 傳進去就行了。function test(callback2) {    // 這邊模擬 test 這個 function 去 call 其他 API 要等待的情況    // 等了一秒後才會執行 console.log 這個函式    setTimeout(() =&amp;gt; {        console.log(&quot;This test function is done.&quot;);        callback2();    }, 1000);}function main(callback) {    console.log(&quot;This is main start.&quot;);    callback(() =&amp;gt; {        console.log(&quot;This is main end.&quot;);    });}main(test);// This is main start.// This test function is done.// This is main end.所以 callback 可以用來解決非同步的問題，但是當 callback 越來越多，就會形成 callback hell，就像是下面這樣，function api1(callback) {    setTimeout(() =&amp;gt; {        console.log(&quot;Done with api1&quot;);        callback();    }, 2000);}function api2(callback) {    setTimeout(() =&amp;gt; {        console.log(&quot;Done with api2&quot;);        callback();    }, 1000);}function main(callback) {    api1(() =&amp;gt; {        api2(() =&amp;gt; {            callback();        });    });}main(() =&amp;gt; {    console.log(&quot;All function is done.&quot;);});// &quot;Done with api1&quot;// &quot;Done with api2&quot;// &quot;All function is done.&quot;甚至變成api1(() =&amp;gt; {    api2(() =&amp;gt; {        api3(() =&amp;gt; {            api4(() =&amp;gt; {                // bla bla bla            });        });    });});PromisePromise 也是一個可以用來處理非同步操作的東西。Promise 通常包括三種狀態：resolve、reject和pending。resolve代表成功，rejetc代表失敗，pending代表還在處理中, 結束狀態未知。then()方法可以回傳Promise物件。例如，現在想要使用XMLHttpRequest() API傳送 request，我們需要等待 response 後才有後續動作。function sleep(ms) {  return new Promise(resolve =&amp;gt; setTimeout(resolve, ms));}function sendHttp() {url = &quot;https://www.google.com/&quot;;var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, url);xhr.responseType = &quot;document&quot;;xhr.send();// 如果沒等待 response，status 和 response 會是 0 和 null// console.log(xhr.status);// console.log(xhr.response);sleep(2000).then((result) =&amp;gt; {console.log(xhr.status);console.log(xhr.response);});}sendHttp();then() 其實是可以一直往後加，就是像callback，想要前面的事情做完，才做下面，形成 Promise Chain，但這樣就又會變成 then hell。所以這時候出現了 async 和 await，讓程式碼看起來更容易閱讀。Async/Awaitasync/await 還是會用到 promise，但不使用 then 去啟動。像剛剛上面的例子，可以改寫成下面這樣，function sleep(ms) {  return new Promise(resolve =&amp;gt; setTimeout(resolve, ms));}async function sendHttp() {url = &quot;https://www.google.com/&quot;;var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, url);xhr.responseType = &quot;document&quot;;xhr.send();await sleep(2000);// 如果需要更多 sleep(2000)// await sleep(2000);console.log(xhr.status);console.log(xhr.response);}sendHttp();在sendHttp()這個 function 前加上 async，並在sleep(2000)前加上 await 就好，整體畫面看起來是不是容易閱讀很多？如果需要更多的sleep(2000)，只需要多加 await 往下寫就好，整個畫面看起來容易閱讀很多。Reference:非同步(Asynchronous)與同步(Synchronous)的差異世界上誤解最大的語言 JavaScript 之 JS 到底是同步與非同步語言?![筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth）callback, promise, async/await 使用方式教學以及介紹 Part I",
      "url": " /javascript/2021/01/16/javascript-callbac,-promise,-async,-and-await/",
      "author": "Shihs",
      "categories": "javascript"
    }
    ,
  

    "javascript-2020-12-03-javascript-traversing-the-dom": {
      "title": "[javascript]Traversing the DOM",
      "content"	 : "整理 Treehouse 前端課程中 JavaScript and the DOM 的最後一節 Traversing the DOM 內容。DOM Traversal 的意思是，可以透過一個 element 與這個 element 的關係去選取其他的 element。parentNode  parentNode：顧名思義，選取被選取的 element 的 parent node。// 選取 id 為 myParagraph 的 nodelet paragraph = document.getElementbyId(&#39;myParagraph&#39;); // 使用 paragraph 選取它的 parent nodelet parent = paragraph.parenNode; // 可以直接利用這個 parent node 做些事parent.removeChild(paragraph); // 刪除 paragraph nodepreviousElementSibling &amp;amp; insertBefore  previousElementSibling：選取被選取的 element 前一個的 sibling。  insertBefore：將被選取的 element 插入在某一個 element 之前， let insertedNode = parentNode.insertBefore(newNode, referenceNode)previousSibling v.s. previousSibling為什麼 sibling 要特別加上 ‘Element’ 呢？因為如果使用 previousSibling 他會抓取前一個 sibling node，不管它是什麼。而我們前一篇講過， node 包含 document、element、attribute 和 text。所以使用 previousElementSibling 我們就只會抓前面的 element sibling。在課程的範例中，現在想要按了 Up 按鈕之後，該 &amp;lt;li&amp;gt; 就會上移。&amp;lt;ul&amp;gt;  &amp;lt;li&amp;gt;grapes     &amp;lt;button class=&quot;up&quot;&amp;gt;Up&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;remove&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;  &amp;lt;/li&amp;gt;  &amp;lt;li&amp;gt;amethyst     &amp;lt;button class=&quot;up&quot;&amp;gt;Up&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;remove&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;  &amp;lt;/li&amp;gt;  &amp;lt;li&amp;gt;lavender     &amp;lt;button class=&quot;up&quot;&amp;gt;Up&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;remove&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;  &amp;lt;/li&amp;gt;  &amp;lt;li&amp;gt;plums     &amp;lt;button class=&quot;up&quot;&amp;gt;Up&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;remove&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;  &amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;// 選取 ul 的 tagconst listDiv = document.querySelector(&#39;.list&#39;);const listUl = listDiv.querySelector(&#39;ul&#39;);// 按下 up 按鈕之後，該 li tag 會往上移listUl.addEventListener(&#39;click&#39;, (event) =&amp;gt; {  if(event.target.className == &#39;up&#39;) {  // 被 click 的 button 的 parent node 就是 li    let li = event.target.parentNode;     // 被選取的 li tag 的 previous element sibiling，也就是前一個 li tag    let prevLi = li.previousElementSibling;     // 這個 li 的 parent node    let ul = li.parentNode;     // 如果 prevLi 不是 null，換句話說，不是第一個    if (prevLi) {      // 將被選取的 li tag 往前移      ul.insertBefore(li, prevLi);     }  }});nextElementSibling &amp;amp; insertBefore按了 down button 之後，該 li 往下移。基本上概念和剛剛上面往前一是一樣的，只是現在使用 nextElementSibling，去選取後面的 element。&amp;lt;ul&amp;gt;  &amp;lt;li&amp;gt;grapes     &amp;lt;button class=&quot;up&quot;&amp;gt;Up&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;down&quot;&amp;gt;Down&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;remove&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;  &amp;lt;/li&amp;gt;  &amp;lt;li&amp;gt;amethyst     &amp;lt;button class=&quot;up&quot;&amp;gt;Up&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;down&quot;&amp;gt;Down&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;remove&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;  &amp;lt;/li&amp;gt;  &amp;lt;li&amp;gt;lavender     &amp;lt;button class=&quot;up&quot;&amp;gt;Up&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;down&quot;&amp;gt;Down&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;remove&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;  &amp;lt;/li&amp;gt;  &amp;lt;li&amp;gt;plums     &amp;lt;button class=&quot;up&quot;&amp;gt;Up&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;down&quot;&amp;gt;Down&amp;lt;/button&amp;gt;    &amp;lt;button class=&quot;remove&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;  &amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;// 選取 ul 的 tagconst listDiv = document.querySelector(&#39;.list&#39;);const listUl = listDiv.querySelector(&#39;ul&#39;);// 按下 up 按鈕之後，該 li tag 會往上移listUl.addEventListener(&#39;click&#39;, (event) =&amp;gt; {  if(event.target.className == &#39;down&#39;) {    let li = event.target.parentNode;    let nextLi = li.nextElementSibling;    let ul = li.parentNode;    if (nextLi) {      ul.insertBefore(nextLi, li);    }      }});children.children 可以選取該 element 底下所有的 child element。const listDiv = document.querySelector(&#39;.list&#39;);const listUl = listDiv.querySelector(&#39;ul&#39;);// lisUl 底下的 child，也就是 li tagconst lis = listUl.children;firstChild &amp;amp; lastChild v.s. firstElementChild &amp;amp; lastElementChild選取該 element 的第一個或最後一個 child。同樣的，firstElementChild &amp;amp; lastElementChild 選取的會是 element。",
      "url": " /javascript/2020/12/03/javascript-Traversing-the-DOM/",
      "author": "Shihs",
      "categories": "javascript"
    }
    ,
  

    "html-2020-11-13-html-e6-96-87-e4-bb-b6-e7-89-a9-e4-bb-b6-e6-a8-a1-e5-9e-8b-document-object-model": {
      "title": "[HTML]文件物件模型（Document Object Model）",
      "content"	 : "DOM 是什麼？DOM 是 Document Object Model（文件物件模型）的縮寫，它是 HTML、XML 和 SVG 文件的程式介面（programming interface）；可以理解成 DOM 是文件和程式溝通的橋樑、介面，也可以說，DOM 是針對 HTML、XML 和 SVG 提供的一個 API，為了讓程式（ex. JavaScript）能夠操作文件的內容。DOM 將文件（HTML、XML 和 SVG）用樹狀結構表示（如下圖），樹中的每一個節點（node）皆為物件（object），DOM 定義了一些方法讓程式可以存取這些的節點（node）/ 物件（object）並改變文件架構、風格（CSS）和內容。Treehouse 的課程這樣解釋：  The DOM is a represenation (map) of a webpage that JavaScript can use.  The DOM represents a web page as a tree-like structure.另外，寫網頁的時候常使用 JavaScript 來存取 DOM，但 DOM 並不屬於 JavaScript 語言的一部分，只是我們常用 JavaScript 去存取 DOM，換句話說，JavaScript 可以用其他語言取代，只是不常見。                              The DOM represents a web page as a tree-like structure                                    Example of DOM hierarchy in an HTML document      為什麼需要 DOM？為的是要讓不同的瀏覽器有一樣的文件物件模型標準，否則我們現在就都得針對不同的瀏覽器個別寫程式碼了。而這個標準是由 W3C（全球資訊網協會）所定義的。DOM 解析DOM 的樹狀結構中最重要的就是節點（node），而節點可以分為下列四種（以 HTML 為例，看上圖）：      Document：Document 就是指這整份文件，就是這份 HTML 檔的開端，所有的 nodes 都會從 Document 開始往下。        Element：Element 是指文件內的各個標籤，像是 &amp;lt;html&amp;gt;、&amp;lt;body&amp;gt;、&amp;lt;div&amp;gt;、&amp;lt;p&amp;gt; 等等各種 HTML Tag 都被歸類在 Element。        Attribute：Attribute 是指各個標籤內的相關屬性，像是 name、class、href 等等都是被歸類在 Attribute。        Text：Text 是指被各個標籤包起來的文字，像是 &amp;lt;h1&amp;gt;Hi&amp;lt;/h1&amp;gt; 中， Hi 被 &amp;lt;h1&amp;gt; 這個 Element 包起來，因此 Hi 就是此 Element 的 Text。  API = DOM + JavaScript這邊介紹一些常見的 DOM API，document.body;document.getElementById(&#39;idName&#39;);document.getElementsByTagName(&#39;tagName&#39;);document.getElementsByClassName(&#39;className&#39;);// selector 可以是 id:#idName, class:.className, tag:tagName, or CSS pseudo-classdocument.querySelector(&#39;selector&#39;); document.querySelectorAll(&#39;selector&#39;);補充：BOM &amp;amp; windowBOM 是 Browser Object Model（瀏覽器物件模型）的縮寫。DOM 是文件和程式溝通的接口，BOM 則是和瀏覽器溝通的接口。像是跳轉到其他頁面、螢幕大小的參數等等可以操作的方法或屬性。同樣的 BOM 也有很多屬於它的 object，像是 location，下面這個程式碼可以讓瀏覽器跳轉到另一個頁面：location.href = &quot;http://www.xxxx.com&quot;;而 windows 也是 BOM 的一個 object。「關閉視窗」可以這樣寫，window.close();Reference:Day03-深入理解網頁架構：DOMW3C DOM文件物件模型 (DOM)JavaScript DOM (Document Object Model)DOM, DOCUMENT, BOM, WINDOW 有什么区别?",
      "url": " /html/2020/11/13/HTML-%E6%96%87%E4%BB%B6%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B-Document-Object-Model/",
      "author": "Shihs",
      "categories": "HTML"
    }
    ,
  

    "javascript-node-js-2020-07-27-node-js-callback": {
      "title": "[node.js]非同步（Asynchronous）、同步（Synchronous）、callback",
      "content"	 : "簡單介紹 node.js 裡重要的「非同步（Asynchronous）」概念，那既然有「非同步（Asynchronous）」當然就會有「同步（Synchronous）」，以及因為「非同步（Asynchronous）」而衍伸出的重要 callback 概念。Node.js 是一個單執行緒且非同步的語言。note      執行緒：執行緒是比程序更小的單元，它是 cpu 的最小執行單元。是作業系統能夠進行運算排程的最小單位。一個程序，至少包含一個或多個執行緒。(source)        單執行緒：單執行的特性是順序執行，當遇到比較耗時的任務時，還未執行的任務就會處於等待狀態，一定要等到前面的任務完成了，才會往後執行。(source)  Asynchronous（非同步）&amp;amp; Event queue（事件佇列）以上提到，單執行緒「還未執行的任務就會處於等待狀態」，所謂的「未執行任務」必須要是非同步（Asynchronous）function 才行，而「等待狀態」是指那些任務會被放到 Event queue，而 Event queue 的事件在所有事件完成前不會被執行。簡單的說，程式碼一行一行執行，當遇到非同步（Asynchronous）function 時，就會先執行下一行的任務，而這個還未被執行的非同步（Asynchronous）function 就會被放到 Event queue 中等到最後才執行。同步（Synchronous）  指程式必須等待前面的程式執行完才能執行。如果 function 是同步(Synchronous)，那就不管如何都會等這行執行完才執行下一行程式碼。例如，writeFileSync()就是同步(Synchronous) function。但先等這行程式碼執行完再執行下一行有什麼問題呢？假如今天要寫的檔案內容超級大，那麼所有工作就會全部停擺，等到這行程式碼完成才能進行，而非同步（Asynchronous）function 便能解決這個問題。非同步（Asynchronous）  指程式不須等待前面的程式執行完就能執行。下面舉一個常見的非同步 function，setTimeout()（第一個參數為時間到時要被執行的函式，第二個參數為要延遲的時間（毫秒）），setTimeout() 會在第二個參數的延遲時間後執行第一個參數的函式。setTimeout(() =&amp;gt; {console.log(&#39;Timer is done!&#39;)}, 1);console.log(&#39;Hello&#39;);console.log(&#39;Hi&#39;);以上程式碼印出來的結果會是，HelloHiTimer is done!因為 setTimeout() 裡的任務被放到 Event queue 中了，必須等到下面兩行程式碼跑完才接著跑 setTimeout() 裡的東西。callback但假如果我們現在就是想要讓程式執行完，才接著下一個任務該怎麼辦呢？所以這時候有了 callback。callback 讓我們把一個函式丟進另一個函式當參數，讓我們可以控制程式碼的流程。先看一個簡單的範例，function callbackSleepWorker() {  alert(&#39;OK, Im wake up !&#39;)}function ICallYouWhenIDone(callbackWorker) {  alert(&#39;OK, Im first.&#39;)  callbackWorker()}ICallYouWhenIDone(callbackSleepWorker)這個結果會先印出 ‘OK, Im first.’ 接著再印出 ‘OK, Im wake up !’。上面這個例子大概還看不太出來為什麼需要 callback，如果現在這個函式是個非同步函式呢？let money = nullfunction slower() {  setTimeout(function() {    money = 30  }, 200)}function faster() {  setTimeout(function() {    console.log(&#39;I have &#39; + money)  }, 100)}slower()faster()以上程式碼印出來的會是：I have null。明明是先跑了 slower() 但 money 卻沒先被負值，這是因為 setTimeout() 是個非同步 function，所以它會先被放到 event queue 中，faster() 就先執行了。那如果我們現在想要讓 slower() 百分之百先執行可以怎麼做呢？let money = nullfunction slower(callbackWorker) {  setTimeout(function() {    money = 30    callbackWorker()  }, 200)}function faster() {  setTimeout(function() {    console.log(&#39;I have &#39; + money)  }, 100)}slower(faster)這時候印出來的結果就會是：I have 30現在有個任務是，讀檔案並計算長度var fs = require(&#39;fs&#39;);// fs.readFile(filename, callback(err, content))fs.readFile(&#39;test.txt&#39;, function(err, content){    var str = content.toString();    console.log(str.length);    console.log(&#39;finish&#39;);});console.log(&#39;not finish&#39;);本來 readFile() 這個 function 會先被放到 event queue 裡，然後接著印出 ‘not finish’，但我們現在把要讀檔案這個任務放在 callback 裡，所以變成只要讀完檔案就會立刻執行，’not finish’ 會等到檔案讀完才會進行。Reference:JS20min Day — 18 關於回呼生活化 (Callback)[Node.js] 理解 Node.js 事件驅動JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！鐵人賽：一次只能做一件事情的 JavaScriptJavaScript 核心篇 學習筆記: Chap.15–執行緒與同步/非同步",
      "url": " /javascript/node.js/2020/07/27/node.js-callback/",
      "author": "Shihs",
      "categories": "javascript, node.js"
    }
    ,
  

    "neural-20network-2020-02-13-neural-network-neural-network-3": {
      "title": "[Neural Network]Neural Network 3 - Backpropagation",
      "content"	 : "前面介紹了 neural network 使用 Gradient descent 來找 cost function 的最小值，那這篇要來介紹 neural network 如何使用 Backpropagation 這個演算法讓 neural network 訓練過程中更有效率。這篇是Neural networks的課程筆記。另外，覺得李宏毅老師的課程也講解的很清楚，所以我會搭配老師的課程內容。李宏毅老師和主要課程使用的符號不太ㄧ樣，但我還是使用他們原本各自的符號。Gradient DescentGradient descent 的目的是要找到 neural network 的 parameters 的最佳解。Network parameters: Gradient: 初始 parameters: ，計算 ，則 ，接著可以再繼續算出 在 neural network 裡 Gradient 的最大問題就是，neural network 有太多的參數，所以這裡我們要介紹的 Backpropagation 就是一個比較有效的計算 Gradient 的演算法。也就是說，Backpropagation 基本上就是 Gradient Descent，但是是一個有效率的演算法。前面我們舉的例子是手寫辨識，input 加上兩層的 hideen layers，總共的 weight 和 bias 加起來有 13,002 個參數。如下圖，為了講解方便，我們現在把整個 nerual network 簡化成每層只有一個神經元。如下圖，第一個神經元是 input，最後一個神經元是 outpu，中間是兩層的 hidden layer，所以 cost function 可以寫成，為了說明 Backpropagation 現在我們再把範圍縮小到最後一層的 hidden layer 和 output，如下圖。我們令最後的 output 為  表示它是在第 L 層，而 hidden layer 為   表示在第 L-1 層，所以上標就只是用來表達它們各自在哪一層而已。在  後的  是我們期望的輸出結果，我們希望 ，也就是說，這裡的 cost 值會是，以上圖的例子就會是，接著我們來看每一個神經元的值。根據前面學過的，我們知道每一個神經元都是由前面的 weight 和 bias 算出來了，也就是說那為了方便，我們把 sigmoid function 裡的式子用一個符號表示，而  就可以寫成，我們現在有了上面三個式子，那我們現在要如何計算權重  對於 cost function 的影響程度呢？換句話說，我們想要知道 cost function 對  的偏微分 。根據 chain rule，我們可以再將上式改寫成，下一個步驟要來計算每一個值，我們可以根據上面式子得到的 (1)(2)(3) 得到，所以可以將式子整理成，而這只是其中一個 training sample 算出來的 cost，而總代價函數應該是所有 training data 的平均，也就是而這其實只是 gradient 裡其中的一個 compenent，Gradient:如果要計算的是 bias 的偏微分，式子就會是，接下來，我們來看這個 cost function 對上一層 activation 的敏感度，前面我們看的是只有一個神經元的狀況，回到真實的 neural network 結構。一個神經元是來自前面很多神經元與 weight 和 bias 的計算，且一個 training data 的 cost 值是每個 output 減 expected value 平方的和。基本上，所有的式子都和只有一個神經元是一樣的，唯一有變化的是，因為，一個神經元會向下影響其他所有與它連接的神經元，所以必須將它們全部加起來。根據以上，只要不斷往回算就可以了。Reference:ML Lecture 7: BackpropagationBack-propagation",
      "url": " /neural%20network/2020/02/13/Neural-Network-Neural-Network-3/",
      "author": "Shihs",
      "categories": "Neural Network"
    }
    ,
  

    "nlp-machine-20learning-neural-20network-2020-02-02-nlp-cnn-in-nlp": {
      "title": "[NLP]CNN in NLP",
      "content"	 : "前一篇介紹了 CNN 的概念，這篇要來介紹 CNN 如何運用在 NLP 中。Yoon Kim 在 2014 年發表論文 Convolutional Neural Networks for Sentence Classification 提出將 CNN 運用在 NLP。上圖就是 Yoon Kim 論文提出的方法概念，和在圖像運用的 CNN 一樣，有 convolution 和 pooling，然後最後是一個 softmax function。我們先來看第一步，Convolution在圖片中，我們將圖片看成一個 nxm 的矩陣，每一格都是一個數字，而我們可以使用 filter(kernel) 來獲取想要的特徵。而在 NLP 中，如果想要將文字表示成數字，可以使用 word embedding，例如 word2vect、glove，或是 one-hot encode 的詞彙到索引詞向量表示方法。上圖中的第一個矩陣是 ‘I love this movie very much!’ 的 word embedding 矩陣，每一列代表一個 word 的向量。總共有七個字，每一個字用一個 5 維的向量表示，所以用一個 7x5 的矩陣表示。filter現在知道了輸入的表示法，那在 convolution 中最重要的 filter 要如何使用呢？一般 CNN 的 filter 會是一個方正矩陣，從左往右再往下滑動，但在 NLP 中，filter 矩陣會和向量的維度一樣，但一次可能滑動兩個字 (2-grams)、三個字 (3-grams)等等，這個稱作 region size，看上圖的第二大行，有紅色系、綠色系、黃色系三種 filter，分別代表 region size 4、3 和 2，且各有兩個，也就是總共有六個 filter。(像這樣移動的方式只有一個方向叫做，1D converlution)整張大圖的第三行，就是輸入矩陣 (channel) 乘上 filter 之後的結果。PoolingConvolution 的下一步是 pooling，上圖使用的是 max pooling，也就是取最大的值。pooling 後 flatten 所有值，最後一步 softmax function 便完成了。Reference:Simple Deep Neural Networks for Text ClassificationUnderstanding Convolutional Neural Networks for NLPIntroduction to 1D Convolutional Neural Networks in Keras for Time Sequences",
      "url": " /nlp/machine%20learning/neural%20network/2020/02/02/NLP-CNN-in-NLP/",
      "author": "Shihs",
      "categories": "NLP, Machine Learning, Neural Network"
    }
    ,
  

    "machine-20learning-neural-20network-2020-02-01-machine-learning-convolution-neural-n-e5-8d-b7-e7-a9-8d-e7-a5-9e-e7-b6-93-e7-b6-b2-e8-b7-af": {
      "title": "[Neural Network]Convolution Neural Network 卷積神經網路",
      "content"	 : "之前寫了兩篇的 CNN 課程筆記，但後來因為太忙沒有繼續看完課程就中斷了 T_T。[Machine Learning]Covolutional Neural Networks(CNN)(1)[Machine Learning]Covolutional Neural Networks(CNN)(2)卷積神經網絡(Convolutional Neural Network)簡稱 CNN，主要應用在影像辨識，這篇想要簡單的說明 CNN 的概念。先看下面兩張 CNN 概念圖圖片來源圖片來源從上圖可以看到整個流程各經過兩次的 Convolution、Pooling 和 Fully Connected，所以其實只要搞懂 Convolution、Pooling 和 Fully Connected 分別在做什麼就可以掌握 CNN 了。整個流程是，前面的 Convolution 和 Pooling (又稱為 subsampling) 在做的是 feature extraction (特徵擷取)，而 Fully connection 在做的是 classification (分類辨識)。1. Convolution Layer 卷積層Convolution Layer 由 filter 和激活函數 (ex. Relu) 所構成。下圖是常見的美圖效果，其實就是使用 filter 達成的圖片來源卷積 (Convolution) 做的是特徵擷取，而不同的效果在做的就是對不同的特徵做擷取。例如，銳化效果在做的就是強化邊緣的特徵，也就是加強擷取出邊緣的特徵。那所以卷積到底是如何擷取不同的特徵的呢？圖片來源特徵擷取的方式是使用 Filter (或稱作 Kernel) 來萃取圖片中的特徵，上圖是一個 3x3 window 的 filter，而算法就是像圖那樣移動 (移動的步數是 stride)，將數字相乘後再相加 (詳情可以看之前的筆記1、筆記2，包括 padding 和 stride 的概念)。美圖的不同效果就是使用不同的 Filter (Kernel) 做出來的。下圖是不同的 filter 做出來的效果圖片來源現在明白了 filter，但再回去看最一開始的流程圖，為什麼 converlution 有三個呢？這是因為使用了三個 filter 去擷取不同的特徵。看完 filter 再看 Relu。可以看到最上圖圖中有個 Relu，也就是將所有計算出來結果的負值都變為 0。圖片來源如果是彩色的圖，通常會有三個 channel (RGB)，也就是一開始輸入的 image 有三個，可以看下圖圖片來源2. Pooling Layer 池化層pooling 又稱為 subsampling，是為了提取特定區域主要特徵，但又想要減少參數的數量，以防止模型過擬合，常用的是 max pooling，也就是取該區域最大的值，也有 average pooling，也就是取該區域的平均值。圖片來源下圖是取 max pooling，使用 2x2 的 window，且 stride 為 23. Fully Connected Layer 全連接層Fully Connected Layer 主要是進行 Flattening 平坦化，將最後的矩陣轉換成一維，然後再使用傳統的 neural network + softmax()。參考我之前的[Neural Network]Neural Network 1以上就是 CNN 的流程。最後提一下，從上面的過程我們可以知道，CNN 整個過程中需要求解的參數是  Convolution layer filters  Full Connected Layer filters來源Reference:[資料分析&amp;amp;機器學習] 第5.1講: 卷積神經網絡介紹(Convolutional Neural Network)[機器學習 ML NOTE]Convolution Neural Network 卷積神經網路【DL笔记6】从此明白了卷积神经网络（CNN）Convolutional Neural Networks’ (CNN) Backward Propagation",
      "url": " /machine%20learning/neural%20network/2020/02/01/Machine-Learning-Convolution-Neural-N%E5%8D%B7%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF/",
      "author": "Shihs",
      "categories": "Machine Learning, Neural Network"
    }
    ,
  

    "neural-20network-2020-01-23-neural-network-neural-network-2": {
      "title": "[Neural Network]Neural Network 2 - Gradient descent",
      "content"	 : "上一篇說明了神經網路的基本原理，這篇我們要講解神經網路是如何學習的 - Gradient descent。這篇是Neural networks的課程筆記。在 Machine Learning 裡我們使用 training data 訓練得到一個 model，但這「訓練」到底是怎麼訓練的呢？訓練的過程，通常是要找到最小的 cost，也就是最後的結果與真實值差距越小越好。在 Neural Network 我們要訓練的變數就是前面一篇提到的 weight 和 bias。一開始我們隨機的給予這些數字，然後在一次次的學習中去改進 weight 和 bias 的值，找到最小的成本函數。在課程的例子裡，Neural Network function 的 input 是 784 個 pixel 的數字，output 是 10 個數字，0 到 9 的機率，parameters 是 weight 和 bias。但在cost function 中，weight 和 bias 變成了 input，而 output 就是 cost 的值，parameters 則是很多的 training pairs。我們可以把 cost function 這樣表示，cost 的算法是 Neural Network 算出來的值，扣掉正確值然後平方相加。學習過程中，我們將所有 training data 的 cost 相加平均（average cost of all training data），希望這個值越小越好。那我們要如何找到最小的 cost 值？如果 cost function 是一個像下圖的函數圖形，我們知道微分等於 0 可以找到最小值，但這並非一件容易的事，尤其是當我們有很多變數時。所以我們可以用的方法是，先隨機到函數圖形上的一點，然後根據該點的切線斜率來決定該往哪個方向移動可以找到最低點。這樣的方法，可以讓我們到 local minimum，我們無法確認找到的最小是否是 global minimum，因為這取決與一開始的 initial value。在進入 Gradient descent 之前，我想要先介紹一下基礎觀念。以下將會講解，  導函數 Derivative function 與導數 Derivative  方向導數 Directional derivative  偏導數 Partial derivative  梯度 Gradient導數 Derivative切線的斜率稱為「導數」（Derivative），也就是微分。定義成，偏導數 Partial derivative斜率求的是單變數的微分，而偏導數是在多變數中的某個變數方向的斜率。以兩個字變數為例，  為對  的偏導數，定義為 為對  的偏導數，定義為也就是對 x 或 y 方向做偏微分。方向導數 Directional derivative斜率求的是單變數的微分，在多變數中要求斜率必須要看是哪個方向的斜率，因為各個方向的斜率都不相同，這時要求的就是方向導數。假設函數 ，在定義域  平面上有一點  及單位向量 。則曲面  在  處，沿  的方向的斜率定義為，方向導數的意義在於，有助於計算出空間中某一場量  在某一特定方向  之變化率。梯度 Gradient梯度的定義就是對各個分量做偏微分。例如，現在是兩變數函數 ，其梯度  定義為若是變數有三個，則  定義為Gernal 來看，有 n 個變數的函數 ，我們可以寫成梯度 Gradient 的幾何意義，   表示曲面  之垂直向量，如下圖所示。   表在 P 點增量最大的方向，也就是 the direction of steepest increase梯度下降法 Gradient descentGradient descent 是一種最佳化方法。從上一部分，我們知道 P 點 gradeint 表示該點增量最大的方向。現在我們要找 cost function 的最小值，也就是該 function 斜率為 0 的點，當我們今天在 P 點知道哪個方向是會增加最快速的點，那就只要往反方向就會是減少最快速的方向了。也就是  是找尋 minimum cost 的方向。總的來說，梯度下降法 Gradient descent 就是不斷的在某個點 P 算它的 Gradient，然後往 Gradient 的反方向一定，直到找到 local minimum 為止（無法知道是否找到 glocal minimum，會根據 initial values 而定）。在 neural netword 中，讓這個梯度計算更有效率的方法叫做 Backpropagation，而這正是 neural netword 的重點！下一篇繼續介紹 :)Reference:方向導數(Directional Derivative)之定義與意義純量函數之梯度(Gradient)",
      "url": " /neural%20network/2020/01/23/Neural-Network-Neural-Network-2/",
      "author": "Shihs",
      "categories": "Neural Network"
    }
    ,
  

    "neural-20network-2020-01-22-neural-network-neural-network": {
      "title": "[Neural Network]Neural Network 1 - The idea",
      "content"	 : "在了解 CNN (卷積神經網路, Convolutional neural network) 與 RNN (循環神經網絡, Recurrent neural network) 前，先來認識最簡單的 NN (神經網路, Neural network) Multilayer perceptron。這篇是Neural networks的課程筆記。Neural network 啟發自大腦神經，所謂的 Neural 就是 neurons (神經元)，而在 Neural network 裡，neurons 是個介於 0 和 1 之間的數字。我們將以讓程式辨認手寫數字 0 到 9 為例解說 Neural network。下圖是一個 28*28 像素的手寫數字，每一個像素都是一個 0 到 1 的灰階值，而 Neural network 以這個圖的每個像素，對應到每個神經元作為輸入值，也就是說第一層輸入層共有 28*28 = 784 個神經元。灰階值 0 為黑色，1 為白色。這些在神經元中的數字稱為「激勵值」（activation）。這裡範例使用，第一層為輸入層，中間兩層 hidden layers，最後一層為輸出層。而最後輸出層就是 0 到 9 的數字，每個神經元都有個「激勵值」（activation），而這數字就代表著最後給定可能是這個數字的判定結果。而中間的 hidden layers 正是神經網路的重點。我們可以想像，將整個數字分解成不同的部分，第一層 hidden layer 是比較小段的部分，而第二層 hidden layer 是由這些小區塊組成比較大塊的區塊。有了這些概念之後，那我們要怎麼從輸入層到第一層的 hidden layer 呢？現在我們希望，第二層的其中一個神經元可以辨識這個圖有沒有一個邊，如下圖，我們會給這個神經元與輸入層的神經元之間每個連線一個權重（weight），然後將輸入層的神經元乘上每個權重再加總，權重可以是正或負值。但因為，我們希望神經元的激勵值（activation）是在 0 和 1 之間，所以使用 sigmoid function  。經過 sigmoid function 計算，越小的值會越接近 0，越大的值會越接近 1。但也許並不是每次加總大於零我們就希望給正的灰階值，因此，權重最後再加上個 bias，來調整我們想要給灰階值的值。所有第一層 hidden layers 的神經元都根據這樣的概念，有自己關注的區塊，有自己的權重，再加上自己的 bias。第二層的 hidden layers 神經元也以同樣的概念計算，所以我們總共會有 13,002 個權重加上 bias。而所謂的 deep learning 的 learning 就是在學習這些權重和 bias，讓電腦去找到正確的值。上上圖的式子只是其中一個神經元，而我們可以用矩陣表達所有第一層 hidden layers 的神經元。如下圖，總的來說，我們可以將整個 neural network 看成一個 function。最後，其實現在已經不使用 sigmoid function 了，現在主流的 function 用的是 ReLU。Reference:究竟神經網路是什麼？ 第一章 深度學習",
      "url": " /neural%20network/2020/01/22/Neural-Network-Neural-Network/",
      "author": "Shihs",
      "categories": "Neural Network"
    }
    ,
  

    "database-2020-01-01-database-er-model-e5-af-a6-e9-ab-94-e9-97-9c-e4-bf-82-e5-9c-96": {
      "title": "[Database]ER Model 實體關聯模型",
      "content"	 : "實體關聯模型（Entity-Relationship Model）是Conceptual model（概念塑模）的一環，用來描述實體與實體之間關係的工具。                              ER Model        實體（Entity）：是指用以描述真實世界的物件，在關聯式資料庫中為一個「資料表」          實體至少擁有一個不是鍵（主鍵）的屬性      一個實體可以含有多個「屬性」(Attribute)用以描述該實體，在關聯式資料庫中，以資料表的「欄位」來表示      例如：學生、員工、產品等等都是屬於實體        關係（Relationship）：指用來表示「一個實體」與「另一個實體」關聯的方式          例如：一對一關係、一對多關係、多對多關係      實體（Entity）定義  a ”thing” in the real world with an independent existence  用來描述實際存在的事物（如:學生），也可以是邏輯抽象的概念（如:課程）  必須可以被識別，亦即能夠清楚分辨出兩個不同的實體(an independent existence)  以「名詞」的來命名，不可以是「形容詞」或「動詞」分類  實體(entity)  弱實體(weak entity)：必須依靠其他實體才能存在，若其依靠的實體消失，則該實體的存在也沒有意義了          例如：學生家長就是依附在學生實體的弱實體，若學生不存在，則家長也沒有存在的意義      圖示                              Entity diagram      屬性(Attribute)定義  用來描述實體的性質（Property）（就是關聯式表格的行）          例如：學生的學號、名字、班級等等      分類  多值屬性 vs 單值屬性          多值屬性（Multivalued attributes）：屬性值不只一個時，我們稱該屬性為多值屬性                  例如：學生有多個專長，珠算、程式…          關係圖中以「雙橢圓形」來表示                    單值屬性（Single-valued attribute）：非多值屬性稱為單值屬性                                    多值屬性 Multivalued attributes diagram        複合屬性 vs 簡單屬性          複合屬性（Composite attributes）：屬性由數個屬性所組成時，我們稱該屬性為複合屬性                  例如：姓名由姓、名組成          關係圖如下                    簡單屬性（Simple attribute）：非複合屬性則稱為簡單屬性                                    複合屬性 Composite attributes diagram        衍生屬性（Derived Attribute）          它的值可以由其它屬性之值經由某種方式的計算或推論而獲得      例如：年齡和星座可由生日推算出來      鍵屬性(Key attribute)定義  是指該屬性的值在某個環境下具有唯一性（primary key）圖示                              Attribute diagram      關係(Relationship)定義  是指用來表達兩個實體之間所隱含的關聯性  使用足以說明關聯性質的「動詞」或「動詞片語」命名          例如：『學生』與『系所』兩個實體型態間存在著一種關係─「就讀於」      分類  關聯強度 Strength          強關聯（strong relationship）：a relationship where entity is existence-independent of other entities, and PK of Child doesn’t contain PK component of Parent Entity      弱關聯（weak (identifying) relationship）：a relationship where Child entity is existence-dependent on parent, and PK of Child Entity contains PK component of Parent Entity，也就是說，此關聯是連結實體與弱實體        Cardinality          1:1 一對一      1:N 一對多      M:1 多對一      M:N 多對多        Participation constraints          全部參與（Total participation）：every entity in the set is involved in the relationship      部分參與（Partial participation）：not all entities in the set are involved in the relationship      圖示                              Relationship diagram      弱實體例子為了區分和一般實體的關係, 我們會以雙菱形來表示實體與弱實體之間的關係, 而弱實體和關係之間以雙直線連接                              Example      以上圖為例，CHAPTER 必須依靠 BOOK 才能存在，所以 CHAPTER 是一個弱實體，兩者間用雙菱形（弱關聯）來連結。CHAPTER 用雙直線（Total participation）連接關係，因為 CHAPTER 是依靠 BOOK 而存在，表示每一個 CHAPTER 必定屬於某本 BOOK。而 CHAPTER 的 primary key 由 BOOK 的 primary key（BOOK ID） 與 CHAPTER ID 組成。如果將上圖關係轉換成表格，CHAPTER 表格會有 {TITLE, CHAPTER ID, BOOK ID} 三個欄位，而 (CHAPTER ID, BOOK ID) 合併為 primary key。Reference:ER Model 實體關係圖第4章 資料庫設計與實體關聯模型利用實體-關係模型 (E-R Model) 規劃資料庫Chen notation資料庫基礎概念",
      "url": " /database/2020/01/01/Database-ER-Model%E5%AF%A6%E9%AB%94%E9%97%9C%E4%BF%82%E5%9C%96/",
      "author": "Shihs",
      "categories": "Database"
    }
    ,
  

    "database-2019-12-31-database-database-e5-9f-ba-e7-a4-8e-e6-a6-82-e5-bf-b5": {
      "title": "[Database]Database 基礎概念",
      "content"	 : "資料(Data)與資訊(Information)  資料(Data)：資訊(Information)的原始型態，是未經整理和分析的原始數值、文字或符號。  資訊(Information)：經過整理和分析後的資料，是有實質意義的資料。  資料處理(Data Processing)：資料(Data) 經過資料處理(Data Processing) 後將資料轉換為資訊(Information)。資料階層資料階層的最小儲存單位是位元，8個位元組成一個位元組，也就是ASCII碼的字元。數個位元組結合成欄位，多個欄位組成記錄，最後將一組記錄儲存成檔案，資料庫就是 一組相關檔案的集合。                              資料階層        第一階層：位元(Bits)  第二階層：位元組(Bytes)  第三階層：欄位(Fields)  第四階層：記錄(Records)  第五階層：檔案(Files)  第六階層：資料庫(Database)資料庫系統(Database System)資料庫系統(Database System)是由「資料庫」(Database)和「資料庫管理系統」(Database Management System，DBMS)所組成。                              資料庫系統      資料庫(Database)  Represents some aspects of the real world (miniworld)  資料庫是一個對結構化資訊或資料的組織性收集，通常以電子方式儲存在電腦系統。  資料庫通常由資料庫管理系統(DBMS)控制。  目前運行中最常見的資料庫型態通常是在一系列的表格中進行行列間建模，使得處理和資料查詢更為有效。  大部分的資料庫使用結構化查詢語言(SQL)來書寫或查詢資料。  資料庫容許多名用戶在同一時間快速、安全地以高度複雜邏輯和語言取得或查詢資料。  Meta-data: Database definition or descriptive information (Stored by the DBMS in a database catalog or data dictionary)資料庫管理系統(DBMS)  資料庫通常需要一個稱做資料庫管理系統(DBMS)的全面資料庫軟體程式。  DBMS是作為資料庫和其用戶或程式之間的介面，讓用戶能檢索、更新和管理，使得資訊組織化和最佳化。  DBMS亦可促進對資料庫的監督和控制，增強各方面的管理運作，包括績效監控、最佳化、備份以及系統恢復。Database System Design Process好的資料庫系統設計對於資料庫的維護、更新及修改相當重要，另外，如何有效的儲存、提取資料也是資料庫重要的一環，接下來要介紹資料庫的設計。資料庫系統設計（Database System Process）有兩個主要的方向，  Database design（資料庫設計）          focuses on defining the database        Application design（應用設計）          focuses on the programs and interfaces that access the database                                    Database System Design Process      Database Design（資料庫設計）/ Data Modeling（資料塑模）(在 Database Technology 講義裡寫的是 Database Design，但找到兩個台灣的講義（第1章 資料庫的基礎、第二章 實體關係模式:基本概念）都是用資料塑模（Data Modeling），所以這兩個東西我把它們放在一起)                              Data Modeling      資料庫設計階段（Phases for designing a database）:  Requirements specification and analysis  Conceptual design（Conceptual model，概念塑模)          e.g., using the Entity-Relationship model (ER Model)        Logical design（Logical model，邏輯塑模)          e.g., using the relational model (關聯模型)        Physical design（Physical model，實體塑模)          e.g., 設定索引                                    Database development life cycle      Conceptual model（概念塑模）概念塑模的目的是將現實中某部分的資料關係用結構化的方式呈現，建立整個資料庫邏輯結構的模型，過程不涉及任何資料庫管理系統、資料庫種類、軟體和實際儲存結構。最常使用實體關係圖（Entity Relationship Diagram）來繪製實體關聯模型（Entity-Relationship Model）。                              ER Model      Entity-Relationship model (ER Model)  ER Model 則是用來繪製結構化資料的概念圖。  ER Model 組成元件包括實體（Entity）和關係（Relationship）。          實體（Entity）- 是在真實世界識別出的東西，例如：老師、學生、車子、品牌。      關聯性（Relationships）- 在二個或多個實體間擁有的關係，主要分為三種：一對一、一對多、多對多。      下一篇有詳細解說Logical model（邏輯塑模）使用的工具是關聯模型（Relational Model），最後會產生資料表的定義關聯綱目（schema）。邏輯模型主要是由三種元素所組成，如下所示:  資料結構（Data Structures）：資料的組成方式，就是欄和列組成表格的關聯表(Relations)  資料操作或運算（Data Manipulation 或 Operations）：資料的相關操作，關聯式代數(Relational Algebra)和關聯式計算(Relational Calculus)  完整性限制條件（Integrity Constraints）：維護資料完整性的條件，其目的是確保儲存的資料是合法的資料資料庫系統演進各年代的資料庫系統中，其使用的資料庫模型就是邏輯資料模型，主要有四種邏輯資料模型，如下所示:  階層式模型（Hierarchical Model）  網路式模型（Network Model）  關聯式模型（Relational Model）wiki  物件導向式模型（Object-Oriented Model）Relational Model (Relational Data Model)  中文稱「關聯（式）模型」。  Relational database 關聯式資料庫: represent data as a collection of relations。「關聯式資料庫」使用多個關聯表（relations）來呈現資料。Relation（關聯表）                              relation (關聯表)            Relation 是關聯表（如上圖），是包含 data 的 table（表格）    Each row (tuple) represents a record of related data values          一列（row）稱為一個值組（tuple），紀錄各個 data 的值        Each column (attribute) holds a corresponding value for each row          Columns associated with a data type (domain)      Each column header: attribute name        Domain          Domain is a set of atomic values. e.g., ,       atomic values: Each value indivisible（不可分割）      Domains specified by data type(integer, string, date, real, etc.)        Relation Schema          Schema describes the relation（關聯表）      關聯表綱要（relation schema）是由關聯表名稱 R（relation name）和一連串屬性 清單（list）還有定義域（domain）所組成      integrity constraints（完整性限制）      Denoted by         Attribute           Name of a role in the relation schema R      使用  的符號來說明屬性  的定義域的範圍是什麼      屬性名稱不可重複，但 domain 可以重複        NULL Values          Each domain may be augmented with a special value called NULL        Question: A relation schema consists of?          Ans: relation name, attribute names and domains, and integrity constraints      Integrity Constraints（完整性限制）  建立檢查資料庫儲存資料的依據和保障資料的正確性。不但可以防止授權使用者將不合法資料存入資料庫，還能夠避免關聯表間的資料不一致。  關聯式資料庫模型的完整性限制條件有很多種，適用所有關聯式資料庫的完整性限制條件有四種，如下所示:          鍵限制條件(Key Constraints)      定義域限制條件(Domain Constraints)      實體完整性(Entity Integrity)      參考完整性(Referential Integrity)      鍵限制條件（Key Constraints）鍵限制條件（Key Constraints）是指關聯表一定擁有一個唯一和最小的主鍵（Primary Key）                              Key        超鍵（Superkeys）          是關聯表綱要的單一屬性或屬性值集合，超鍵需要滿足唯一性（Uniqueness）      Superkeys 可以由一個或多個行（屬性）組成，只要唯一就可以      下方範例關聯表來看，符合的有(sid)、(SSN)、(sid, SSN)、(sid, ename)、(SSN, cname)、(sid, tel)、(SSN, cname, postcode)……        候選鍵（Candidate Keys）          候選鍵（Candidate Keys）是一個超鍵，在每一個關聯表至少擁有一個候選鍵，不只滿足超鍵的唯一性，還需要滿足最小性（Minimality）      Candidate Keys 是超鍵的子集合，但不同的是，候選鍵還必須要有最小性，所以單一屬性的超鍵一定是候選鍵      舉個例子，如果下面的範例多了一個學生 sid = 5, ename = Jane，這時候 (sid, ename) 就不是候選鍵，因為去掉 ename 也能區分每一行，所以 ename 是多餘的        主鍵（Primary Key）          符合的有(sid)、(SSN)      從候選鍵中選出一個作為主鍵，挑選主鍵的原則如下所示:                  不可為空值(Not Null)          永遠不會改變(Never Change)          非識別值(Nonidentifying Value)          簡短且簡單的值(Brevity and Simplicity)                      替代鍵（Alternate Keys）          在候選鍵中不是主鍵的其他候選鍵稱為替代鍵(Alternate Keys)，因為這些是可以用來替代主鍵的候選鍵      如果 (sid) 是主鍵，則 (SSN) 是替代鍵        外來鍵（Foreign Keys）          是關聯表的單一或多個屬性的集合，它的屬性值是參考到其他關聯表的主鍵，用來建立兩個關聯表間的連接      換句話說，Foreign Keys 是其他關聯表的主鍵，它（們）可以是該關聯表的主鍵，但不一定是      外來鍵和參考的主鍵屬於相同定義域，不過屬性名稱可以不同      外來鍵可以是空值NULL                                    範例關聯表      定義域限制條件(Domain Constraints)  每個值都必須是基元值且必須在定義域內  例如，屬性 age 的定義域是 int，屬性值可以為5 ，但不可以是4.5實體完整性(Entity Integrity)  實體完整性是關聯表內部的完整性條件，主要是用來規範關聯表主鍵的使用規則  主鍵（primary  key）不可以是 Null  例如，（ename, cname）是主鍵，ename 屬性不可為空值；cname 屬性也不可是空值。參考完整性(Referential Integrity)  關聯表的所有外來鍵值，都必須能參考到另一關聯表的主鍵值Physical Model（實體塑模）  針對指定資料庫管理系統建立實際資料庫結構的資料模型，例如:SQL Server  對於關聯式資料庫模型的實體模型來說，就是在資料庫管理系統軟體建立關聯表(Relation) 的表格、關聯性(Relationship)和索引等定義資料  簡單來說，就是將 Conceptual model 和 Logical model 實際建立出來                              實體模型      Reference:第1章 資料庫的基礎第3章 關聯式資料庫模型Oracle - 什麼是資料庫？Database Technology - Topic 1: IntroductionDatabase Technology - Topic 2: Relational Databases深入了解關聯式資料模型(Relational Data Model)第二章 實體關係模式:基本概念Data Modeling (資料塑模) : 概念塑模、邏輯塑模、實體塑模快速理解資料庫超鍵，候選鍵，主鍵",
      "url": " /database/2019/12/31/Database-Database-%E5%9F%BA%E7%A4%8E%E6%A6%82%E5%BF%B5/",
      "author": "Shihs",
      "categories": "Database"
    }
    ,
  

    "nlp-2019-12-17-nlp-nltk-e7-ad-86-e8-a8-98": {
      "title": "[NLP]NLTK &amp; spaCy 筆記",
      "content"	 : "常見的 NLP package 有 NLTK、spaCy、Scikit-learn 等等，參考下面的功能比較圖。這裡則要分別介紹 NLTK 和 spaCy 的一些用法。從上面的比較圖我們知道，這兩個 package 基本上功能相似，在 preprocessing 時一定會使用到，但兩者有各自的優缺點。NLTK主要用於處理斷詞、詞頻、 pos 等等，更多用法請參照下面連結。NLTKspaCyspaCy 是 NLTK 的主要競爭者，它們的功能類似。spaCy",
      "url": " /nlp/2019/12/17/NLP-NLTK-%E7%AD%86%E8%A8%98/",
      "author": "Shihs",
      "categories": "NLP"
    }
    ,
  

    "text-20mining-2019-11-26-text-mining-word-embeddings": {
      "title": "[Text Mining]Word embeddings",
      "content"	 : "This post is based on the 732A92 Texting Mining course, given by Marco Kuhlmann at LiU in 2019.Word embeddings對於人來說，要理解文字並不是件困難的事，但對電腦來說，每個字不過是一串 string，所以當我們要做 text mining 時就必須要將這些 string 轉化成電腦可以理解的方式。而 word embedding(word vector or word representation) 的概念就是將文字轉換成 vector ，好讓電腦可以讀懂文字間的關係。譬如說，人類可以理解 pretty 和 beautiful 是相近詞，但如果只是給電腦這兩個單字，對於電腦來說，這只是兩個不同長度的 string 罷了。word embedding 會將這兩個字轉換成不同的 vector 映射到一個高維空間，當這兩個 vector 越接近（可以使用 consine similarity）就表示這兩個詞越相近。這就是 word embedding 主要的概念。  A word embedding is a mapping of words to points in a vector space such that nearby words (points) are similar in terms of their distributional properties.The distributional principleword embedding 方法可以使用最重要的就是因為有 distributional hypothesis 這個假設。  The distributional principle states that words that occur in similar contexts tend to have similar meanings.這裡的概念是說，詞(target words)出現在類似的上下文中(context words)，則它們很有可能有相似的意思。譬如說，-「那隻『貓』好可愛」-「那隻『狗』好可愛」這時候除了『貓』和『狗』外，這兩句話的上下文是一樣的，根據 distributional principle，這兩個詞應該是相似的。Co-occurrence matrix上圖中，context words 就是上下文，而 target words 就是我們想要分析的字詞。現在來看 cheese 這個字，可以看到和 butter, cake, cow, deer 這幾個字一起出現的次數分別是，12, 2, 1和0次。看起來和 butter 還有 cake 連結性比較強。再來看 bread 這個字，同樣的在 butter 和 cake 上的連結也比較強。如果我們把這兩個單字用向量表示就會是，(12, 2, 1, 0) 和 (5, 5, 0, 0)，可以去比較和其他兩個單字的 cosine similarity，這兩個的關係是比較強的。現在我們把它們畫出來（因為它們被映射到的是四維空間，所以老師的 slide 只看 cow 和 cake 這兩個 context words）如果還是不太明白，這篇部落格應該可以看懂。補充：從上面的 matrix 可能會想到一件事，context words 等於是決定了 target words 的向量啊！換句話說，當我們分析不同的文本的時候，會需要不同的 context words來算出 word embeddings。想像，如果今天要分析新聞報導和 ptt 內容，不太可能使用一樣的 context words，畢竟ptt用語和新聞用語會有很大的不同。（蛤？你說記者都抄 ptt 內容嗎？XDDD）Simple applications of word embeddingsword embeddings 的應用  finding similar words. 找到相似的字，像是上面的例子，找出哪一個字和 cheese 比較相似。  answering ‘odd one out’ questions. 找出不一樣的詞，譬如說  lunch, breakfast, dinner, car 哪一個詞屬於不同類？ (根據上面提到的概念，lunch, breakfast, dinner 這三個的 vector 應該會比較接近，會在比較接近的上下文中出現)Limitations of word embeddings      There are many different facets of ‘similarity’. Ex. Is a cat more similar to a dog or to a tiger? (在不同情境下，cat 和 dog 可能比較相似。譬如說，貓和狗都是寵物，但如果以生物的角度來看，cat 和 tiger 都屬於貓科動物，這時候 cat 和 tiger 會比較相似)        Text data does not reflect many ‘trivial’ properties of words. Ex. more ‘black sheep’ than ‘white sheep’ (如果只分析文本，因為大部分的羊都是白色的，所以在提到羊的時候並不會特別提到顏色，但當提到比較稀少的黑羊時，反而會特別說到 black，這會導致在分析時好像黑羊出現的頻率比白羊出現的頻率高)        Word vectors reflect social biases in the data used to train them. Ex. including gender and ethnic stereotypes (論文參考) 很多詞語上的用法其實帶有非常多的社會偏見和刻板印象，而這也會導致分析出的結果有所偏差。  還有什麼問題？到目前為止，看起來都非常合理，那還會有什麼問題呢？這裡會碰到和之前提到過的，矩陣稀疏性的問題。如果今天 context words 有十萬個字，那麼 target words 就會是在十萬維度的空間的 vectors，而且可能會有很多的值都是 0 的狀況發生。那這樣要用什麼方法解決矩陣的稀疏性並產生 word embeddings（也就是每個詞的向量） 呢？從不同的面向來看幾個常見的 word embedding 方法，  Learning word embeddings via matrix factorization          Singular Value Decomposition(SVD)      Positive Pointwise mutual information(PPMI)        Learning word embeddings via language models          N-gram      Neural language models(Ex. word2vec)      以下就要來介紹這幾種方法。Matrix factorization - Singular Value Decomposition(SVD)  The rows of co-occurrence matrices are long and sparse. Instead, we would like to have word vectors that are short and dense. 簡單來說，co-occurrence matrices 會有稀疏性的問題。  One idea is to approximate the co-occurrence matrix by another matrix with fewer columns. Singular Value Decomposition 的想法是，將這個又長又臭的 co-occurrence matrix 用另比較少 columns 的 matrix 取代。什麼是 Singular value decomposition（奇異值分解）?推薦李宏毅老師的線性代數  Singular value decomposition(SVD) can be applied on any matrix. (不需要是方陣。比較：PCA(特徵值分解) 也是一個降維的方法，但它的矩陣就必須要是方陣。)SVD 的概念就是，任一一個矩陣 ，它都可以拆解成三個矩陣（）的相乘。其中， 的 columns 是 Orthonormal，而  的 rows 是 Orthonormal， 是 Diagonal(只有對角線有非負的值，且由大到小)。(在線性代數中，一個內積空間的正交基（orthogonal basis）是元素兩兩正交的基。稱基中的元素為基向量。 假若，一個正交基的基向量的模長都是單位長度1，則稱這正交基為標準正交基或”規範正交基”（Orthonormal basis）。)   會是一個長得像這樣的矩陣，且 而  是奇異值（singular value），而 r 越小也代表了該值越重要，換句話說，含有越多訊息，因此我們可以只保留  較重要的前面幾行得到一個相似的矩陣 。用較小的儲存空間就可以得到接近原始的矩陣 。參考線代啟示錄-奇異值分解 (SVD)的圖，回到我們的 word-embedding。我們可以利用 SVD 進行去噪及降維，刪除一些不那麼重要的訊息，用來解決 Co-occurrence matrix 稀疏性的問題。我們也不需要再將相乘矩陣，直接使用 𝑼 就好，每一列就代表一個 target word。  Each row of the (truncated) matrix 𝑼 is a k-dimensional vector that represents the ‘most important’ information about a word.  A practical problem is that computing the singular value decomposition for large matrices is expensive.這邊看一個例子，下圖是一個 Co-occurrence matrix 將上面的矩陣  使用 SVD 分解、降維，只留下前三個特徵值。每個特徵值的大小表示對應位置的屬性值的重要性大小，左奇異矩陣的每一列即代表每個詞的特徵向量，右奇異矩陣的每一行表示每個文件的特徵向量。取每個向量後兩維的對應值投影到一個二維空間，如下所示上圖中，一個紅色的點對應一個詞，一個藍色的點對應一個文件。當這些點被投影到空間中，我們可以對這些詞和文件進行分類，比如說stock和market可以放在一類，real和estate可以放在一類，按這樣的分類結果，我們就可以知道文件中哪些事相近的詞，所以當使用者利用詞搜尋文件的時候，我們就可以利用相近的詞（在向量空間中相近的詞、被歸為同一類的詞）進行檢索，而不是只是使用完全相同的詞搜尋。Matrix factorization - Positive Pointwise mutual information(PPMI)Pointwise mutual information(PMI)      Raw counts favour pairs that involve very common contexts. E.g. the cat, a cat will receive higher weight than cute cat, small cat.        We want a measure that favours contexts in which the target word occurs more often than other words.        A suitable measure is pointwise mutual information (PMI):  簡單來說，我們可以用 PMI 公式來看兩個字之間的關係。現在我們把  看成我們的 target word， 看成我們的 context word，  We want to use PMI to measure the associative strength between a word  and a context  in a data set :但根據上面的公式，會發現一個問題，PMI is infinitely small for unseen word–context pairs, and undefined for unseen target words. (如果  和  並沒有共同出現過，再取 log，整個值會變成 -Inf)所以這時候就有了 Positive Pointwise mutual information(PPMI)。  In positive pointwise mutual information (PPMI), all negative and undefined values are replaced by zero:  PPMI assigns high values to rare events, it is advisable to apply a count threshold or smooth the probabilities.看一個例子，下圖是一個 Co-occurrence matrix，列是 target words，行是 context words假設這篇文章總共只有 19 個字，這裡我們計算 x = information，y = data 的 PMI 值，根據同樣的方式可以求出所有 target words 對應的 context words 的 PMI 值。Language models  A probabilistic language model is a probability distribution over sequences of words in some language.  Recent years have seen the rise of neural language models, which are based on distributed representations of words.  By the chain rule, the probability of a sequence of 𝑁 words can be computed using conditional probabilities as  To make probability estimates more robust, we can approximate the full history  by the last few words (馬可夫鍊):Language models - N-gram models      An n-gram is a contiguous sequence of n words or characters. E.g. unigram (Text), bigram (Text Mining), trigram (Text Mining course)        An n-gram model is a language model defined on n-grams –  a probability distribution over sequences of n words.        n-gram 是一種語言機率模型。一句話出現的機率是一個聯合模型。如果一個詞的出現只考慮前面一個字，那就是 bi-gram；如果一個詞的出現考慮前面兩個字，那就是 tri-gram。  Formal definition of an n-gram model  : the model’s order (1 = unigram, 2 = bigram, …)  : a set of possible words (character); the vocabulary  : a probability that specifies how likely it is to observe the word  after the context (n − 1)-gram Unigram modeln = 1 不考慮前面出現的字。Thus contexts are empty.MLE of unigram probabilitiesBigram modelsn = 2 考慮前面出現的一個字。Thus contexts are unigrams.Estimating bigram probabilitiesExample(source)Smoothing當在計算 bigram 時可能會碰到兩個字完全沒有相鄰的狀況，這會導致算出來的機率等於 0。（如下圖）這種時候就需要用到，smoothing。Smoothing methods  Additive smoothing  Good-Turing estimate  Jelinek-Mercer smoothing (interpolation)  Katz smoothing (backoff)  Witten-Bell smoothing  Absolute discounting  Kneser-Ney smoothing上面的狀況碰到的是，”CHER” 後面沒有出現 “READ” 的狀況，而導致機率等於0，但如果現在是 “CHER” 這個字從未出現在資料集中呢？這種狀況時，smoothing 便派不上用場了。  In addition to unseen words, a new text may even contain unknown words. For these, smoothing will not help.Unknown words建立一個 token ，如果是 unknown words 就用  當作普通的單詞處理。  A simple way to deal with this is to introduce a special word type UNK, and to smooth it like any other word type in the vocabulary.  When we compute the probability of a document, then we first replace every unknown word with UNK.Language models - Neural networks as language modelsAdvantages of neural language models  Neural models can achieve better perplexity than probabilistic models, and scale to much larger values of n.  Words in different positions share parameters, making them share statistical strength. (Everything must pass through the hidden layer.)  The network can learn that in some contexts, only parts of the  n-gram are informative. (implicit smoothing, helps with unknown words)word2vec  word2vec 是 word embedding 的一種      word2Vec 主要有 CBOW (continuous bag-of-words) 和 skip-gram 兩種模型    CBOW 是給定上下文，來預測輸入的字詞；Skip-gram 則是給定輸入字詞後，來預測上下文Reference:732A92 Texting Mining詞向量介紹自然語言處理 – Vector Space of Semantics[NLP] 秒懂词向量Word2vec的本质李宏毅老師的線性代數 - SVDNLP 笔记 - 再谈词向量機器學習筆記之二十二——PCA與SVD線代啟示錄-奇異值分解 (SVD)自然語言處理 – Pointwise Mutual InformationNLP Lunch Tutorial: Smoothing機器學習五分鐘：自然語言處理（NLP）的N-gram模型是什麼？詞向量(one-hot/SVD/NNLM/Word2Vec/GloVe)",
      "url": " /text%20mining/2019/11/26/Text-Mining-Word-embeddings/",
      "author": "Shihs",
      "categories": "Text Mining"
    }
    ,
  

    "text-20mining-2019-11-21-text-mining-text-clustering-and-topic-modelling": {
      "title": "[Text Mining]Text clustering and topic modelling",
      "content"	 : "This post is based on the 732A92 Texting Mining course, given by Marco Kuhlmann at LiU in 2019.在進入 Text clustering 前我想要先介紹 Clustering。Clustring      Clustering (分群）是一種 unsupervised learning（非監督學習）    Typical applications          As a stand-alone tool to get insight into data distribution      As a preprocessing step for other algorithms        Cluster: a collection of data objects。但什麼樣的 data 會被歸在同一個 cluster 呢？ 這就是 clustering 最重要的概念，Similar 和 Dissimilar。  Similar to one another within the same cluster  Dissimilar to the objects in other clusters=&amp;gt; 而提到 Similar 和 Dissimilar 就要必須要提到 distance (or similarity) measures。有了 distance（similarity）才有辦法定義 Similar 和 Dissimilar。Distance（Similarity）  Distances are normally used to measure the similarity or dissimilarity between two data objectsDistances 可以有很多種定義方式，但不管怎麼定義，都一定要符合以下的 properties。   (non-negativity)   (identity of indiscernibles)   (symmetry)   (triangle inequality)Minkowski distance, q is a positive integer  If q = 1, d is Manhattan distance  If q = 2, d is Euclidean distanceBinary Variables  symmetric binary variables: both states are equally important; 0/1  asymmetric binary variables: one state is more important than the other (e.g. outcome of disease test); 1 is the important state, 0 the other  Accuracy for symmetric binary variables  Jaccard similarity for asymmetric binary variablesText clustering上圖是 Conceptual framework for text mining，而這篇要介紹的是 Clustering 和 Topic Analysis。      Text clustering is the task of grouping similar texts together. What is considered ‘similar’ depends on the application.        Clustering is a central tool in exploratory data analysis, where it can help us to get insights into the distribution of a data set.        Clustering is also useful as a pre-processing technique in knowledge-focused applications. Example: Brown clustering  Similarity measures剛剛前面提到的 Similarity，如何用在 text 上呢？Accuracy for symmetric binary vectorsJaccard similarity for asymmetric binary vectorsHard clustering and soft clusteringHard clustering  Each document either belongs to a cluster or not. Ex. Hierarchical clustering(brown clustring), Partitioning clustering(k-means), Density-Based clustering(DBSCAN)Soft clustering  Each document belongs to each cluster to a certain degree. Ex. LDA (topic model)An overview of hard clustering methodsHierarchical clusteringThis method does not require the number of clusters k as an input, but needs a termination condition      Agglomerative: Each document starts in its own cluster. Hierarchy is created by merging pairs of clusters.將點倆倆合併，最後所有的點會全部在同一個 cluster 裡。那至於要用什麼決定要將兩個點合併呢？這時候又有 Linkage criteria 來決定，eg. Single-link, Complete-link, Average-link 等等。不同的 linkage criteria 會導致不同的分群結果，如下圖。        Divisive clustering: All documents start in one cluster. Hierarchy is created by splitting clusters recursively.    Brown clustringPartitioning clustering      K-means        Issues with the k-means algorithm          The k-means algorithm always converges, but there is no guarantee that it finds a global optimum. (Solution: random restarts)      The number of clusters needs to be specified in advance, or chosen based on heuristics and cross-validation. (Example: elbow method)      The k-means algorithm is not good at handling outliers – every document will eventually belong to some cluster.      K-means is restricted to clusters with convex shapes =&amp;gt; Density-Based clustering      Density-Based clustering  The basic idea behind density-based algorithms is that different regions of the vector space can be more or less densely populated.  Under this view, clusters can take any shape; they are not constrained to convex clusters as in k-means.Directly density-reachable  DBSCANEvaluation of hard clusteringIntrinsic and extrinsic evaluation  In intrinsic evaluation, a clustering is evaluated based on internal measures such as coherence and separation. Are documents in the same cluster similar? Are clusters well-separated?  In extrinsic evaluation, a clustering is evaluated based on data that was not used for the clustering, such as known class labels. cluster purity, Rand indexRand index假設一個集合中有N篇文章一個集合中有N(N-1)/2個集合對TP：同一類的文章被分到同一個簇TN：不同類的文章被分到不同簇FP：不同類的文章被分到同一個簇FN：同一類的文章被分到不同簇Rand Index度量的正確的百分比RI = （TP+TN）/（TP+FP+FN+TN）Topic models  A topic model is a statistical model for representing the abstract topics that are expressed in a collection of documents.  Topic models are examples of soft clustering techniques – each document belongs to each cluster (topic) to a certain degree.Latent Dirichlet Allocation (LDA)LDA有兩個原則，  每個 domcuments 是由多個 Topic 組成（each document belongs to each cluster (topic) to a certain degree）  每個主題會有不同的 terms 來描述，且同樣對詞可以同時出現在不同的主題。Reference:732A92 Texting Mining732A75 Advanced Data Mining自然語言處理 – Brown Clustering直觀理解 LDA (Latent Dirichlet Allocation) 與文件主題模型聚類評價指標 Rand Index,RI,Recall,Precision,F1",
      "url": " /text%20mining/2019/11/21/Text-Mining-Text-clustering-and-topic-modelling/",
      "author": "Shihs",
      "categories": "Text Mining"
    }
    ,
  

    "text-20mining-2019-11-13-text-mining-text-classification": {
      "title": "[Text Mining]Text classification",
      "content"	 : "This post is based on the 732A92 Texting Mining course, given by Marco Kuhlmann at LiU in 2019.Text classification  Text classification is the task of categorising text documents into predefined classes.Evaluation of text classifiers最簡單的檢視預測結果好壞的方法就是將 predict 出來的類別與真實的類別做比較。（預測必須要在 test data，換句話說之前並沒有參與任何 training 的過程。這點在做所有 Machine Learning 的方法都很重要，在做 model 測試前不要碰 test data。）AccuracyThe accuracy of a classifier is the proportion of documents for which the classifier predicts the gold-standard class:Accuracy and imbalanced data sets上面的 accuracy 看起來非常合理啊，去計算分類正確的比例來判斷這個分類器是否預測準確。但，如果其實資料本身的類別並不平均呢？根據上圖，我們只要把所有資料都猜綠色的 class，這樣 accuracy 就能有 80%。從這個例子可以知道，      Evaluation measures are no absolute measures of performance. 如果今天得到 accuracy 是 80% 我們並無法確定這樣的準確率的好壞，要根據每個問題去判斷。        Instead, we should ask for a classifier’s performance relative to other classifiers, or other points of comparison. E.g.’Logistic Regression has a higher accuracy than Naive Bayes.’        When other classifiers are not available, a simple baseline is to always predict the most frequent class in the training data.  Precision and recall      Precision and recall ‘zoom in’ on how good a system is at identifying documents of a specific class.        Precision is the proportion of correctly classified documents among all documents for which the system predicts class.    Recall is the proportion of correctly classified documents among all documents with gold-standard class.F1-measureA good classifier should balance between precision and recall.  Naive Bayes classifierBayes’ theoremWe know that  is classes,  is features. Using Bayes’ theorem, the conditional probability can be decomposed as也就是，根據上式，我們可以將分母視為常數，因為 features  的值是給定的，且與  無關，所以可以得到Naive Bayes assumptionNaive Bayes 假設 根據 Naive Bayes 的假設，前面的式子我們可以寫成，根據上面的推導過程，我們可以得到，Naive Bayes classifer而 Naive Bayes classifer 就是取各個分類  中  值最大的為最後的分類結果。換句話說，我們可用這樣的式子表示而  就是最後的分類結果。Two Classic Naive Bayes Variants for Text  Multinomial Naive Bayes          Data follows a multinomial distribution (多項分布)      Each feature values is a count (word occurrence counts, TF-IDF weighting, …)        Bernoulli Naive Bayes          Data follows a multivariate Bernoulli distribution      Each feature is binary (word is present / absent)      Lab: Text classification LabReference:732A92 Texting Mining如何辨別機器學習模型的好壞？秒懂Confusion Matrixwikipeida - 單純貝氏分類器",
      "url": " /text%20mining/2019/11/13/Text-Mining-Text-classification/",
      "author": "Shihs",
      "categories": "Text Mining"
    }
    ,
  

    "text-20mining-2019-11-05-text-mining-information-retrieval": {
      "title": "[Text Mining]Information Retrieval",
      "content"	 : "This post is based on the 732A92 Texting Mining course, given by Marco Kuhlmann at LiU in 2019.這門課教授的是英文的文字探勘，中文與英文本身在結構上有非常大的差異，所以有些解析和斷詞的方法中文可能並不適用，但在基本概念上還是有相同的地方。每個主題都有一個 Lab 附在文章最後。Information Retrieval (IR)Information Retrieval (IR) is finding material (usually documents) of an unstructured nature (usually text) that satisfies an information need from within large collections (usually stored on computers).中文稱為「資訊檢索」。從一堆的 unstructured 資料中（通常是文字）找出符合我們需要的條件的資料。例如，google 搜尋就是一個例子。我們在搜尋 bar 裡輸入我們想要找到的關鍵字，google 搜尋引擎會從它儲存的所有 database（網站們） 中找出符合我們關鍵字條件的網站給我們。那我們要如何找到包含這些關鍵字的文章呢？最直觀地想應該就是把有我們搜尋的關鍵字的文章抓出來吧！這就是 Boolean retrieval。在進入 Boolean retrieval 之前先來看一下 The classic search model。The classic search model  To communicate her/his information need to an IR system, the user formulates a search query.  The objective of the IR system is to find documents in the collection that ‘match’ the search query.  A good IR system finds documents that are also relevant for the user’s information need.Boolean retrievalThe Boolean retrieval model is a model for information retrieval in which we can pose any query which is in the form of a Boolean expression of terms, that is, in which terms are combined with the operators AND, OR, and NOT. The model views each document as just a set of words.很直覺的方法要找出包含關鍵字的可以使用 terms(通常是個單詞) 是否包含在 documents 裡。例如，現在有 Sherlock Holmes 小說文字。我想要找出哪些篇章符合出現 ‘Moriarty’ 和 ‘Lestrade’ 但不包含 ‘Adair’。那麼下的 query 就會是 Moriarty AND Lestrade AND NOT Adair那個我們可以將上面的概念寫成一個 Term–document matrix。Term–document matrix每一行代表一個章節，每一列代表一個條件的單詞（term）。以列來看，0 表示該單詞沒有出現在那一章節中，1 表示該單詞有出現。像是第一列，’Adair’ 只有出現在 ‘Empty house’ 這個章節。這樣的方法看似簡單，但以實務上來說並不是個好辦法。因為，  Term–document matrices are sparse. 可以從上面的 matrix 看到，有很多的 0 ，也就是說其實很多資訊並不需要，但卻還是需要儲存。  假如現在有 1,000,000 份 documents，有 500,000 不同的 terms ，這樣的條件下會產生 a matrix with 500,000,000,000 entries (62,5 GB)。所以我們必須得使用別的辦法減少不必要的資訊儲存。這時候就有了 Inverted index。Inverted indexThe inverted index is a key–value mapping, the basic idea is shown below.  the keys are search terms  the values are sorted lists of document identifiers (ids)  the list for terms identifies those documents that contain the terms從上圖我們可以看到，和 Term–document matrix 不一樣的是 Inverted index 只儲存了有包含該單詞的 document ids。現在我們知道我們要的是去看那些關鍵字是否包含在 documents 中，但我們並不會每一次找關鍵字的時候一篇一篇文章搜索，我們會先建立一個儲存好所有 term 的 matrix，但我們要怎麼決定是哪些 terms 要被儲存呢？Index constructionThe major steps in index construction:  Collect the documents to be indexed.  Tokenize the text.  Do linguistic preprocessing of tokens.  Index the documents that each term occurs in.Tokenizationraw = &quot;Apple is looking at buying U.K. startup for $1 billion.&quot;# tokenize raw text based on whitespacefor token in raw.split(): print(token)# tokenize using spaCyimport spacynlp = spacy.load(&quot;en_core_web_sm&quot;) for token in nlp(raw):    print(token.text)# 結果：# Apple# is# looking# at# buying# U.K.# startup# for# $# 1# billion# . 英文每個單字可以很容易地使用空白（.split()）來分割出每個單字，但只使用split 無法排除標點符號的問題，python 的 spacy 可以將標點符號也區分出來。Stop wordsA stop word is a word that is frequent but does not contribute much value for the application in question. For example: a, the, and…但根據分析的目的不同，會有不同的 stop words 的定義。以分析 Sherlock Holmes 的小說為例，資料裡面肯定會包含非常大量的 Sherlock Holmes，那這種時候我們或許可以根據分析的目的將 Sherlock Holmes 定義為 stop words。換句話說，並不存在一個所有分析通用的 stop words 資料集。既然 stop words 對於分析沒有價值貢獻，那麼在做分析前就必須把 stop words 刪除，以避免干擾分析結果。Lexemes and lemmas英文的文法有幾個規則，  動詞會根據人稱與時態有所變化  動詞有動名詞型態  名詞的單數與複數有變化但在分析前必須要將這些相同意義但不同型的單字修正為相同以便分析。      The term lexeme refers to a set of word forms that all share the same fundamental meaning. For example: word forms run, runs, ran, running – lexeme run        The term lemma refers to the particular word form that is chosen, by convention, to represent a given lexeme. For example: what you would put into a lexicon  Ranked retrieval（排序檢索）進行到這裡我們已經知道如何要先建立一個有所有 term 的 matrix for 所有的 documents，然後使用 boolean retrieval 找出我們要的 documents，但這樣並沒有考慮到單詞的重要性。換句話說，一個很常出現的單詞有可能並沒有比一個出現次數較少但卻在某 document 出現還要重要，我們可能更想要抓出含有那個單詞的文章。所以我們必須要 rank 那些抓出來的 terms。Problems with Boolean retrieval  Not many users are capable of writing high-quality Boolean queries, and many find the process too time-consuming.  Feast or famine: Boolean queries tend to return either too many results, or no results at all.  Intuitively, whether or not a document ‘matches’ a search query is not a Boolean property, but is gradual in nature.Ranked retrieval      A ranked retrieval system assigns scores to documents based on how well they match a given search query. (There are many possible ways of scoring.)        Based on the score, a ranked retrieval system can return a list of the top documents in the collection with respect to the query.  前面提到的 boolean retrieval 只考慮了文件是否包含或不包含要的詞彙，為了那個詞彙的「重要性」也考慮進去，我們要給予每個 term 不同的 weight。Term weighting  The score of a document d with respect to a query q is the sum of the weights of all terms t that occur in both d and q.  Any specific way to assign weights to terms is called a term weighting scheme.計算 weight 的方法有很多種，也可以自行定義，這邊介紹一種常用的方法。TD–IDF weightTD–IDF is Term frequency–inverse document frequency. This formula includes two parts: Term frequency &amp;amp; Inverse document frequency.Term frequencyThe number of times a term t occurs in a document d is called the term frequency of t in d, and is denoted by tf(t, d).-A problem with term frequencyRelevance is not a linear function of term frequency. 例如，一個出現20次的單詞難道就代表它比一個只出現1次的單詞重要20倍嗎？為了要降低出現頻率造成太大的影響，所以我們將 frequency 取 log，這時候 weight(t, d) 定義成，稱作，log-frequency weighting-Another problem with term frequency時常重複出現的慣用詞彙對一個文件的影響很大。例如，現在想要考慮 Sherlock Holmes 裡包含 Moriarty 和 Holmes 的章節，但當我們下 query 去找時會發現，Holmes 出現最多的章節幾乎沒有 Moriarty，這是因為 Holmes 在這些文本裡出現的比例實在太高了，如果直接以它出現的頻率來分析肯定會造成很大的誤差，進而影響了出現次數少很多的 Moriarty。所以這時候 Inverse document frequency 就非常重要了！Inverse document frequency  Let N be the total number of documents in the collection.  The number of documents that contain a term t is called thedocument frequency of t, and is denoted by df(t).It denotes by idf(t):df(t) 越大代表該詞彙出現在越多文章中，也就是說，如果 df(t) 越常出現，則 idf(t) 就會越小，換句話說，該詞彙的重要性越小。TD–IDF Weight現在我們有了 td 和 idf，tf–idf weight 就是將這兩個數字相乘（出現次數乘以重要性），The tf–idf weight of a term t in a document d is defined aswhere N denotes the number of documents in the collection.Variations of the tf–idf weighting scheme因為 df(t) 可能是 0，所以我們改良一下上面的式子。In scikit-learn, the tf–idf weight is computed aswhere N denotes the number of documents in the collection.The vector space modelDocument representations      Documents as sets of termsIn Boolean retrieval, the only relevant information is whether or not a term is present in a document.        Documents as bags of termsIn ranked retrieval based on term frequency, the only relevant information is how often a term is present in a document.  The vector space model – idea 1Represent documents as vectors in a high-dimensional space:  The dimensions (axes) of the space correspond to the terms inthe vocabulary (potentially relevant terms). For example: could be set of all words in the collection, set of most frequent words, …  The values of the vector components depend on the term weighting scheme: Boolean values, counts, tf–idf values, … (in scikit-learn: CountVectorizer, TfidfVectorizer)The vector space model – idea 2To rank documents in the vector space model,  we represent the query as a vector in the same space as the documents in the collection  we compute the score of a candidate document as the similarity between its document vector and the query vector (similarity = proximity in the vector space)Cosine similarity以下舉一個從一篇部落格看到的例子，例如:Query = {“Hello”}Doc1 = {“Foo”, “Foo”}Doc2 = {“Hello”, “World”}在經過計算之後，我們知道其向量分別為（可以使用 tf-idf values, counts,… 等等）Query = (1, 0, 0)Doc1 = (0, 0, 2)Doc2 = (1, 1, 0)我們可以使用歐幾里德距離算出 query 和兩個 documents 的距離分別是，根號5和1。但計算歐幾里德距離忽略掉了單詞出現的頻率的影響。如果說今天把上面的向量改一下，Query = (2, 0, 0)Doc1 = (0, 0, 4)Doc2 = (2, 2, 0)這時候 所有的距離都變成了兩倍，但其實他們完全是平行的向量。那如果我們考慮向量之間的角度呢？也就是計算兩個向量的 dot，這時候會發現，長度還是影響了最後的數值。因此，使用 Cosine similarity 來將數值 normalized。使用 cosine 後，數值只會介於 -1 和 1 之間，並且只需要考慮非0的數值。Evaluation of information retrieval systemsTo evaluate an IR system we need:  a document collection  a collection of queries  a gold-standard relevance judgementPrecision:Precision (P) is the fraction of retrieved documents that are relevantRecall:Recall (R) is the fraction of relevant documents that are retrievedF1-measureA good system should balance between precision and recall.   The F1-measure is the harmonic mean of the two values:Lab: Information Retrieval LabReference:732A92 Texting MiningIntroduction to Information Retrieval[文件探勘] TF-IDF 演算法：快速計算單字與文章的關聯Vector Space Model(1)如何辨別機器學習模型的好壞？秒懂Confusion Matrix",
      "url": " /text%20mining/2019/11/05/Text-Mining-Information-Retrieval/",
      "author": "Shihs",
      "categories": "Text Mining"
    }
    ,
  

    "machine-20learning-2019-03-12-machine-learning-markov-chain-monte-carlo-mcmc": {
      "title": "[Machine Learning]Markov Chain Monte Carlo (MCMC)",
      "content"	 : "MCMC 是什麼？Markov Chain Monte Carlo （MCMC）是一種抽樣方法，用來解決無法直接抽樣的分佈的隨機抽樣問題。The Goal of MCMCWe want to sample from some distribution p, or approximate an 通常 p 是一個很複雜的 distribution，要從這個分佈取 sample 根本不可能，所以這時候就會需要 MCMC。為什麼要使用 MCMC？在 Baysian Inference 中常使用到這個公式或是，它的參數  的貝式估計其中的  為先驗機率 (prior probability)，基本上我們無法獲得  的值，這時候就需要 MCMC。MCMC 由兩部分的觀念 (步驟) 組成, 一個是 「Markov Chain」 ，另一個則是「Monte Carlo integration」，接下來將說明這兩個部分。Monte Carlo IntegrationMonte Carlo Integration 可以以抽樣平均的方式計算上面的期望值式子也就是說，使用樣本平均數來估計期望值。這件事情可以成立是因為，根據大數法則，當樣本數 n 夠大時，樣本的平均數將趨近於母體平均數。這樣看起來 Monte Carlo Integration 讓我們省去了上面那個看起來複雜的積分式子。但是，現實生活中很多時候並無法從  這個 distribution 抽樣，要不就是不知道這個 distribution，要不就是這個 distribution 爆炸複雜啊。所以說，哪有這麼好的事？這時候可以採用其他的抽樣方法，譬如，rejection sampling, importance sampling 和本文的重點 MCMC。Markov Chain      Markov Chain (馬可夫鍊)：A Markov chain is a sequence  of random variables such that the distribution of the next value depends only on the current on (and parameters). 現在有一隨機變數數列 ，且每一個變數只和前一個變數有關，也就是  來自 ，像這樣的數列我們就稱為馬可夫鍊。         被稱為這個馬可夫鍊的轉換核心 (transition kernel)        A Markov chain is stationary, with stationary distribution         One shows (not trivial in general) that under certain conditions a Markov chain will converge to the stationary distribution in the limit. 在一般條件假設底下，馬可夫鍊的變數分配將收斂到目標機率函數  並且與  的選擇無關。  Monte Carlo Integration可以看這裡Reference:(ML 18.1) Markov chain Monte Carlo (MCMC) introduction-12eZWG0Z5gY.mp4The Markov Chain Monte Carlo Simulations Linköping University - 732A90 Computational Statistics 2019 Lecture 4 slide[数据分析] Markov Chain Monte Carlo徐亦达机器学习课程 Markov Chain Monte CarloMCMC(一)蒙特卡罗方法",
      "url": " /machine%20learning/2019/03/12/Machine-Learning-Markov-chain-Monte-Carlo-(MCMC)/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2019-03-02-machine-learning-covolutional-neural-networks-cnn-2": {
      "title": "[Machine Learning]Covolutional Neural Networks(CNN)(2)",
      "content"	 : "前面介紹了 Convolution operation。  Padding  Strided Convolution  Convolutions Over Volume***Padding為什麼需要 Padding?Convolution operation 的缺點：  經過 convolution fitler 後原始圖將變小。如果有很多層 convolutional layer，資訊在每次運算後不斷損失。  最邊緣的 pixel 只會被使用到一次，但中間的 pixel 會使用到較多次。也就是說，會有邊緣的很多資訊缺失。所以為了解決以上的缺點，我們將 input 的圖的邊緣加上一個 pixel，這樣經過卷積運算後的圖像仍和原圖一樣大。邊緣也是可以加 2 pixel 的。以上圖為例，原本為 6x6(nxn) 的圖，經過 3x3(fxf) 的 filter 做卷積運算後，變為 (n-f+1)x(n-f+1) 的圖。但如果今天邊緣加上 p pixel，最後圖檔就會變為 (n+2p-f+1)x(n+2p-f+1) 的圖。The choice of padding - Vaild and Same convolutions  Vaild - No padding  Same - Pad so that output size is the same as the input size根據上面的公式，如果在 input 圖邊緣加上 pixel 後經過卷積運算要和原始圖檔大小ㄧ樣，那要符合 n+2p-f+1 = n，那就會得到 p = (f-1)/2For computer vision, usually f is odd. 3 by 3 filters are very common.Strided Convolution前面我們在做 convolution 時 filter 都是一次跳一格計算，strided 則是一次跳不只一格。如下圖，這時候最後結果的 pixel 也會不同，計算公式就會是 ((n+2p-f)/2)+1 取 floor。cross-correlation vs. convolution  cross-correlation：數學家喜歡將 convolutional operation 稱為 cross-correlation。在做運算時會將 filter 做水平與垂直翻轉，如下圖。  convolution：在 deep learning 通常都稱為 convolution，且不會將 filter 做鏡射的動作。那這樣幹嘛要翻轉？因為在做訊號處理時，翻轉後會有一些好的特性可以拿來使用。但在做 deep learning 時基本上沒有影響，所以做 deep learning 時不會翻轉 filter。Convolutions Over VolumeConvolutions on RGB impages前面舉的例子都是在 2D 上計算 convolution，現在要來看如何在 3D 上實現 convolution。Reference:Coursera - Convolutional Neural Networks(deeplearning.ai)",
      "url": " /machine%20learning/2019/03/02/Machine-Learning-Covolutional-Neural-Networks(CNN)(2)/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "algorithm-2019-03-02-algorithm-e5-9f-ba-e5-9b-a0-e6-bc-94-e7-ae-97-e6-b3-95genetic-algorithm": {
      "title": "[Algorithm]基因演算法Genetic Algorithm",
      "content"	 : "基因演算法（Genetic Algorithm）是一種求函數極值的最佳化（函數的最大或最小值）的方法。它的想法是來自於基因遺傳，透過細胞分裂將好的基因保留，不好的基因淘汰，一代傳一代，最後留下最適合生存的物種，所謂「適者生存」。實現的方式就像基因的機制那樣，透過隨機選擇後，再進行 crossover 和 mutation，經過多次迭代後，最後結果將會收斂到一個最佳解。但這最佳解不ㄧ定是 global maximum（minimum），通常是 local maximum（minimum）。（但其實這與基因的真實行為完全無關，就像是 Neural Network 和人類神經反應的真實行為無關一樣。）演算法流程圖Source  一開始隨機產生n個變數 (n由使用者決定)  利用適應函數（fitness function）計算所有變數的適應值  依每個的適應值進行「選擇、複製」  對留下的變數進行交配（crossover）及突變（mutation）的動作範例以下範例是來自演算法筆記的 Optimization1.[初始化]一開始先隨便弄出幾個x。本例是四個。10101010101011001011111010101100101010002.[fitness function]根據問題特性，定義好壞程度。f(1010101010) = 6783.[selection]隨便找個位置切一刀，每個x都被分成兩段。1010101  0101011001  0111110101  0110010101  0004.[crossover]隨便找兩組你覺得夠優良的x，交叉相接變成新答案。重複一直做，直到x數目跟原先一樣多。本例是四個。1010101 / 010  -&amp;gt;  1010101 -- 0111011001 / 011      1011001 -- 010 10101010111011001010111010101010101010005.[mutation]每個x都隨便找一個地方把數字改掉，也可以不改。10101110111011001000111010101010101010016.重複3. 4. 5.，直到裡面有一個x是你滿意的，令f(x)最大的那個x。  隨機產生N個x。  計算fitness function。  重複以下步驟，直到有一個x讓人滿意。　甲、selection。　乙、crossover。　丙、mutation。　丁、計算fitness function。一開始的 x 的足夠豐富，多演化幾次就可以得到不錯的結果。一開始的 x 足夠豐富，可以避免進入區域極值。 mutation 用於增加 x 的豐富性，以跳脫區域極值。Reference:演算法筆記 - OptimizationGenetic Algorithm 基因演算法人工智慧系列之基因演算法",
      "url": " /algorithm/2019/03/02/Algorithm-%E5%9F%BA%E5%9B%A0%E6%BC%94%E7%AE%97%E6%B3%95Genetic-Algorithm/",
      "author": "Shihs",
      "categories": "Algorithm"
    }
    ,
  

    "python-2019-02-27-python-filter-map-reduce-lambd": {
      "title": "[Python]filter、map、reduce、lambda",
      "content"	 : "  lambda 可以直接定義一些簡單的 funciton。  filter、map和reduce這三個函數有點像 R 裡頭的 apply 家族系列。lambda我其實覺得就是定義 funciton，只是是定義一些簡單，可以一行完成的 funciton。# 回傳輸入的變數 + 1fun = lambda x: x + 1print (fun(3))# 上面的 func 其實就等於def fun(x):  return x+1# 輸入兩個變數fun = lambda x, y: x+yprint (fun(3, 5))# 含 iffun = lambda x: True if x % 2 == 0 else Falseprint (fun(3))filter(function, sequence)對 sequence 中的 item 依序執行 function(item)，然後將執行結果為 True 的 item 組成一個 list/string/tuple（與 sequence 類型相同）回傳。這時候 function 可以使用 lambda 定義或是平常的 def 定義。# 回傳是數字，除 0 外都是 Truefun = lambda x: x-1print (filter(fun, range(3)))# function 為 defdef f(x): return x % 2 != 0 and x % 3 != 0 print (filter(f, range(2, 25)) )# function 為 lambdaf = lambda x: x % 2 != 0 and x % 3 != 0 print (filter(f, range(2, 25)) )map(function, sequence)對 sequence 中的 item 依序執行 function(item)，執行結果以 list 回傳。# funciton 只有一個參數res = map(lambda x: x**2, range(1, 11))print (res)# 每次都回傳 1res = map(lambda i: 1, range(1, 11))print (res)# function 有兩個參數res = map(lambda x, y: x*y, range(1, 11), range(2, 12))print (res)reduce(function, sequence, starting_value)對 sequence 中的 item 順序迭代調用 function，最後回傳一個值。from functools import reduce # 在 python3 是必須的# 求 list 的和res = reduce(lambda x, y: x+y, range(1, 10))print (res)Reference:Python特殊语法：filter、map、reduce、lambda [转]",
      "url": " /python/2019/02/27/Python-filter-map-reduce-lambd/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "machine-20learning-2019-02-25-machine-learning-reinforcement-learning": {
      "title": "[Machine Learning]Reinforcement Learning",
      "content"	 : "複習機器學習可以被分為三大類：      Supervised Learning:Learn to generalize and classify new data based on labelled training data. 像是 regression 和 classification 就屬於 Supervised Learning。        Unsupervised Learning:Discover structure and relationships in complex high-dimensional data. 像是 cluster。        Reinforcement Learning:Generate policies/strategies that lead to a (possibly delayed) reward. Learn by interacting with the environment! 和人類學習的過程很像，會根據環境而行動，並做調整（像是學騎腳踏車）。這篇主要就是要介紹 Reinforcement Learning。  Reinforcement Learning 可以做什麼？  2016 年 AlphaGo 擊敗世界棋王使用的就是 Reinforcement Learning  Robot Learns to Flip Pancakes  pole balancingDifferences to other methods  Difference to supervised learning          Time! Reinforcement Learning 的學習時間會比 Supervised Learning 費時（當然要有缺點，不然大家幹嘛還要用 Supervised Learning），所以如果有 labels 通常還是會選用 Supervised Learning，但當事前沒有 labels，不知道結果的時候就可以使用 Reinforcement Learning。      Can become better than the system designer, unlike a supervised system that can never become better than the teacher. 因為 Supervised Learning 是根據 system designer 給的 labels 下去計算，但 Reinforcement Learning 是機器自己學習所獲得的結果，就像是，雖然教練教學生打球，但學生的學習成果可能比教練還好。      Feedback is usually not immediate but is given after many actions - delayed feedback! 像是下棋，要等到結果贏或輸才會知道是得到 positive reward 還是 negative reward。      Feedback is given as a scalar reward, not as the correct action to make. Supervised Learning 的 feedback 是結果是否正確，但 Reinforcement Learning 得到的 feedback 是 reward（can be positive or negative）。        Difference to control theory          No physical model of the world, e.g., in pole balancing      機器怎麼學？不像 Supervised Learning 有 lable 可以知道結果是正確還是錯誤， Reinforcement Learning 的學習方法是透過 reward 來知道學習結果正確或不正確（就像是狗狗學習技能，如果做對了就給東西吃一樣）。所以透過打分數的結果來知道怎麼樣的行為是正確的而進行調整，往正確的學習道路邁進。（所以每次學習結果所獲得的 reward 就變得有點像是 Supervised Learning 的 labels 的感覺，只是這個 labels 是從學習的過程中獲得的）Reinforcement Learning 如何進行？Reinforcement Learning 問題的基本設定&amp;lt;A, S, R, P&amp;gt;  Action space : A  State space : S  Reward: R : S × A × S → R  Transition : P :S × A → SA 代表的是 Agent 的所有動作（action）；S 是 state，是 Agent 所能感知的狀態； R 是 reward 代表獎勵或懲罰，是一個實數；P 是 Agent 所交互的世界，也被稱為 model。根據上圖（Source），電腦是 agent，地球代表 environment（環境），reward（獎勵）是環境所提供的反饋，reward 由模型設計者定義，可以是 positive 或是 negative，reward 的定義對強化學習來說是個很重要的一環。PolicyPolicy 就是 agent 根據每個 state 所做出的不同的 action，也就是根據不同的狀態 agent 會採取不同的「策略」。定義為 ，是 RL（Reinforcement Learning） 最核心的問題。可以將 policy 看成是當 agent 感知到 state(S) 採取 action(A) 的 mapping。policy 可以分為隨機的（stochastic policy）和確定性的（deterministic policy）。  stochastic policy:   deterministic policy: RewardReward 是 RL 非常重要的一環，沒有 reward，agent 就不會知道到底學習正確還是錯誤。透過 reward，agent 才知道剛剛採取的 action 好不好。以下圖（Source）為例，最一開始的 state 是 ，agent 做了  的 action，這時候產生了一個 reward ，然後因為剛剛的  這時候 state 來到 ，而 agent 要採取下一步  的時候就會根據剛剛的  來反應。agent 就這樣一步一步根據 reward 的結果來學習。但其實並不是所有的學習都會像這個例子一樣立即獲得 reward，像下棋就會是整局結束後才得到 reward。另外，需要注意的是，Reward  Goal。也就是說，agent 的目標並不是「當前」reward 最大，而是「平均累計」回報最大。總結來說，Reinforcement Learning 的目標就是找到一個最佳的 Policy（策略），讓最後平均的 reward 最大！所以現在問題就來了，要如何衡量這個 policy 好不好？哪些 policies 是我們想要 explore 的？Value functionValue function - How good is a policy?定義從長期來看 action 平均回報的好壞。例如，象棋中吃掉對方的車看起來即時收益很大，但如果因為吃掉對方的車自己的將卻被吃了，那麼從長期看這個 action 就不是一個好的選擇。 表示的是策略 ，狀態 s 的長期期望收益。 是策略  在狀態 s 下，採取動作 a 的長期期望收益。      長期回報期望： （因為  介於 0 和 1 之間，所以 makes immediate rewards more important than distant rewards）        Value function：        Q function：  How to learn V(s)?      Monte Carlo approach        Temporal Difference approach  Summary  For a given policy, the value (expected reward) V(s) of each state is unknown before we learn it by interacting with the environment.  V(s) is found iteratively, starting for example with V(s)←0, using the Monte Carlo or Temporal Difference methods.  The Temporal Difference method generally converges much faster.Q-LearningWhich policies should we explore?上面介紹了 V(s) 是狀態 s 的長期期望收益，那 agent 要如何決定根據它來決定要做什麼 action 採取什麼 policies 呢？這時候我們就會加上 action 這個變數來看，也就是上面提到的 Q(s, a)。   denote the value function for the optimal policy   is expected future reward of doing action a in state s and then following the optimal policy    未知，必須透過學習得到。,  is learning rate這篇文章翻譯了這個原文，我覺得非常好理解。但要整篇整理在這裡太麻煩了，所以自己看吧。Reference:Linköping University Neural Networks and Learning Systems TBMI26 / 732A55 2019 Lectures.深度强化学习（Deep Reinforcement Learning）入门：RL base &amp;amp; DQN-DDPG-A3C introductionwikipedia - 強化學習強化學習 Reinforcement Learning莫凡python[機器學習 ML NOTE] Reinforcement Learning 強化學習(DQN原理)如何用简单例子讲解 Q - learning 的具体过程？A Painless Q-learning Tutorial (一个 Q-learning 算法的简明教程)",
      "url": " /machine%20learning/2019/02/25/Machine-Learning-Reinforcement-Learning/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2019-02-25-machine-learning-covolutional-neural-networks-cnn": {
      "title": "[Machine Learning]Covolutional Neural Networks(CNN)(1)",
      "content"	 : "這篇為 Coursera 上 Convolutional Neural Networks 這門課第一週的 Computer Vision、Edge Detection Example 和 More Edge Detection 筆記。前言：因為 Deep Learning 的快速發展，所以電腦視覺（computer vision）這幾年也迅速的超展開。像是自動駕駛就受惠於 computer vision 的進步，讓自駕車能更準確的偵測路人和其他車輛，提升安全性；或是人臉辨識系統也變得更厲害，像是手機的人臉辨識解鎖；或是使用 Deep Learning 辨別照片是屬於風景照、人、動物還是車輛等等（像是 iphone 的相簿現在就很變態的會自動歸類照片是什麼）；甚至在藝術作品上都有 Deep Learning 的蹤影。為什麼要使用 Covolutional Neural Networks(CNN)？Computer Vision Problem以上圖的例子來看，第一張是 64x64 的照片，第二張畫素則是 1000x1000，這時候如果再加上 RGB 三原色的維度，兩張照片的維度分別會是 64x64x3 和 1000x1000x3。以 Neural Network 來實作的話（右下角），input layer 的 Xn 的 n = 1000x1000x3，如果第一層的 hidden 是 1000 個 nodes，這時候轉換的 W 的維度就會是 1000x3000000，這是不是很 CRAZY？所以這時候就會碰到以下的問題。缺點  很難避免 overfitting  計算上需要大量的電腦效能和 CPU，實在太不切實際了因此，為了解決的這個問題，我們就需要用到 CNN。CNN 的流程圖SourseHow the convolution operation works?現在先來看 convolutional layer 的部分，也是 CNN 非常重要的一個環節。這邊使用 Edge detection 作為範例操作 convolution operation 是如何運作的。Edge detection example在辨識下圖時我們可能會想要做垂直的邊緣辨識和水平的邊緣辨識。那要如何操作呢？Vertical edge detection最左邊的圖是一張 6x6 pixel 的黑白圖，每個 pixel 的數字表示灰階的深度，數字越小代表顏色越深。中間是一個 3x3 的 filter，在有些地方會被稱為 kernel，但這門課都會稱作 filter。這樣的兩個 matrix 做 convolution 運算後（用 * 表示），會產生一個 4x4 的 matrix。運算方法則是，將 3x3 的 filter 與圖片的左上方 match（如圖片淺藍底），對應到的格子相乘，最後再將九個數字相加。依序移動 3x3 的 filter，如此最後就會產生一個 4x4 的 matrix。而中間的 filter 可以看到是一個由左至右從淺到深的圖。因為現在做的是 Vertical edge detection，所以才會選擇這樣的 filter。再看一個例子，我們可以看到，最右邊最後產生的是一個中間一條白色的圖，這就偵測到了我們的想找垂直邊緣的圖（最左邊）的正中間有個邊界。（這個例子看起來邊緣很寬，是因為我們這個圖只有 6x6，如果今天用大一點的圖 1000x1000 就會發現這樣的偵測效果是很好的）Different transitions剛剛的例子是由亮到暗（上），現在的例子是由暗到亮（下），會發現時候最後運算出來的 matrix 也會不同，根據中間的數字我們可以知道，這張圖是由亮到暗還是由暗到亮。下圖的中間偵測得到邊緣數字是 -30，如果今天需要偵測的結果需要知道深淺的變化，那數字就是重要的，但如果今天只是要抓邊緣，也可以將 -30 取絕對值，一樣能抓到轉換的邊界。Vertical and horizontal edge detection看完了垂直的範例，我們再看一下偵測水平邊緣的 filter。Different filters從上面的結果可以發現，不同的 filter 可以讓我們偵測出不同的狀況。這邊提了一下兩個 filter，Sobel filter 和 Scharr filter。其實我們可以不需要直接使用現成的 filter，而是可以訓練出一個 filter 針對我們的需求，這之後會再提。Reference:Coursera - Convolutional Neural Networks(deeplearning.ai)",
      "url": " /machine%20learning/2019/02/25/Machine-Learning-Covolutional-Neural-Networks(CNN)/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "others-2019-01-22-ascii-unicode-e5-92-8c-utf-8": {
      "title": "字元編碼，ASCII、Unicode、UTF-8",
      "content"	 : "關於編碼，相信大家很常聽到 ASCII、Unicode、UTF-8 這幾個名詞，這篇要根據我的理解來介紹這三個名詞。若有錯歡迎指正:)2022/03/15 上完 Harvard CS50 的 Lecture 0 後做了一些新增與修改。字元編碼  在電腦的世界是使用二進位（binary）的方式來進行運算，也就是 0 與 1 兩個 digits（each binary digit called bit）。  而電腦是使用「關」與「開」來表示二進位中的 0 與 1。  在現代電腦中是由上百萬的電晶體（transistors）來控制這樣的「關」與「開」（0 與 1）。ASCIIASCII 是電腦早期發展時由美國制定的一套編碼規則，且沿用至今。它的目的是用來統一規範，規定數字與字母大小寫、符號等等的對應關係，而每一個數字由 8 個 bits 表示。最後一次更新是在1986年，至今為止共定義了 128 個字元。像是 HI! 就是由數字 72、73 和 33 所組成的。由二進位表示就是，01001000、01001001、00100001。Extended ASCII但因為一個 byte 共有 8 個 bits，也就是說還有很多個位元並未使用到，所以後來又產生了 Extended ASCII。很多歐洲國家有一些字母並未在 ASCII 中，所以除了 ASCII 為固定的字元外，每個國家根據自己所需給與字元，但也造成每個國家並未統一編碼。（Wikipedia）Unicode隨著網際網路的發展，世界各國交換訊息，未統一的編碼便造成了很大的問題。這時候有了 Unicode 的誕生。Unicode 協會將所有的文字與符號都分配一個數字，這個數字的寫起來像是，U+0645，而這個數字就稱為 Code point。U+ 的意思是 Unicode，數字則是用十六進位表示。但 Unicode 編碼使用至少兩個位元儲存字元，若是今天只有英文，仍舊是每個字元使用兩個位元儲存，這表示浪費了很多的資源。所以這時候有有人想出了更好的辦法。UTF-8有人發明了 UTF-8 這種儲存方式。UTF-8 編碼把一個 Unicode 字元根據不同的數字大小編碼成 1-6 個字節，常用的英文本母被編碼成 1 個字節，漢字通常是 3 個字節。如果今天要傳輸的內容都是英文，這時使用 UTF-8 編碼就能省下空間。比較Unicode 是一種編碼方式，和 ASCII 是同一個概念，而 UTF-8 是一種存儲方式，在存儲和傳輸上節約空間、提高性能的一種編碼形式Reference:字符编码笔记：ASCII，Unicode 和 UTF-8淺談電腦編碼與 Unicode (一) 基礎概念篇常見三種字符編碼的區別：ASCII、Unicode、UTF-8[轉錄] [doc] 每個軟體開發者都絕對一定要會的Unicode及字元集必備知CS50 2022 - Lecture 0",
      "url": " /others/2019/01/22/ASCII-Unicode-%E5%92%8C-UTF-8/",
      "author": "Shihs",
      "categories": "Others"
    }
    ,
  

    "python-2019-01-02-python-pyinstaller-e5-87-ba-e7-8f-be-e9-8c-af-e8-aa-a4-e8-a8-8a-e6-81-afattributeerror-type-object-pandas-tsobject-has-no-attribute-reduce-cython": {
      "title": "[Python]pyinstaller出現錯誤訊息AttributeError:type object pandas._TSObject has no attribute _reduce_cython_",
      "content"	 : "在打包含有 pandas 套件的程式碼時產生了以下的錯誤訊息，根據Hooks: Add hook-pandas.py to fix issue #2978. #2998的討論串，有人回答when run pyinstaller -F xxx.py in windows10 , I get error AttributeError: type object &#39;pandas._libs.tslib._TSObject&#39; has no attribute &#39;__reduce_cython__&#39;, and solve it by degrade pandas version to 0.20.0.我將 pandas 套件的版本降至 0.20.3 也確實解決問題了。先檢查一下 pandas 版本pip show pandas將版本降至 0.20.3pip install pandas==0.20.3這時候打包完後執行應該就不會有問題了！Reference:Hooks: Add hook-pandas.py to fix issue #2978. #2998成功解决pyinstaller打包AttributeError:type object pandas.TSObject has no attribute _reduce_cython",
      "url": " /python/2019/01/02/Python-pyinstaller%E5%87%BA%E7%8F%BE%E9%8C%AF%E8%AA%A4%E8%A8%8A%E6%81%AFAttributeError-type-object-pandas._TSObject-has-no-attribute-_reduce_cython_/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-2019-01-02-python-e8-ae-80-e5-8f-96-e8-88-87-e5-af-ab-e5-85-a5xlsx-e6-aa-94-e6-a1-88": {
      "title": "[Python]讀取與寫入xlsx檔案",
      "content"	 : "這裡要介紹使用 pandas 套件讀取與寫入 xlsx 檔案。在開始前請先安裝 pandas 套件，pip install pandas讀取檔案df = pd.read_excel(&quot;filename.xlsx&quot;, header = None)# 獲取列數rows = df.shape[0]# 獲取儲存格內容df.iat[1, 0]# 修改儲存格內容df.iloc[1, 0] = &quot;test&quot;# 但修改後必須要儲存才會修正檔案內容# df.to_excel(&#39;test_result.xlsx&#39;, sheet_name = &#39;sheet1&#39;)若在執行以上程式碼時產生錯誤訊息：Pandas pd.read_excel giving ImportError: Install xlrd &amp;gt;= 0.9.0 for Excel support這時候只要安裝 xlrd 套件就能解決問題。pip install xlrd寫入檔案import pandas as pd# Create a Pandas dataframe from some data.df = pd.DataFrame({&#39;Data&#39;: [10, 20, 30, 20, 15, 30, 45]})# Create a Pandas Excel writer using XlsxWriter as the engine.writer = pd.ExcelWriter(&#39;pandas_simple.xlsx&#39;, engine=&#39;xlsxwriter&#39;)# Convert the dataframe to an XlsxWriter Excel object.df.to_excel(writer, sheet_name=&#39;Sheet1&#39;)# Close the Pandas Excel writer and output the Excel file.writer.save()以上的程式碼是參考這裡。我存的檔案內容是中文，這時候產生了像這樣的錯誤訊息Python pandas to excel UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xe2 in position 11只要將 pd.ExcelWriter 裡的參數 engine=&#39;xlsxwriter&#39; 改成 engine=&#39;openpyxl&#39; 就可以了。Reference:Example: Pandas Excel examplePython: Pandas pd.read_excel giving ImportError: Install xlrd &amp;gt;= 0.9.0 for Excel supportPython pandas to excel UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe2 in position 11PYTHON pandas 操作Excel 基本介紹",
      "url": " /python/2019/01/02/Python-%E8%AE%80%E5%8F%96%E8%88%87%E5%AF%AB%E5%85%A5xlsx%E6%AA%94%E6%A1%88/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-2019-01-02-python-e5-85-a8-e5-bd-a2-e8-88-87-e5-8d-8a-e5-bd-a2-e8-bd-89-e6-8f-9b": {
      "title": "[Python]全形與半形轉換",
      "content"	 : "因為全形字元的 unicode 編碼從 65281~65374，而半形字元的 unicode 編碼從 33~126，也就是同樣的字在全形與半形數字會差 65248。例如，半形的驚嘆號（!）是 unicode 編碼是 33，則全形的驚嘆號（！）unicode 就會編碼是 33 + 65248 = 65281但要將數字解析成半形時是使用 chr() function，而全形則是使用 unichr() function。以下將 33~126 全部列出來，並轉換成全形。for i in xrange(33,127):print i, chr(i), i+65248, unichr(i+65248).encode(&quot;utf-8&quot;)結果，33 ! 65281 ！34 &quot; 65282 ＂35 # 65283 ＃36 $ 65284 ＄37 % 65285 ％38 &amp;amp; 65286 ＆39 &#39; 65287 ＇40 ( 65288 （41 ) 65289 ）42 * 65290 ＊43 + 65291 ＋44 , 65292 ，45 - 65293 －46 . 65294 ．47 / 65295 ／48 0 65296 ０49 1 65297 １50 2 65298 ２51 3 65299 ３52 4 65300 ４53 5 65301 ５54 6 65302 ６55 7 65303 ７56 8 65304 ８57 9 65305 ９58 : 65306 ：59 ; 65307 ；60 &amp;lt; 65308 ＜61 = 65309 ＝62 &amp;gt; 65310 ＞63 ? 65311 ？64 @ 65312 ＠65 A 65313 Ａ66 B 65314 Ｂ67 C 65315 Ｃ68 D 65316 Ｄ69 E 65317 Ｅ70 F 65318 Ｆ71 G 65319 Ｇ72 H 65320 Ｈ73 I 65321 Ｉ74 J 65322 Ｊ75 K 65323 Ｋ76 L 65324 Ｌ77 M 65325 Ｍ78 N 65326 Ｎ79 O 65327 Ｏ80 P 65328 Ｐ81 Q 65329 Ｑ82 R 65330 Ｒ83 S 65331 Ｓ84 T 65332 Ｔ85 U 65333 Ｕ86 V 65334 Ｖ87 W 65335 Ｗ88 X 65336 Ｘ89 Y 65337 Ｙ90 Z 65338 Ｚ91 [ 65339 ［92  65340 ＼93 ] 65341 ］94 ^ 65342 ＾95 _ 65343 ＿96 ` 65344 ｀97 a 65345 ａ98 b 65346 ｂ99 c 65347 ｃ100 d 65348 ｄ101 e 65349 ｅ102 f 65350 ｆ103 g 65351 ｇ104 h 65352 ｈ105 i 65353 ｉ106 j 65354 ｊ107 k 65355 ｋ108 l 65356 ｌ109 m 65357 ｍ110 n 65358 ｎ111 o 65359 ｏ112 p 65360 ｐ113 q 65361 ｑ114 r 65362 ｒ115 s 65363 ｓ116 t 65364 ｔ117 u 65365 ｕ118 v 65366 ｖ119 w 65367 ｗ120 x 65368 ｘ121 y 65369 ｙ122 z 65370 ｚ123 { 65371 ｛124 | 65372 ｜125 } 65373 ｝126 ~ 65374 ～Reference:Python實現全形半形字元互轉的方法",
      "url": " /python/2019/01/02/Python-%E5%85%A8%E5%BD%A2%E8%88%87%E5%8D%8A%E5%BD%A2%E8%BD%89%E6%8F%9B/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "machine-20learning-2018-12-27-machine-learning-linear-regression": {
      "title": "[Machine Learning]Linear Regression",
      "content"	 : "Linear Regression 屬於 Supervised Learning(監督式學習)，用來預測連續型(continuous)的變數。Simple Linear RegressionSimple Linear Regression 假設 (X, Y) 存在線性關係，且可以使用以下的式子來表示 (X, Y)的關係。  而現實中我們無法知道參數 (beta_0, beta_1)，這時候我們會使用 train data 找出估計參數 (hat{beta_0}, hat{beta_1})。簡單線性回歸的估計式可以寫成，  其中，(hat{y}) 是當 (X = x) 時 (Y)的預測值。Estimating the Coefficients現在有一堆 data， ((x_i, y_i), thinspace i = 1, 2, 3, …, n)，根據上面的迴歸式可以將這些 data 表示成，已經知道迴歸模型可以用上面的式子表示，那現在的任務是要找到 (hat{beta_0}) 和 (hat{beta_1})，只要找到這兩個參數就可以預測 (y) 了。找 (hat{beta_0}, hat{beta_1}) 的方法叫 The Least Square Method（最小平方法）。以上圖為例，紅色的點為 observations，深藍色的線是用最小平方法找到的迴歸線。The Least Square Method 是什麼？式子 ( hat{y_i} = hat{beta_0} + hat{beta_1} x_i ) 為 (X = x_i) 時 (Y) 的預測值。我們使用 Residual(殘差) 來看這個預測的結果與實際數值的差距，定義為 (e_i = y_i - hat{y_i}) (上圖中紅點到深藍色線的灰色線段們)。將所有 Residual 相加便能RSS =Reference:An Introduction to Statistical Learning with Applications in R",
      "url": " /machine%20learning/2018/12/27/Machine-Learning-Linear-Regression/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-09-machine-learning-regression-splines": {
      "title": "[Machine Learning]Regression splines",
      "content"	 : "上圖是一個 x, y 的分佈圖，紅線是這些點分部的方程式。但現實中，我們並無法真的知道紅線的方程式，我們可能使用一次方程式、二次方程式甚至更高次方的方程式去嘗試（如下圖）。我們可以將擬合的多項式方程式（polynomial function）寫成，(y = beta_0 + beta_1 x^1 + beta_2 x^2 + … + beta_n x^n + epsilon)但只是一味的提高多項式的次方只是增加模型的複雜度會導致 overfitting 的問題，在 testing data 上的結果也不會太好。這時候我們可以使用 Piecewise 將 data 劃分成多個區間，根據每個區間的 data 給予一個模型去擬合。Basis function(y_i = beta_0 + beta_1 b_1(x_i) + beta_2 b_2(x_i) + … + beta_n b_n(x_i) + epsilon_i)透過 (b_1(X))、(b_2(X))、……、(b_n(X)) 可以將非線性的自變量轉換成線性。Piecewise Function將 data 劃分多個區段後，每個區段再各自找到可以擬合的 model，model 可以是一次方程式、二次方程式或是三次方程式等等，不過三次方最常使用。如下圖每個區段都是用一次方程式去擬合。(xi) 為區段的分隔點，稱為 knot，每個分段函數稱為 piecewise function。From: 《Elements of Statistical Learning》但這些 piecewise function 是有條件的。雖然 piecewise function 是每個區段各自擬合出來的 function，但所有區段 function 必須整個為連續，也就是在 (xi) 的交界處的值必須相同。Cubic Spline這裡則是使用三次方程式。From: 《Elements of Statistical Learning》cubic spline 除了邊界的值相同外，還必須要一階和二階倒數相同。看上圖左上的圖加上邊界連續後成為右上，雖然看起來是連續的函數，但並不是完美的曲線，如果再加上一階導數相同就變成左下，再加上二階導數就可以畫出右下的圖。這個 R code 是畫出最上面圖的程式碼，使用 Introduction to Splines 裡頭的範例。set.seed(100)# functionf &amp;lt;- function(x) {  f_x &amp;lt;- 0.2*x^11*(10*(1-x))^6 + 10*(10*x)^3*(1-x)^10}x &amp;lt;- seq(from = 0, to = 1, length = 500)f_x &amp;lt;- f(x)eps &amp;lt;- rnorm(n = 500, mean = 0, sd = 2) # epsilony &amp;lt;- f_x + epsd &amp;lt;- data.frame(  x = x,  f_x = f_x,  y = y)# plotggplot(d, aes(x = x)) +  geom_point(aes(y = y), size = 0.5) +   geom_line(aes(y = f_x), colour = &quot;red&quot;, size = 0.8) +  theme_bw()ggplot(d, aes(x = x, y = y)) +  geom_point(size = 0.5) +   geom_smooth(method = &quot;lm&quot;, se = FALSE) +  stat_smooth(method = &quot;lm&quot;, formula = y ~ x + I(x^2), se = FALSE, colour = &quot;green&quot;) +  # stat_smooth(method = &quot;lm&quot;, formula = y ~ x + I(x^2) + I(x^3), se = FALSE, colour = &quot;gold1&quot;) +  # stat_smooth(method = &#39;loess&#39;, se = FALSE, colour = &quot;red&quot;) +  theme_bw()Reference:一文读懂回归样条（regression splines），附Python代码Introduction to SplinesSpline Regression | Non Linear Model | Polynomial Regressionwikipedia - 樣條函數Cubic and Smoothing Splines in R《An Introduction to Statistical Learning with Applications in R》",
      "url": " /machine%20learning/2018/12/09/Machine-Learning-Regression-splines/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-08-machine-learning-principal-component-analysis-pca": {
      "title": "[Machine Learning]Principal Component Analysis(PCA)",
      "content"	 : "From: «Pattern Recognition and Machine Learning» P.561What is PCA?Principal Component Analysis(PCA)，中文翻作「主成分分析」。PCA 是一種將多維度降維的方法。一個變數其實可能是多個潛在變因（laten variables）組成，但我們無法實際測量出那些 laten variables，而 PCA 就是要拆解出影響較大的變因。使用較少的變數解釋多個 variables。舉個例子，股市的點數上上下下，我們所能觀測到的是點數這個變數，但其實影響點數變動的潛在變因可能包含了很多市場因素，且每個因素可能又是互相影響。如果用數學符號表示，(x_i) 是我們有的變數，(z_i) 是裡頭含有的潛在變因，(x_i) 是 (z_i) 的線性組合（linear combination）。(x_1 = a_{11} z_1 + a_{12} z_2 + a_{13} z_3 + epsilon_1)(x_2 = a_{21} z_1 + a_{22} z_2 + a_{23} z_3 + epsilon_2)(x_3 = a_{31} z_1 + a_{32} z_2 + a_{33} z_3 + epsilon_3)……可以將上式改寫成，(z_1 = x_1 u_{i1} + x_2 u_{i2} + x_3 u_{i3})……如何降維？根據 «Pattern Recognition and Machine Learning» 這本書第 561 頁給了 PCA 兩種定義  PCA can be defined as the orthogonal projection of the data onto a lower dimensional linear space, known as the principal subspace, such that the variance of the projected data is maximized (Hotelling, 1933).  PCA can be defined as the linear projection that minimizes the average projection cost, defined as the mean squared distance tbtween the data points and their projections (Pearson, 1901).可以用上圖來理解，或是 StatQuest: Principal Component Analysis (PCA), Step-by-Step 這段。根據上面的定義，可以看到，降維的方法是要做 orthogonal projection，且找到投影向量讓投影後的資料變異量最大。這邊我使用 StatQuest: Principal Component Analysis (PCA), Step-by-Step 影片的內容來介紹。  maximized 什麼？假如現在座標上有個綠色的點，以座標((0, 0))原點，其長度為 a（影片沒有表示這是 a 向量，方便起見，後面以 a, b, c 向量表示），c 向量為 a 向量的投影方向與長度。根據畢氏定理，可以畫出一個正三角形，現在三角形的三邊長分別為 a, b, c（因為我懶得再圖上修正了，現在又變回長度）。而 PCA 要找的投影向量就是，最小化 (b^2) 的值，或是最大化 (c^2) 的值。  投影根據上圖，這個二維座標上有好幾個點，我們現在就是要找到一條能讓投影後 variance 最大的投影向量（紅色虛線），如下圖。要找到 SS（eigenvalue） 最小的投影向量。在投影前，我們會先將資料平移 (x_i - mu_i)，也就是不改變點之間的相對位置，這樣不但不會影響找投影向量的結果，在計算上也比較容易。Variation 變異量變異量 = (SS/(n-1), n )是點的數量有了變異量以後，我們通常會想要知道每個投影向量的變異量占比。假如現在有 PC1 其變異量為 15，PC2 的變異量為 3，則 PC1 與 PC2 的變異量總和為 18。所以 PC1 = 15*100%/18 = 83%，PC2 = 3*100%/18 = 17%。在做 PCA 的時候，我們會根據轉換的 (PC_i) 的比重，來決定要考慮要使用幾個 (PC_i)。如果可以解釋百分之九十基本上就可以拿來使用。假如今天有一筆多維度的資料，但轉換後 PC1 與 PC2 可以表示百分之九十的變異量，那麼這時候只要使用 PC1 與 PC2 就好，且還可以在平面座標上看點的分佈。基本上 PCA 就是在做座標變換，將原變數投影成新變數。接著以最少的新變數來代表原始資料最大的成分（variation 涵蓋量最大）。其原則如下  新變數是原變數的線性組合  保留原變數間的最大變異量（variance）Reference:StatQuest: Principal Component Analysis (PCA), Step-by-Step機器/統計學習:主成分分析(Principal Component Analysis, PCA)wikipedia - 主成分分析The Elements of Statistical LearningPattern Recognition and Machine Learning",
      "url": " /machine%20learning/2018/12/08/Machine-Learning-Principal-Component-Analysis(PCA)/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-03-machine-learning-boosting-and-adaboost": {
      "title": "[Machine Learning]Boosting and Adaboost",
      "content"	 : "BoostingFrom: Introduction to Boosted TreesBoosting 也是一種 Ensemble learning，它會結合多個弱分類器（weak classifiers）成為一個較準確的分類器，也可以應用在 regression 上。和 Bagging 有什麼不同？Bagging 各個 classifier 產生的過程是獨立的，但 Boosting 後產生的 classifier 與前面的 classifier 有關。也就是說，Bagging 的 classifier 可以並行產生，但 Boosting 必須要有順序的產生。所以時間上來說，Bagging 可以節省比較多的時間。與前面的分類器有關？在 Boosting 中，每一次產生 classifier 後，後面的 classifier 會根據前面 classifier 的結果調整每個點的權重。在前一個 classifier 分類錯誤後，在後一個 classifier 的權重會比較重，而表現較好的則會權重減少。這就是和 Bagging 最大的不同，Bagging 中所有的點都是隨機選取，且權重都是一樣的。簡單來說，Boosting learns features from data.步驟  用最原始的 training data 跑一個 classifiers  利用這個 classifiers 提高分類錯誤的點的權重，降低分類正確的點的權重。  重複第二步驟 N 次，最後使用權重的平均值。AdaBoostFrom: 機器學習: Ensemble learning之Bagging、Boosting和AdaBoostAdaBoost 應用了 boosting 的方法。概念假設現在有 n 個樣本，要執行 boosting T 次。第一次將所有樣本的權重都設為 (alpha_i) = 1/n, i = 1, …, n對所有 t = 1, …, T  根據樣本的權重 (alpha_i) 建立出 classifier (f_t(x))  使用 (f_t(x)) 後計算 (epsilon_t) 誤差  利用 (epsilon_t) 算出係數 (w_t)  再重新計算 (alpha_i)最後的 model 就會是：(hat{y} = sign sum_{t=1}^{T} w_i f_t(x))AdaBoost 的優勢就是讓 model 能夠從錯中學，使用提升與降低權重的方式讓分類錯誤的點可以在下一次的 model 中被改進。Reference:决策树（二）機器學習: Ensemble learning之Bagging、Boosting和AdaBoostAdaBoost和随机森林的区别Machine Learning -  University of Washington机器学习算法优缺点及其应用领域",
      "url": " /machine%20learning/2018/12/03/Machine-Learning-Boosting-and-Adaboost/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-03-machine-learningdecision-tree": {
      "title": "[Machine Learning]Random Forest",
      "content"	 : "基本上 Random Frost 是要改善 Decision Tree 容易 overfitting 的問題，它結合了 Decision Tree 和 bagging 的方法。Random Forest 是建立很多顆決策樹，再利用多數決選出最好的選項，和 bagging 這篇提到的方法有點類似，但有些小差異。使用的方法是 bagging（結合多個 model），所以這也是 Ensemble learning。Random Forest步驟假如有一 training data，有 N 個樣本，p 個features。今天要利用這個 training data 建立一個 Random Forest model，裡頭共有 B 棵決策樹，  使用 boostrap 從 training data 中抽出 N 個樣本產生一組 data  在這組 data 中隨機從 p 個 featrues 中選取 m (m &amp;lt; p) 個 features，再從這 m 個 features 找出最好的一個分割結果，如此產生一個 node  重複步驟 2，直到完成這個 model 為止  重複步驟 1~3 B 次，共會產生 B 棵擁有不同 feature 的決策樹最後要進行 predict 時，分類問題使用多數決，回歸問題使用平均數決定。  因為每一棵樹的隨機選取的樣本與 feature 都不同，所以每棵樹的結果都不會相同。  Random Frost 建立的 decision tree 不需要 pruning。在 decision tree 剪枝是爲了避免 overfitting，但在 Random Frost 使用 bagging 的方式就已經避免 overfitting 了。  因為每一棵決策樹都是隨機篩選 feature 的結果，所以可以想像每棵樹就像是精通某個領域的專家。當有個新的數據近來，經由各個領域的專家投票表決，做出最後的選擇。      Random Forest 中有兩個參數需要人為控制，一個是樹的數量（B），一般建議取很大。另一個是 feature 的大小（m）。    優點：          不用做特徵（feature）選擇。      訓練完後可以知道哪些 feature 比較重要。      Reference:StatQuest: Random Forests Part 1 - Building, Using and Evaluating随机森林（Random Forest）算法原理AdaBoost和随机森林的区别",
      "url": " /machine%20learning/2018/12/03/Machine-LearningDecision-Tree/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-03-machine-learning-bagging": {
      "title": "[Machine Learning]Bagging",
      "content"	 : "BaggingFrom: Hastie, T., Tibshirani, R. and Friedman, J. The Elements of Statistical Learning. Springer, 2009. p.285Bagging 是什麼？Bootstrap aggregating (bagging) is a machine learning ensemble meta-algorithm to improve classification and regression models in terms of stability and classification accuracy. It also reduces variance and helps to avoid ‘overfitting’. Although it is usually applied to decision tree models, it can be used with any type of model. (Decision Tree - Bagging)簡單來說，Bagging是一種 Ensemble learning方法，它集結一些 model 來做最後的決策。通常會是集結表現沒那麼好的 model，讓這些 model 一起做決定，一種三個臭皮匠勝過一個諸葛亮的感覺。Decision tree 是一個常見的 weak classifier，所以如果在 decision tree 上使用 bagging，可以讓最後表現結果比較好，也避免 overfitting 的情況。Boostrap在開始說明 bagging 步驟前先介紹 bootstrap。bootstrap 是一種抽樣方法。假設今天有一組資料，裡頭共有 N 個樣本，我們想要有 m 個大小為 N 的樣本作為訓練資料。方法是，每次從這 N 個樣本隨機抽取，且每次都是取後放回(也就是有些樣本可能被抽到一次以上，有些樣本可能沒被抽到)，同樣的方法重複 m 次，這樣我們就會有 m 組樣本數為 N 的 y 資料集。這樣的方法在樣本數量少時很有用。如果樣本小，但我們用 train-validation-test 這樣的方式訓練資料，訓練的樣本資料非常小，會造成 bias 較大的問題。而使用 bootstrap 不會減少樣本的數量，也能保留 test data。如何操作？  使用 boostrap 方法從 training data 中採集 B 組樣本數與 training data 相同的資料集。  這 B 組資料集都建立一個 model， (f_b(x))，共產生 B 個 model。  最後預測的結果就是將這 B 個 model 做統合。在分類問題上，可以平均各個 model 的 posterior class probabilities，或是使用 majority voting。（選機率比較大的結果或是多數決）；在回歸上，則取平均值。從最上圖可以看到，不論是使用機率或是投票決定，bagging 選出的結果的 test error 都要比個別的 model 表現較好。除了 Bagging 外，Ensemble learning 還有另一種常見的方法 Boosting，這篇先到這裡之後繼續介紹。Reference:機器學習: Ensemble learning之Bagging、Boosting和AdaBoost随机森林（Random Forest）算法原理The Elements of Statistical LearningPattern Recognition and Machine Learning",
      "url": " /machine%20learning/2018/12/03/Machine-Learning-Bagging/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-03-machine-learning-decision-tree-e5-92-8c-bagging": {
      "title": "[Machine Learning]Decision Tree",
      "content"	 : "Decision TreeDecision Tree是什麼？簡單來說，decision tree 是一個分類模型。  Tree-based methods partition the feature space into a set of rectangles, and then fit a simple model (like a constant) in each one.這是 Pattern Recognition and Machine Learning 裡頭的定義。根據上圖，想像一下，在右邊的二維座標平面上有一堆散布的點，而 decision tree，就是將這個平面一一分割，每一個框框都是一個分類結果。但我們可以用右邊那樣一層一層的樹枝結構狀來表示右邊難懂的圖。（這裡的例子是二維平面，當變數 (x_i) 增加時，這樣的概念可以推廣到多維空間）每一個分支都像是一個 if-else 問題，如果是就選某一邊，不是就選另外一邊。上圖左，我們可以看到有兩個變數，(x_1), (x_2)，第一關是 (x_1 &amp;gt; theta_1 )，如果小於就往左邊分，如果大於就往右邊分，以此類推往下繼續細分，最後給予分類結果。最後共分成 A, B, C, D, E 五個類別，也就是右邊的五個框框。Decision Tree 又可以分為      Regression trees - 最後分類結果為連續變數        Classification trees - 最後分類結果為類別變數  名詞  Root node (The Root) - 第一個起始的點  (Internal) Nodes - 中間的節點。上方會有箭頭指向 node，且 node 也會往下指向其他點。  Leaves (terminal nodes) - 最後的節點，也就是最後的分類結果。如何分類？假如今天我有一份 data，decision tree 是如何決定要先使用哪一個變數與什麼值作為分割呢？分割的原則是，這樣的分割要能得到最大的資訊增益 (Information gain, IG) ([資料分析&amp;amp;機器學習] 第3.5講 : 決策樹(Decision Tree)以及隨機森林)資訊量根據最後的分類結果可以使用，  Regression trees:          MSE (mean-squared error)        Classification trees:          Entropy (Deviance)      Gini impurity      Missclassification error      在 Classification tree 裡，Entropy 和 Gini impurity 是常用的兩種方式，詳細的公式請參考 Wikipedia假如今天碰到兩種 model 算出來的資訊量都ㄧ樣，請選擇比較簡單的那個 model。（分支、leaves node 較少）R 範例這裡使用 tree 這個 library 做範例，另外還有像是 rpart 也是做 decision 常用的 package。library(tree)data(&quot;iris&quot;)# 使用 Entropy (Deviance)fit &amp;lt;- tree(Species ~ Sepal.Length + Petal.Length, iris, split = c(&quot;deviance&quot;))plot(fit)text(fit, pretty=0)summary(fit)# 使用 Gini impurityfit &amp;lt;- tree(Species ~ Sepal.Length + Petal.Length, iris, split = c(&quot;gini&quot;))plot(fit)text(fit, pretty=0)summary(fit)優缺點  優點：          Simple to understand and interpret. 容易理解與解釋      Able to handle both numerical and categorical data. 可以用在類別與 numerical 資料        缺點          Low bias and high variance with respect to the training data.（當 decision tree model 變得太過複雜時，太多 nodes，就會導致 overfitting (bias-variance trade off 的狀況）      所以為了讓 model 不要 overfitting，我們可以使用 pruning 的方式，砍掉底下的樹枝。在 R 可以使用，prune.tree()，並且可以使用 best 這個參數來決定最後要保留多少 leaves。使用剛剛最後的 fit示範prune_fit &amp;lt;- prune.tree(fit, best = 5)plot(prune_fit)text(prune_fit, pretty=0)summary(prune_fit)這時候 leaves 由原本的 9，修剪到了剩下 5，但 Misclassification error rate 卻是相同的。修剪過後的 model 較簡單，且 variance 也會比較小，在預測上表現也會較佳。Reference:[資料分析&amp;amp;機器學習] 第3.5講 : 決策樹(Decision Tree)以及隨機森林StatQuest: Decision TreesThe Elements of Statistical LearningPattern Recognition and Machine Learning",
      "url": " /machine%20learning/2018/12/03/Machine-Learning-Decision-Tree-%E5%92%8C-bagging/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "r-2018-11-10-r-e5-a6-82-e4-bd-95-e5-9c-a8-ggplot2-e5-9c-96-e5-bd-a2-e4-b8-8a-e5-b8-8c-e8-87-98-e5-ad-97-e6-af-8d": {
      "title": "[R]如何在 ggplot2 圖形上希臘字母？",
      "content"	 : "1. 圖形文字Text Labels: Use parse = T inside geom_text or annotate.2. 座標軸標籤Axis Labels: Use expression(alpha) to get greek alpha.3. LegendLegend Labels: Use bquote(alpha == .(value)) in legend label.4. Fecet圖形Facet 圖形比較特殊，要將 labeller = label_parsedFacet Labels: Use labeller = label_parsed inside facet.來源",
      "url": " /r/2018/11/10/R-%E5%A6%82%E4%BD%95%E5%9C%A8-ggplot2-%E5%9C%96%E5%BD%A2%E4%B8%8A%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-10-20-r-environment": {
      "title": "[R]Environments (1)",
      "content"	 : "這篇要介紹 R 的環境(Environments)。我個人覺得環境是一個寫程式很重要但一開始會很困惑的東西，之前一直處於似懂非懂的狀態。其實如果只是用 R 來跑一些數據分析，其實不理解環境並不會造成什麼太大的問題，但如果能夠懂當然絕對是有利無弊。最近有了寫 R package 的經驗後，讓我開始對「環境」比較了解，所以這篇想要將我的理解記錄下來。1. 什麼是環境（Environments）？當我們每次打開 R studio 這時候便是打開了某個環境，接著我們產生了一些變數，這些變數便是在這個環境底下。很抽象嗎？打開 R studio 時，在右上的框框（或是在某個位置）有個「Environment」，然後可以看到如下圖的「Gloabal Environment」，並且在下面的框框可以看到我們產生的變數（圖中的 x）。這就表示，我們現在在「Gloabal Environment」這個環境底下，且 x 這個變數在「Gloabal Environment」環境中。當我們把「Gloabal Environment」這個圖往下拉，可以看到像下圖這樣（每個人的可能都不太一樣）依序往下就會是「Gloabal Environment」的 「parent 環境」。（「parent 環境」是殺毀？！）環境就像是房間我覺得可以把「環境」想像是一個房間。當妳/你在操作 R ，產生任何變數，做任何動作，都是在這個房間裡面操作（通常一打開 R studio 都會是在 Global 環境）。所以這些變數全部都會被放在這個房間裡。或是想像在一個房間裡縫娃娃這些娃娃做完都會被放在這個房間裡。那「parent 環境」就會是，妳/你走出這個房間來到客廳，也就是說，這個房間是被包在家裡的，走出家裡，整個家是被包在建築物裡的，然後社區，然後某條路，某個區，某個縣市……就是一個俄羅斯娃娃的感覺。往上一層就會是「parent 環境」、「grand parent 環境」…..以此類推。2. R 是如何在環境裡找變數的？根據上面的解釋我們知道，每次操作 R 的時候我們都會是在某個環境底下。那這和 R 要找變數有什麼關係呢？在這之前我們先來看我現在有幾間房間呢？search()# [1] &quot;.GlobalEnv&quot;        &quot;tools:rstudio&quot;     &quot;package:stats&quot;     &quot;package:graphics&quot;  &quot;package:grDevices&quot;# [6] &quot;package:utils&quot;     &quot;package:datasets&quot;  &quot;package:methods&quot;   &quot;Autoloads&quot;         &quot;package:base&quot;這表示，最底下的環境是.GlobalEnv(Gloabal Environment)，它的 parent 變數是tools:rstudio，再往上是package:stats……等等，最後會是package:base，但其實最上層會是 Empty environment。在房間裡找東西？如果今天妳/你人在一個房間裡找東西妳/你會怎麼找？一定會先在房間裡搜尋一遍，如果怎麼都找不到，就會去客廳找，再找不到就到這棟建築物找……一直往外找對吧？所以同樣的，如果今天我們想要找個變數 x，結果 R 發現找不到，那它就會往 parent 環境（search()的順序）找，再找不到就會再往上找，如果一直找到最上層還是沒有，就會跳出像這樣的錯誤。x# Error: object &#39;x&#39; not found找的方式就像是這個圖，sourceparent 是誰？我們可以用parent.env()來查看上一層環境，now.env &amp;lt;- environment()parent.env &amp;lt;- parent.env(now.env)grandparent.env &amp;lt;- parent.env(parent.env)3. 可以增加環境嗎？如果仔細看剛剛search()的結果會發現，那些都是 package 呢！其實在每次使用 library()或是require() attache 一個 pacakge 後環境就會被改變，這時 Gloabal Environment 的 parent 環境就會變成這個 package。（請自行實驗）（題外話）library() v.s require()這兩者到底有什麼差別呢？基本上兩個的差別只有在於找不到這個 package 時，library() 會產生 Error 暫停程式，require()會 FALSE 並吐出 Warning ，然後繼續執行程式。所以可以把require()包在 if 裡，如果沒有這個 package 就安裝，程式也能繼續執行。&amp;gt; library(x)# Error in library(x) : there is no package called ‘x’require(x)# Loading required package: x# Warning message:# In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :#  there is no package called ‘x’（題外話結束）也就是說，如果我們今天使用library()或是require()就會讓環境改變。所以如果今天是要 create package 的話，千萬不要將 library()和require()包在任何 function，這樣非常危險，可能會造成 Namespace 的混亂。（如果看不懂可以先忽略這段）那如果今天需要用到這個包，但是又不想讓它加到 search path（parent 環境）裡怎麼辦？這時候請使用::。例如，今天想要呼叫 pkg1 裡頭的 fun()，pkg1::fun()::還有一個很好用的時刻，就是當今天有兩個不同的 package 擁有兩個同樣名稱的 function 時，先載入的 package 順序會被放在後面，所以如果直接呼叫 funciton ，一定會用到後載入的 package 的 function。如果現在是 pkg1 和 pkg2 都有 fun()，那我們可以這樣用，# 呼叫 pkg1 的 funpkg1::fun()# 呼叫 pkg2 的 funpkg2::fun()這樣就絕對不會出錯了。不過記得，要使用::必須要有 install 這個 package 才能使用。Attaching v.s Loadinglibrary() 和 require() 這兩個 function 的動作都是 Attaching，也就是會將這 package 加到 parent 環境 (search path)。但 ::則是 Loading，也就是說，這個 pacakge 在 loading 後可以在記憶體（memory）中被找到，但不會被加到 parent 環境 (search path) 中。source下次介紹  new.env()和 function 中的環境  &amp;lt;- 和 «- 的差別Reference:Advance R - EnvironmentsR package - NamespaceBuild a R package for yourselfMaking Your First R Package",
      "url": " /r/2018/10/20/R-Environment/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-10-19-r-variable-types": {
      "title": "[R]variable types",
      "content"	 : "We know there are several common types in R, such as, vector, list, matrix, and data.frame.Here I’m going to see these 4 types more details.  What are the differences between vector, list, matrix, and data.frame?  What are the outputs of is.atomic() and is.vector()?  What are the outputs of typeof()?1. What are the differences between vector, list, matrix, and data.frame?We can seperate these four types to two groups from different aspects.(a) Elements type aspect  Homogeneous data: vector, matrix  Heterogeneous data: list, data.frameWhich means all elements in vector and matrix have to be the same type (integer, double, or character ect.).But elements in list and data.frame can be different types.For example:Vector has same type of elements# vectorv &amp;lt;- 1:4#  v# [1] 1 2 3 4v_ch &amp;lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)# v_ch# [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;What if we give a vector different type of elements?v &amp;lt;- c(1, &quot;2&quot;)# v#[1] &quot;1&quot; &quot;2&quot;As you can see, R forces 1 to be character.But what is the priority? Why not “2” become numeric?Because the hierarchy for coercion is:  logical &amp;lt; integer &amp;lt; numeric &amp;lt; characterSo this is why numeric would be force to character.reference(b) Dimension aspect  1 Dimension: vector, list  2 Dimensions: matrix, data.frame2. What are the outputs of is.atomic() and is.vector()?Let’s see the outputs of these four types.v &amp;lt;- 1:4 # vectorl &amp;lt;- list(1:4) # listmat &amp;lt;- matrix(1:2, ncol = 2) # matrixdf &amp;lt;- data.frame(a = 1, b = 2) # data.frame(a) is.atomic()# &amp;gt; is.atomic(v)# [1] TRUE# &amp;gt; is.atomic(l)# [1] FALSE# &amp;gt; is.atomic(mat)# [1] TRUE# &amp;gt; is.atomic(df)# [1] FALSEAs you can see the results, is.atomic() gives boolean values.And the output is to see if the object is Homogeneous data or Hetergeneous data.Hence, vector and matrix get TRUE, list and data.frame get FALSE.(b) is.vector()# is.vector(v)# [1] TRUE# is.vector(l)# [1] TRUE# is.vector(mat)# [1] FALSE# is.vector(df)# [1] FALSEIn contrast with is.atomic(), is.vector() checks from Dimension aspect.3. What are the outputs of typeof()# vectorv &amp;lt;- 1:4  # all elements are numericv_ch &amp;lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)  # all elements are characters# listl &amp;lt;- list(1:4)  # all elements are numericl_ch &amp;lt;- list(a = &quot;a&quot;, b = &quot;b&quot;) # all elements are characters# matrixmat &amp;lt;- matrix(1:2, ncol = 2)  # all elements are numericmat_ch &amp;lt;- matrix(c(&quot;a&quot;, &quot;b&quot;), ncol = 2)  # all elements are characters# data.framedf &amp;lt;- data.frame(a = 1, b = 2)Let’s see the results,# ---vector-------------# &amp;gt; typeof(v)# [1] &quot;integer&quot;# &amp;gt; typeof(v_ch)# [1] &quot;character&quot;# ---list-------------# &amp;gt; typeof(l)# [1] &quot;list&quot;# &amp;gt; typeof(l_ch)# [1] &quot;list&quot;# ---matrix-------------# &amp;gt; typeof(mat)# [1] &quot;integer&quot;# &amp;gt; typeof(mat_ch)# [1] &quot;character&quot;# ---data.frame-------------# &amp;gt; typeof(df)# [1] &quot;list&quot;From the result of ouputs, we can see it checks if the object is Homogeneous data or not.If it is Homogeneous data then typeof() will show the type of elements.But if the object is Hetergeneous data, it will give only list as output result.More detail about Data Structure can be found hereReference:R深入|数据类型",
      "url": " /r/2018/10/19/R-variable-types/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-10-04-r-rstudtio-e7-b7-a8-e7-a2-bc-e5-95-8f-e9-a1-8c": {
      "title": "[R]RStudtio編碼問題",
      "content"	 : "解決編碼問題可以說最惱人的事了……在使用中文或是其他歐語系語言時經常碰到編碼問題，這篇我根據我自己的一些經驗整理了一些在使用 RStudio 時解決編碼問題的辦法。根據我的經驗，我覺得編碼問題可以分成三種，  R 程式碼編碼問題  檔案編碼問題  系統編碼問題1. R 程式碼編碼問題當你打開一份 R Script 時，發現 script 中的中文都是亂碼時，這時應該是這份 script 檔案的編碼與你電腦的 RScript 預設的不同。這時選擇 File -&amp;gt; Reopen with Encoding… 更改編碼(UTF-8、BIG5、ASCII試試)，問題應該就可以解決了。或是可以直接更改預設的讀檔編碼，到 Tools -&amp;gt; Global Options… -&amp;gt; (左邊選單) Code -&amp;gt; Saving 更改 Default text encoding。2. 檔案編碼問題當你讀進一份檔案，可能碰到以下幾種狀況a. 讀檔時出現編碼錯誤解決方法： (1)讀檔時設定 fileEncoding：讀檔時提供檔案本身編碼資訊，參考(2)更改檔案編碼：先更改檔案本身的編碼，再使用 RStudio 讀取檔案。   如果是 Windows，我個人推薦直接使用記事本更改最方便。另存新檔直接存成需要的編碼。(3)更改預設讀檔編碼：如第一個提到的 R 程式碼編碼問題的解決方案，直接更改預設的編碼，設定成 UTF-8 應該是最好的。b. 順利讀進檔案，但無法正確顯示讀檔時，使用 encoding 參數來決定要顯示什麼語言read.csv(&quot;filename.csv&quot;, encoding = &quot;latin1&quot;)3. 系統編碼問題順利讀進檔案，已更改輸入時的編碼，但顯示仍舊錯誤。這問題是在讀一份含有瑞典文的檔案時碰到的，已經更改過檔案的編碼，但開啟後仍無法正確顯示瑞典文。可以檢查一下系統本身的編碼是不是 UTF-8sessionInfo() # 裡的 local# 或是Sys.getlocale()# MAC 會長得大概像這樣# &quot;en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8&quot;如果不是，更改系統的語系，以下更改為 UTF-8# for windowsSys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;UTF-8&quot;)# for macSys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;en_US.UTF-8&quot;)另外，要查看 vector 的編碼可以使用# x is a vectorEncoding(x)我個人認為，解決編碼問題最重要的就是要先知道編碼出錯的問題在哪。是檔案本身編碼問題，還是系統的問題，那是要修改檔案還是要修改系統？",
      "url": " /r/2018/10/04/R-RStudtio%E7%B7%A8%E7%A2%BC%E5%95%8F%E9%A1%8C/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "algorithm-2018-09-28-algorithm-hamiltonian-path-and-travelling-salesman-problem-tsp": {
      "title": "[Algorithm]Hamiltonian path and Travelling Salesman Problem(TSP)",
      "content"	 : "以下簡單地整理網路上查到的 Hamiltonian path 與 Travelling Salesman Problem 介紹。Hamiltonian pathWhat is Hamiltonian path?Hamiltonian path is a path that visit every node only once. It can be an undirected or directed graph. Also itHamiltonian cycleIf a Hamiltonian path is a cycle then we call it A Hamiltonian cycle (or Hamiltonian circuit).Hamiltonian path problemDetermining whether such paths and cycles exist in graphs is the Hamiltonian path problem, which is NP-completeTravelling Salesman ProblemWhat is Travelling Salesman Problem(TSP)?There is a man traveling. He departures from a city and he wants to visit every cities(nods) with the shortest distance. In the end, he will go back to the origin city, and he can only stop in each city once.Which means, TSP is looking for the shortest distance of Hamiltonian cycle.reference:演算法筆記Wikipedia - TSPWikipedia - Hamiltonian path",
      "url": " /algorithm/2018/09/28/Algorithm-Hamiltonian-path-and-Travelling-Salesman-Problem(TSP)/",
      "author": "Shihs",
      "categories": "Algorithm"
    }
    ,
  

    "r-2018-09-27-r-scale-e8-88-87-dist-function": {
      "title": "[R]scale 與 dist function",
      "content"	 : "這篇文章會介紹 R 中的 scale 與 dist 兩個 function。在做資料分析前會需要先標準化scalescale 的主要作用在標準化數據，共有三個 arguments，  x: 必須要是 matrix，以「行」為每組數據計算  center: TRUE or FALSE。中心化，TRUE 會減去數據的平均值  scale: TRUE or FALSE。 TRUE 會將數據中的每個值除以數據的標準差預設 center 和 scale 都是 TRUE，也就是算出來的值是 z-score。  (z = frac{x - mu}{sigma}, sigma neq 0)其中：(x)：數據(mu)：平均值(sigma)：標準差x &amp;lt;- matrix(1:10, nrow = 5)scale(x)distdist 是在算數據間的距離，主要的 arguments有  x: 可以是 matrix, data.frame ，但必須要是 numeric。  methods: 共有六種計算距離的方法，”euclidean”, “maximum”, “manhattan”, “canberra”, “binary” 和 “minkowski”，預設是使用 euclidean 距離。以「列」為數據，兩兩計算，x &amp;lt;- matrix(1:10, nrow = 5)dist(x)",
      "url": " /r/2018/09/27/R-scale-%E8%88%87-dist-function/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-09-14-r-e5-a6-82-e4-bd-95-e5-9c-a8r-package-e5-8a-a0-e4-b8-8acode-coverage-codecov": {
      "title": "[R]如何在R Package加上code coverage (codecov)?",
      "content"	 : "code coverage(代碼覆蓋率)?這篇是根據這篇的步驟操作。如果要找 package 內容物該有的東西可以參考我完成的一個 R package。以下會將步驟一一列下。1. 完成 R package 與建立 test 測試建立 R package 可以參考大神的書，test 則可以參考這本書的 testing 章節。基本上使用，devtools::use_testthat()就會自己建立一個 tests 資料夾，再把要測試的程式碼加進下一層的 testthat 資料夾內。最後進行測試，devtools::test()2. 建立所有 code coverage 需要的檔案與內容先跑一下程式碼，devtools::use_coverage()跑完後會出現以下的步驟提示，* Creating `codecov.yml` from template.* Adding `codecov.yml` to `.Rbuildignore`.* Add to `README.md`: [![Coverage Status](https://img.shields.io/codecov/c/github/shihs/LiUAdRLab3/master.svg)](https://codecov.io/github/shihs/LiUAdRLab3?branch=master)* Add to `.travis.yml`:after_success:  - Rscript -e &#39;covr::codecov()&#39;基本上就一步一步照著做就對了，前面兩件事程式已經幫你處理好了，從第三步開始就行。3. 將 Github 與 codecov 連結使用 Github 帳號登入 codecov.io 。連結你要使用 codecov 的 reposity，會出現像這樣的畫面得到一組 token，將 token 複製，在 R 中跑以下程式碼，install.packages(&quot;covr&quot;)library(covr)codecov(token = &quot;YOUR_TOKEN_GOES_HERE&quot;)大功告成！這時候會看到你剛剛貼上的 coverage 圖案出現 code coverage 的結果。如果想要先在 R studio 上看測試結果可以使用，library (covr)report()viewer 視窗就會顯示測試結果了。",
      "url": " /r/2018/09/14/R-%E5%A6%82%E4%BD%95%E5%9C%A8R-Package%E5%8A%A0%E4%B8%8Acode-coverage-(codecov)/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-git-2018-09-08-r-git-e5-a6-82-e4-bd-95-e9-80-a3-e6-8e-a5rstudio-e8-88-87githu": {
      "title": "[R][Git]如何在 Rstudio 上連接 R project 與 Github",
      "content"	 : "本篇介紹如何將 Rstudio 中的 R project 與 Github 連結，讓每次專案在進行中都可以簡單快速的 commit 與 push。在進入主題前，請先安裝好 R、Rstudio 和 Git ，並且申請好 Github 帳號。前置作業設置 SSH RSA key1.複製 public keyTool &amp;gt; Global Options &amp;gt; Git/SVN &amp;gt; Create RSA Key &amp;gt; View public key 點開 View public key 後，複製裡頭所有的東西。2.將 public key 貼到 github開始建立 connection建立專案請先建立一個專案，這裡就不多加解釋了。在本機建立 repositoryBuild &amp;gt; Configure public Tools &amp;gt; Git/SVN將 Version control system 由 None 改為 Git這時候就會發現 Rstudio 的視窗長得不太一樣了。下方視窗應該會有一些還未 commit 的檔案，但因為我都已經 commit 了，所以沒有內容。且這時候 pull 和 push 鍵應該還無法操作。Github 同步終於來到最後一哩路。到 Github 上創建一個新的 repository，且名稱要和 project 相同，只要單純創建 repository 就好，什麼檔案都不要。最後，打開 Rstudio 工具列的， Tools &amp;gt; Shell然後在 Shell 裡輸入，git remote add origin https://github.com/你的github帳號/你的專案名稱.gitgit push -u origin master完成後就會發現專案已經和 Github 連結了！專案的檔案都出現在 Github 上了。這時候 pull 和 push 鍵也已經可以操作了。未來只要更新專案內容，就可以直接在 Rstudio 上 commit 和 push 就好了！補充移除 project 與該 repository 的 connection rm -rf .git參考：  Hadley Wickham 的 R Package Git 章節",
      "url": " /r/git/2018/09/08/R-Git-%E5%A6%82%E4%BD%95%E9%80%A3%E6%8E%A5Rstudio%E8%88%87githu/",
      "author": "Shihs",
      "categories": "R, Git"
    }
    ,
  

    "e7-b5-b1-e8-a8-88-2018-09-04-e7-b5-b1-e8-a8-88-e4-bb-80-e9-ba-bc-e6-98-afcdf": {
      "title": "[統計]什麼是 CDF (Cumulative Distribution Function)?",
      "content"	 : "在進入連續型隨機變數（Continuous Random Variable）前先插播介紹何謂 CDF。CDF (Cumulative Distribution Function)定義 Definition  The cumulative distribution function (CDF) of random variable (X) is defined asSource  Mathematical Statistics with Applications 這本書將 CDF 稱為 distribution function，wikipedia 則翻譯為累積分布函數。以下再分 1.離散型函數 與 2.連續型函數 來看，離散型隨機變數的 CDF以擲兩枚硬幣為例，出現 head 為 1，tail 為 0，其隨機變數 (X) 的 PMF 函數為PMF 函數圖為，則它的 CDF 累積分佈函數為CDF 函數圖為，可以發現，離散型的 CDF (F_X(x)) 為不連續的函數圖。關於離散型的 CDF 這影片有更詳細的說明。連續型隨機變數的 CDF那如果今天有個隨機變數 (X)，它的 CDF (F(X)) 為連續函數呢？定義 Definition  A random variable (X) with CDF (F(X)) is said to be continuous if (F(X)) is a continuous function for all (X in {Bbb R} ). Source參考：  Introduce To Proability, Statistics and Random Process",
      "url": " /%E7%B5%B1%E8%A8%88/2018/09/04/%E7%B5%B1%E8%A8%88-%E4%BB%80%E9%BA%BC%E6%98%AFCDF/",
      "author": "Shihs",
      "categories": "統計"
    }
    ,
  

    "e7-b5-b1-e8-a8-88-2018-09-04-e7-b5-b1-e8-a8-88-e9-9b-a2-e6-95-a3-e5-9e-8b-discrete-e9-9a-a8-e6-a9-9f-e8-ae-8a-e6-95-b8-e8-88-87-e5-85-b6-e6-a9-9f-e7-8e-87-e5-88-86-e4-bd-88-3": {
      "title": "[統計]離散型(Discrete)隨機變數與其機率分佈(3)",
      "content"	 : "這一系列我是以 Wackerley, Mendenhall and Scheaffer 的 Mathematical Statistics with Applications, 7th edition 這本書為主，有些名詞與定理解釋會再參考其他書籍與網路作為輔助（下方有參考連結）。這一篇要介紹常見的離散型分佈（Discrete Distribution），這篇主要是參考  Source伯努利分佈 Bernoulli Distribution定義 Definition  A random variable (X) is said to be a bernoulli random variable with peremeter (p), shown as (X sim Bernoulli(p)), if its PMF is given by  where (0 &amp;lt; p &amp;lt; 1)簡單來說，一個事件只有兩種可能。生活中有非常多的例子都會是 Bernoulli Distribution，譬如，  考試有及格、不及格  丟擲一枚銅板有正面、反面  小孩子性別可能是男生、女生幾何分布 Geometric Distribution定義 Definition  A random variable (X) is said to be a geometric random variable with peremeter (p), shown as (X sim Geometric(p)), if its PMF is given by  where (0 &amp;lt; p &amp;lt; 1)Geometric Distribution 的例子：擲一枚銅板，且此銅板擲到 Head 的機率為 (p)。今天擲這枚到出現第一個 Head 為止，則其機率分佈為 Geometric Distribution。另外，每一次擲這枚銅板都會是獨立的 Bernoulli 試驗。所以，Geometric Distribution 就是很多次的 Bernoulli 試驗直到成功為止。以 (p = 0.3) 為例，其 Geometric Distribution 的 PMF 會是這樣，二項分布 Binomial Distribution定義 Definition  A random variable (X) is said to be a binomial random variable with peremeter (n) and (p), shown as (X sim Binomial(n, p)), if its PMF is given by  where (0 &amp;lt; p &amp;lt; 1)Binomial Distribution 也是很多次獨立 Bernoulli 試驗的結果，但和 Geometric Distribution 不一樣的是，Binomial Distribution 會執行 (n) 次的 Bernoulli 試驗，且成功了 (k) 次。所以它的 PMF 會有 ，表示執行了(n) 次，其中有 (k) 次成功，且這 (k) 次並沒有限定在哪個位置。可以以丟擲 (n) 枚銅板來想，其中 (k) 枚硬幣為 Head，((n-k)) 為 Tail。以 (n = 10,; p = 0.3) 為例，其 PMF 圖會是，Binomial random variable as a sum of Bernoulli random variables  If (X_1,;X_2,;X_3,…,;X_n) are independent (Bernoulli(p)) random variable,  then the random variable (X) defined by (X = X_1 + X_2 + X_3 + … + X_n) has a (Binomial(n,p)) distribution.也就是，二項分布可以看成是每個獨立的伯努利分佈的和。布瓦松分布 Poisson Distribution定義 Definition  A random variable (X) is said to be a poisson random variable with peremeter (lambda), shown as (X sim Poisson(lambda)), if its range is (R_X = { 0, 1, 2, 3,… } ), and if its PMF is given byPoisson Distribution 的意義為：單位時間內，事件出現平均 (lambda) 次的機率分布。既然上面的式子為 PMF，那我們來檢驗(sum_{k in R_X}{P_k(x)} = 1)是否正確。  Note: 根據 Taylor Series(泰勒展開式) (; e^{x} = sum_{k=0}^{infty} frac{x^k}{k!})，上列式子可以寫成，Example:  The number of emails that I get in a weekday can be modeled by a Poisson distribution with an average of 0.2 emails per minute.      What is the probability that I get no emails in an interval of length 5 minutes?    What is the probability that I get more than 3 emails in an interval of length 10 minutes?  Poisson as an approximation for binomial  Let (X sim Binomial(n, p = frac{lambda}{n})), where (lambda &amp;gt; 0) is fixed. Then for any (k in {0, 1, 2,…} ), we have(X sim Poisson(lambda = 5)) 的函數圖形，參考：  Mathematical Statistics with Applications 7th Edition  Introduce To Proability, Statistics and Random Process  陳鍾誠的網站",
      "url": " /%E7%B5%B1%E8%A8%88/2018/09/04/%E7%B5%B1%E8%A8%88-%E9%9B%A2%E6%95%A3%E5%9E%8B(Discrete)%E9%9A%A8%E6%A9%9F%E8%AE%8A%E6%95%B8%E8%88%87%E5%85%B6%E6%A9%9F%E7%8E%87%E5%88%86%E4%BD%88(3)/",
      "author": "Shihs",
      "categories": "統計"
    }
    ,
  

    "e7-b5-b1-e8-a8-88-2018-09-02-e7-b5-b1-e8-a8-88-e9-9b-a2-e6-95-a3-e5-9e-8b-discrete-e9-9a-a8-e6-a9-9f-e8-ae-8a-e6-95-b8-e8-88-87-e5-85-b6-e6-a9-9f-e7-8e-87-e5-88-86-e4-bd-88-2": {
      "title": "[統計]離散型(Discrete)隨機變數與其機率分佈(2)",
      "content"	 : "這一系列我是以 Wackerley, Mendenhall and Scheaffer 的 Mathematical Statistics with Applications, 7th edition 這本書為主，有些名詞與定理解釋會再參考其他書籍與網路作為輔助（下方有參考連結）。這篇關於期望值的介紹在書中的 3.3，但這篇內容有很大部分也來自 Source期望值 Expectation定義 Definition  Let (X) be a discrete random variable with range (R_X = { x_1, x_2, x_3,… } )(finite or countably infinite). The expectation of (X) is defined as且期望值 (E(X)) 會等於平均數 (mu)說明：  There is a discrete random variable with range (R_X = { x_1, x_2, x_3,… } ). Suppose that we repeat this experiment a very large number of times (N), and that the trials are independent. Let (N_1) be the number of times we observe (x_1), (N_2) be the number of times we observe (x_2, ….), (N_k) be the number of times we observe (x_k).  從以上式子我們可以得到 (N_k = NP_X(x_k))以上就是 (E(X) = mu) 的說明。另外，可能會看到一些不同的寫法表示期望值這部分內容主要來源為 SourceLaw of the unconscious statistician (LOTUS)THEOREM 3.2  Let (X) be a discrete random variable with probability function (P(x)) and (g(X)) be a real-valued function of (Y). Then the expected value of (g(X)) is given byExample: Source  Let (X) be a discrete random variable with range (R_X = { 0, frac{pi}{4}, frac{pi}{2}, frac{3pi}{4}, pi… } ), such that (P_X(0)=P_X(frac{pi}{4})=P_X(frac{pi}{2})=P_X(frac{3pi}{4})=P_X(pi)=frac{1}{5}).  Find (E[sin(X)]).Solution:  根據 LOTUS，變異數 Variance定義 Definition  If (X) is a random variable with mean (E[X] = mu), the variance of (X) is defined as  且根據 LOTUS，這個式子可以再寫成期望值的運算THEOREM 3.3  Let X be a discrete random variable with probability function (p(x)) and (c) be a constant. ThenTHEOREM 3.4  Let X be a discrete random variable with probability function (p(x)) and (g(X)) be a function of X, and c be as constant. ThenTHEOREM 3.5  Let X be a discrete random variable with probability function (p(x)) and (g_1(X), g_2(X), …, g_k(X)) be (k) functions of (X). Then根據以上定理，可以再產生THEOREM 3.6  Let X be a discrete random variable with probability function (p(x)) and mean (E(X) = mu). Then證明：  參考：  Mathematical Statistics with Applications 7th Edition  Introduce To Proability, Statistics and Random Process  陳鍾誠的網站",
      "url": " /%E7%B5%B1%E8%A8%88/2018/09/02/%E7%B5%B1%E8%A8%88-%E9%9B%A2%E6%95%A3%E5%9E%8B(Discrete)%E9%9A%A8%E6%A9%9F%E8%AE%8A%E6%95%B8%E8%88%87%E5%85%B6%E6%A9%9F%E7%8E%87%E5%88%86%E4%BD%88(2)/",
      "author": "Shihs",
      "categories": "統計"
    }
    ,
  

    "e7-b5-b1-e8-a8-88-2018-09-01-e7-b5-b1-e8-a8-88-e9-9b-a2-e6-95-a3-e5-9e-8b-discrete-e9-9a-a8-e6-a9-9f-e8-ae-8a-e6-95-b8-e8-88-87-e5-85-b6-e6-a9-9f-e7-8e-87-e5-88-86-e4-bd-88-1": {
      "title": "[統計]離散型(Discrete)隨機變數與其機率分佈(1)",
      "content"	 : "這一系列我是以 Wackerley, Mendenhall and Scheaffer 的 Mathematical Statistics with Applications, 7th edition 這本書為主，有些名詞與定理解釋會再參考其他書籍與網路作為輔助（下方有參考連結）。這篇內容為書中的 3.1 與 3.2。在開始前，何謂「隨機變數」？隨機變數 Random Variable定義 Definition  隨機變數 (X) 是一個以樣本空間 (S) 為定義域（Domain）的實數值函數。 Source  A random variable (X) is a funcion from sample space to real number. Source  ( X: S  to {Bbb R},  S  is  sample  space  ) ( i.e.  forall  s in S,  X(s) in {Bbb R}  )Example:  擲兩枚硬幣，其樣本空間為 ( R = {HH, HT, TH, TT}  )，共有 (2^2) 種可能。 若將 H 定義為 1，T 定義為 0，則其隨機變數 (X) 的值為 ( {0, 1, 2})而隨機變數又分為 1. 離散型 與 2. 連續型，這一章節我們只會討論離散型。離散型隨機變數 Discrete Random Variable定義 Definition  A random variable (Y) is said to be discrete if it can assume only a finite or countably infinite number of distinct values. (DEFINITION 3.1)  (X) is a discrete random variable, if its range is countable. Source根據定義，離散型隨機變數（Discrete Random Variable）必須為可數（countable）。所以像是擲銅板或是擲骰子就會是離散型隨機變數。以擲一顆骰子一次為例，其可能值為 ({1, 2, 3, 4, 5, 6}), 我們用 (X)來表示其隨機變數，但因為隨機變數為 function，所以我們可以用 (R_X)來表示它的範圍，  ( Range(X) = R_X = {1, 2, 3, 4, 5, 6}  ) 機率質量函數 Probability Mass Function (PMF)定義 Definition  Let (X) be a discrete random variable with range (R_X = { x_1, x_2, x_3,… } ) (finite or countably infinite). The function  is called the probability mass function (PMF) of (X). Source機率質量函數 Probability Mass Function (PMF) 可以用來表達樣本空間中某事件的機率。譬如說，擲一顆公平的骰子，骰子點數為 1 的機率我們可以這樣表示，  ( P(X = 1) = 1/6  )另外，( P_X(x) )還有兩個很重要的性質 Source，  ( 0 leqslant P_X(x) leqslant 1 , forall x )  ( sum_{substack{x in R_X}}P_X(x) = 1 )簡單來說就是，  任何事件發生的機率都只會介於 0 和 1 之間  所有事件機率總和等於 1離散型 PMF 圖擲兩枚硬幣，出現 head 為 1，tail 為 0 ，其 PMF 函數為  函數圖為，參考：  Mathematical Statistics with Applications 7th Edition  Introduce To Proability, Statistics and Random Process  陳鍾誠的網站",
      "url": " /%E7%B5%B1%E8%A8%88/2018/09/01/%E7%B5%B1%E8%A8%88-%E9%9B%A2%E6%95%A3%E5%9E%8B(Discrete)%E9%9A%A8%E6%A9%9F%E8%AE%8A%E6%95%B8%E8%88%87%E5%85%B6%E6%A9%9F%E7%8E%87%E5%88%86%E4%BD%88(1)/",
      "author": "Shihs",
      "categories": "統計"
    }
    ,
  

    "r-2018-08-27-r-e5-a6-82-e4-bd-95-e4-bf-ae-e7-95-8c-e9-9d-a2-e8-aa-9e-e8-a8-80-e7-9a-84-e8-a8-ad-e5-ae-9a": {
      "title": "[R]如何更改R介面語言的設定",
      "content"	 : "當安裝完 R 後，原本設定的語言為中文，但現在想要將中文改為英文該如何操作？以下為 mac 的 ios 系統解法，system(&quot;defaults write org.R-project.R force.LANG en_US.UTF-8&quot;)然後關閉 R 再重新打開就會改為英文介面囉！",
      "url": " /r/2018/08/27/R-%E5%A6%82%E4%BD%95%E4%BF%AE%E7%95%8C%E9%9D%A2%E8%AA%9E%E8%A8%80%E7%9A%84%E8%A8%AD%E5%AE%9A/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "python-2018-07-13-python-e5-9f-b7-e8-a1-8cpyinstaller-e7-94-a2-e7-94-9f-e7-9a-84exe-e6-aa-94-e5-87-ba-e7-8f-beno-module-e9-8c-af-e8-aa-a4-e8-a8-8a-e6-81-af": {
      "title": "[Python]執行pyinstaller產生的執行檔出現No module錯誤訊息",
      "content"	 : "前面介紹過使用 pyinstaller 將 .py 打包成執行檔，方便使用者執行程式。我在 mac 終端機輸入 pyinstaller -F pyscript.py 後， 執行在 dist 資料夾底下的檔案，卻出現`no module named ‘somepackagename’`的錯誤訊息。這表示，在打包這支程式時，並未把需要的套件打包進去？ 但是我使用 .py 執行時並沒有這樣的問題啊？ 表示我的電腦確實是有安裝該套件才是。原來是因為在打包時 pyinstaller 並不知道這個套件的路徑， 所以只要加上套件的路徑位置，讓 pyinstaller 執行打包時可以找得到就好。 假如缺少的套件在 /usr/local/lib/python2.7/site-packages， 只要將原本的 pyinstaller -F pyscript.py 改成 pyinstaller -F -p /usr/local/lib/python2.7/site-packages pyscript.py 就好了。 可以用， import sysprint sys.path查看系統路徑，就可以知道套件可能的位置。",
      "url": " /python/2018/07/13/Python-%E5%9F%B7%E8%A1%8Cpyinstaller%E7%94%A2%E7%94%9F%E7%9A%84exe%E6%AA%94%E5%87%BA%E7%8F%BENo-module%E9%8C%AF%E8%AA%A4%E8%A8%8A%E6%81%AF/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-2018-07-05-python-e5-bd-88-e5-87-ba-e8-a6-96-e7-aa-97alert-box": {
      "title": "[Python]彈出視窗 alert box",
      "content"	 : "介紹如何使用 python 寫彈跳視窗，其實網路上可以找到蠻多方法的，我這邊就簡單介紹幾個。以下會分為 mac 和 windows 兩個系統來討論。Mac1. easygui 套件# 記得先安裝 easygui 套件from easygui import msgboxmsgbox(&#39;Stuff&#39;)這個套件基本上蠻簡單的，只要使用msgbox()就好，如果只是要在跑程式的時候使用沒有太大問題，更多 easygui 套件 的介紹但如果要把程式碼打包時（pyinstaller套件） 這個方法就會失效，會出現錯誤訊息ImportError: No module named easygui[3310] Failed to execute script alterwindow所以如果要讓程式碼打包後可以出現彈跳視窗可以使用內建的 system。2. os.system()import osos.system(&quot;osascript -e &#39;Tell application &quot;System Events&quot; to display dialog &quot;&quot;+&quot;Some Funky Message&quot;+&quot;&quot;&#39;&quot;)這方法其實就是使用 python 執行系統命令。也就是，其實把 os.system() 括號裡的東西osascript -e &#39;Tell application &quot;System Events&quot; to display dialog &quot;Some Funky Message&quot;&#39;打在 terminal 裡會執行的東西。將以上命令打在 terminal 會發現出現一個彈跳視窗，內容是 Some Funcky Message。所以在 python 裡面同樣執行會產生同樣的結果。而這個方法將程式打包後可以正確執行。Windows1. easygui 套件# 記得先安裝 easygui 套件from easygui import msgboxmsgbox(&#39;Stuff&#39;)基本上和 mac 一樣，將程式碼打包後也無法正常執行。2. ctypes 套件# 不需另外安裝import ctypesctypes.windll.user32.MessageBoxA(0, &quot;Your text&quot;, &quot;Your title&quot;, 1)# 或著你可以定義一個 functiondef Mbox(title, text, style):    return ctypes.windll.user32.MessageBoxA(0, text, title, style)Mbox(&#39;Your title&#39;, &#39;Your text&#39;, 1)# 如果是要輸出中文，記得重新 encodectypes.windll.user32.MessageBoxA(0, &quot;內容&quot;.decode(&quot;utf-8&quot;).encode(&quot;big5&quot;), &quot;標題&quot;.decode(&quot;utf-8&quot;).encode(&quot;big5&quot;), 1)這個方法也可以打包後執行。另外，會看到有些地方使用ctypes.windll.user32.MessageBoxW()而不是ctypes.windll.user32.MessageBoxA()但執行後會發現，ctypes.windll.user32.MessageBoxW()這個方法會出現亂碼。這兩個的差別在MessageBoxW要使用 unicode 編碼，而MessageBoxA是 ascii 編碼。有人回答這個問題。這邊 mac 和 windows 各介紹了兩種方法，其實還有很多方法啦，只要能符合需求的都是好方法！",
      "url": " /python/2018/07/05/Python-%E5%BD%88%E5%87%BA%E8%A6%96%E7%AA%97alert-box/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2018-07-03-python-e8-ae-80-e5-8f-96-e9-a9-97-e8-ad-89-e7-a2-bc": {
      "title": "[Python][爬蟲]使用 pytesseract 與 Image 套件解析驗證碼",
      "content"	 : "當爬網站碰到需要讀取驗證碼的網站時可以使用pytesseract 與 Image 套件來讀取圖片上的數字與英文。基本流程：  找到圖片的來源網址  下載圖片  調整圖片、解析圖片，獲得圖片上的數字與英文  帶入參數以經濟部公司及分公司基本資料查詢系統為例，從檢查元素中可以發現，在載入這個頁面時會有一個產生圖片的網址同時被載入。而這個頁面正是送出 requests 時會產生的驗證碼圖片。所以只要能下載這個圖片並解析它，就能將解析出來的結果帶進 post 的參數裡，就能完成一個 post requests 。解析驗證碼完整程式碼s = requests.Session()# 1. 找到圖片的來源網址img_url = &quot;https://serv.gcis.nat.gov.tw/pub/kaptcha.jpg&quot;res = s.get(img_url, stream = True, verify = True, timeout = 30)# 2. 下載圖片with open(&#39;pic.jpg&#39;,&#39;wb&#39;) as f:    f.write(res.content)# 3. 調整圖片、解析圖片，獲得圖片上的數字與英文image = Image.open(&#39;pic.jpg&#39;)# adjust pitcure size, it would read more correctlyimage.resize((150, 50),Image.ANTIALIAS).save(&quot;pic.jpg&quot;)image = Image.open(&quot;pic.jpg&quot;)captcha = pytesseract.image_to_string(image).replace(&quot; &quot;, &quot;&quot;).replace(&quot;-&quot;, &quot;&quot;).replace(&quot;$&quot;, &quot;&quot;)程式碼步驟解析session()這裡使是 session 是因為要記錄載入頁面的 cookies，以確保讓網站覺得和等下要送出 requests 時事同時載入的。s = requests.Session()找到圖片的來源網址與存檔img_url = &quot;https://serv.gcis.nat.gov.tw/pub/kaptcha.jpg&quot;res = s.get(img_url, stream = True, verify = True, timeout = 30)with open(&#39;pic.jpg&#39;,&#39;wb&#39;) as f:    f.write(res.content)這前面兩行很簡單，就是送出驗證碼來源網址的 requests，接著下載該圖檔，會發現這時候產生了一個 pic.jpg 的檔案。調整圖片、解析圖片，獲得圖片上的數字與英文image = Image.open(&#39;pic.jpg&#39;)print image# adjust pitcure size, it would read more correctlyimage.resize((150, 50),Image.ANTIALIAS).save(&quot;pic.jpg&quot;)image = Image.open(&quot;pic.jpg&quot;)print imagecaptcha = pytesseract.image_to_string(image).replace(&quot; &quot;, &quot;&quot;).replace(&quot;-&quot;, &quot;&quot;).replace(&quot;$&quot;, &quot;&quot;)print captcha有時候將下載下來的圖片直接丟進 pytesseract.image_to_string() 解析結果正確率會很低，但如果調整一下圖片的 size 反而會有較正確的結果。所以前面我先使用 resize 調整圖片的大小，並重新存檔。最後再使用 pytesseract.image_to_string() 解析圖片。可以根據 pytesseract.image_to_string() 解析出來的結果做些調整以提高正確率。因為發現這個圖片解析出來後常會有些多餘的符號，所以使用 replace 修正。圖片的 mode 必須要為 RGB另外，可以使用print image看 open() 後的圖片的資訊。像是被調整過後的圖片變成&amp;lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=150x50 at 0x109355D90&amp;gt;圖片的尺寸(size)變成 150x50，mode 為 RGB。這點很重要，因為如果 mode 不是 RGB 就會無法 使用 pytesseract.image_to_string()解析圖片。會碰到錯誤訊息/usr/local/lib/python2.7/site-packages/PIL/Image.py:971: UserWarning: Couldn&#39;t allocate palette entry for transparency  &quot;for transparency&quot;)---省略--TypeError: int() argument must be a string or a number, not &#39;tuple&#39;譬如我曾經抓到一個圖片，print 出來的圖片資訊是&amp;lt;PIL.GifImagePlugin.GifImageFile image mode=P size=60x20 at 0x10F1DCD10&amp;gt;這時候必須要把 mode 由 P 轉為 RGB，只要在 open() 後加上一行，image = Image.open(&#39;pic.gif&#39;)image = image.convert(&#39;RGB&#39;)# print image這是後print image會發現 mode 已被改為 RGB，且可以正確執行了。基本上，根據上面的概念就可以破解驗證碼，只要再根據個別網站的狀況做調整就好。經濟部公司及分公司基本資料查詢系統爬蟲網站完整程式碼。或是，另外比較複雜的驗證碼可以參考我的github。",
      "url": " /python/%E7%88%AC%E8%9F%B2/2018/07/03/Python-%E8%AE%80%E5%8F%96%E9%A9%97%E8%AD%89%E7%A2%BC/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-sql-2018-06-30-python-sql-pytho-e6-8e-a5-sqlite": {
      "title": "[Python][SQL]Python 連接 SQLite",
      "content"	 : "這篇是 Python 連接 SQL 的一些基本語法，內容來自 Udacity 上 Intro to Relational Databases 的免費課程與我自己整理的資訊。import sqlite3conn = sqlite3.connect(&quot;Cookies&quot;) # 連接 SQLite 資料庫cursor = conn.cursor() # 獲得連接的游標# 要下的 SQL 指令cursor.execute(    &quot;select host_key from cookies limit 10;&quot;)results = cursor.fetchall()print resutls # 結果為 turpleconn.close() # 每次都要記得 close 連線",
      "url": " /python/sql/2018/06/30/Python-SQL-Pytho%E6%8E%A5-SQLite/",
      "author": "Shihs",
      "categories": "Python, SQL"
    }
    ,
  

    "sql-psql-2018-06-29-sql-psql-e5-9f-ba-e6-9c-ac-e4-bb-a4-e8-88-87-2": {
      "title": "[SQL][psql]基本觀念(2)",
      "content"	 : "這篇是整理一些 psql 的基本觀念，內容來自 Udacity 上 Intro to Relational Databases 的免費課程與我自己整理的資訊。Normalized DesignWhat is Normalized Design?  Every row has the same number of columns. 每一列都必須有同樣的行數。  There is a unique key, and everything in a row says something about the key. 每個 table 會有一個 unique key，且 table 中的每一行的資訊都必須要和 unique key 有關。  Facts that don’t relate to the key belong in different tables. 與 unique key 無關的訊息要放在另一個 table。  Table shouldn’t imply relationships that don’t exist. 行之間不存在關係的資料不能產生會讓人誤會訊息。More about Normalization:William Kent’s paper A Simple Guide to Five Normal Forms in Relational Database TheoryWikipedia’s article on database normalizationUnique Key v.s. Foreign KeyWhat is Unique Key?唯一值不能重複。譬如像是，學號、身分證字號等等，只存在唯一的值，但像名字這種可能會重複的值就不能當 unique key。另外還有一個和 unique key 很像的東西，叫 primary key。它同樣必需要是唯一值不能重複，但他們的差別在於，unique key 可以有 null，但 primary key 不能有 null。譬如，在一間公司裡，公司有台灣人和外國人。公司的每位員工都有職編，但只有台灣人會有身分證字號，這時候職編可以作為 primary key 或是 unique key，但身分證字號只能是 unique key。詳細說明可以看這裡。What is Foreign Key?對照到另一個資料表的 primary key。譬如，有一份資料表是學生資料，欄位包含「學號」和「姓名」，另一份是學生的數學成績，包含「學號」、「分數」。右邊的表格對照到左邊姓名那份表格，學號在左邊的表格是 primary key，所以右邊表格中「學號」那個欄位就會是 foreign key。",
      "url": " /sql/psql/2018/06/29/SQL-psql-%E5%9F%BA%E6%9C%AC%E4%BB%A4%E8%88%87(2)/",
      "author": "Shihs",
      "categories": "SQL, psql"
    }
    ,
  

    "others-python-2018-06-28-google-map-api-geocoding-e5-9c-b0-e5-9d-80-e7-b6-93-e7-b7-af-e5-ba-a6": {
      "title": "Google Map API - Geocoding 地址經緯度",
      "content"	 : "Google Map 提供了很多 API，方便開發者根據自己的需求使用。不過大部分的 API 都需要使用 Google 帳號申請一個 API KEY 。 API KEY 申請時要填上信用卡資訊，有一年的免費使用時間，過了一年以後會自動扣款，但隨時都可以停用，而且時間快到時 Google 也會寄信通知你。這次要介紹Geocoding這個 API 。 根據說明文件上的介紹Geocoding is the process of converting addresses (like &quot;1600 Amphitheatre Parkway, Mountain View, CA&quot;) into geographic coordinates (like latitude 37.423021 and longitude -122.083739), which you can use to place markers on a map, or position the map.簡單來說，你可以根據地址找到該地址在地理上的座標（經緯度），方便應用在地圖上標記位置。根據Geocoding說明文件，這個 API 的 format 有 json 和 xml 兩種格式。來看文件上給的一個輸出 json 格式的範例，https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;amp;key=YOUR_API_KEY看起來這個 API 是需要 API KEY 。但其實，這個 API 是可以不需要 KEY 的（我不知道為什麼 XD）。而且使用 API key 反而還會被限制一天可以搜尋的數量……所以其實上面的例子只要這樣就好，https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA當然也可以搜尋中文地址，https://maps.googleapis.com/maps/api/geocode/json?address=台北市中正區重慶南路一段122號就可以獲取該地址完整的地址資訊（包括郵遞區號）與經緯度。其實只要搜尋「重慶南路一段122號」就可以找到該地址完整的資訊了。使用 python 快速爬取 API 內容這邊我寫了一個簡單的 python 程式可以快速地使用這個 API 獲得地址的經緯度。import requestsimport urllibimport jsondef get_latitude_longtitude(address):    # decode url    address = urllib.quote(address)    url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=&quot; + address        while True:        res = requests.get(url)        js = json.loads(res.text)        if js[&quot;status&quot;] != &quot;OVER_QUERY_LIMIT&quot;:            time.sleep(1)            break    result = js[&quot;results&quot;][0][&quot;geometry&quot;][&quot;location&quot;]    lat = result[&quot;lat&quot;]    lng = result[&quot;lng&quot;]    return lat, lngaddress = &quot;重慶南路一段122號&quot;lat, lng = get_latitude_longtitude()",
      "url": " /others/python/2018/06/28/Google-Map-API-Geocoding-%E5%9C%B0%E5%9D%80%E7%B6%93%E7%B7%AF%E5%BA%A6/",
      "author": "Shihs",
      "categories": "Others, Python"
    }
    ,
  

    "sql-psql-2018-06-15-psql-e5-9f-ba-e6-9c-ac-e6-8c-87-e4-bb-a4": {
      "title": "[SQL][psql]基本指令(1)",
      "content"	 : "這篇是整理一些 psql 的基本指令，內容來自 Udacity 上 Intro to Relational Databases 的免費課程。BASIC COMMANDSConnect to psql$ psqlQuit psql$ qList all databases$ list# or$ l#  exit from query result viewer$ qList all datatables in current database# connect to the database$ connect dbname# or$ c dbname# list all tables $ dtSQL COMMANDSCreate and Drop DATABASECREATE DATABASE dbname;DROP DATABASE dbname;Create and Drop TABLE# Example: Create a table with a text column and a serial columnCREATE TABLE dtname (id serial,name text);# drop table dtnameDROP TABLE dtname;Insert valuesINSERT INTO dtname VALUES(&#39;This is a test&#39;);Show all data in a tableTABLE dtname# orSELECT * FROM dtnameSet primary key# single column primary keyCREATE TABLE dtname (id serial primary key,name text,birthday date);# multiple columns primary keyCREATE TABLE postal_places (postal_code text,country text,name text,primary key (postal_code, country));Declaring relationshipsCREATE TABLE sales (sku text references products (sku),sale_date date,count integer);",
      "url": " /sql/psql/2018/06/15/psql-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/",
      "author": "Shihs",
      "categories": "SQL, psql"
    }
    ,
  

    "python-2018-06-13-python-args-e5-92-8c-kwargs": {
      "title": "[Python]Python 中的 *args 和 *kwargs",
      "content"	 : "簡單來說，*args和**kwargs是 function 的參數，在不確定會有多少參數時使用。args 是 arguments 縮寫，kwargs 是 keyword argments 的縮寫。也就是， args 是沒有 keyword 的變數， kwargs 有 keyword。如果 *args和**kwargs 同時使用，*args必需在**kwargs之前。先簡單看以下的例子def test(*args, **kwargs):    for i in args:        print &quot;agrs=&quot; + str(i)    for j in kwargs:        print &quot;kwargs=&quot; + jtest(1, 2, 3, 4, first = &quot;a&quot;, second = &quot;b&quot;, third = &quot;c&quot;)結果agrs=1agrs=2agrs=3agrs=4kwargs=secondkwargs=thirdkwargs=firstargs 和 kwargs 不是重點，* 才是args 和 kwargs 這兩個參數名稱並不是重點，重點是前面的星號 *。所以，if you like 其實參數也可以寫成 *var 和 **vars，*args 和 **kwargs 只是一個大家使用的習慣。*args 的用法first_arg = &quot;this is first arguments&quot;def arg_test(first_arg, *args):    print &quot;first_arg=&quot; + first_arg    if args is not None:        print &quot;other *args...&quot;        for i in args:            print &quot;agrs=&quot; + str(i)    arg_test(first_arg, 1, 2, 3, 4)結果first_arg=this is first argumentsother *args...agrs=1agrs=2agrs=3agrs=4*kwargs 的用法def greet_me(**kwargs):    if kwargs is not None:        for key, value in kwargs.iteritems():            print &quot;%s == %s&quot; %(key,value) greet_me(name=&quot;yasoob&quot;)name == yasoob從以上兩個範例可以看出 args 和 kwargs 用法的差異。使用 list 和 dictionary 當參數def test_arg(arg1, arg2, arg3):    print arg1    print arg2    print arg3#===args===========args = [1, 2, 3]test_arg(*args)# resultarg1=1arg2=2arg3=3#===kwargs===========kwargs = {    &quot;arg3&quot;:1,    &quot;arg2&quot;:2,    &quot;arg1&quot;:3}test_arg(**kwargs)# resultarg1=3arg2=2arg3=1根據以上範例，可以發現*arg print 的順序就是 list 的順序，但 **kwargs 會根據 dictionary 的 key 來賦予 value。參考",
      "url": " /python/2018/06/13/Python-args-%E5%92%8C-kwargs/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "web-css-2018-06-11-web-css-e5-a6-82-e4-bd-95-e5-88-aa-e9-99-a4nav-ta-e5-ba-95-e8-89-b2-e5-85-a9-e9-82-8a-e7-9a-84-e7-a9-ba-e7-99-bd": {
      "title": "[Web][CSS]如何刪除 nav tag 底色兩邊的空白？",
      "content"	 : "&amp;lt;nav&amp;gt;的作用  &amp;lt;nav&amp;gt; 為 HTML 文件的區域元素 (element)，&amp;lt;nav&amp;gt;用來規劃網頁的導覽區域，通常裡頭會放網站其他網頁的連結。  &amp;lt;nav&amp;gt; 除了全域屬性外，沒有定義其他屬性 (attribute) 。參考像我的網頁上面黑色那條有 “About” 和 “Contact Me” 連結的區域就是在 &amp;lt;nav&amp;gt;裡。&amp;lt;!-- html --&amp;gt;&amp;lt;body&amp;gt;  &amp;lt;nav class=&quot;wrapper-nav&quot; id=&quot;nav&quot;&amp;gt;    &amp;lt;ul&amp;gt;      &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#about&quot;&amp;gt;About&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;          &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#contact&quot;&amp;gt;Contact Me&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;    &amp;lt;/ul&amp;gt;             &amp;lt;/nav&amp;gt;&amp;lt;/body&amp;gt;/* css */nav {  background-color: black;}如何刪除 &amp;lt;nav&amp;gt; 背景的空白 How to remove the space on both sides of navbar若使用上面的程式碼會發現 nav 底色變成黑色，但兩邊會有無法移除的空白，這時候有兩種解決方法。皆是在&amp;lt;body&amp;gt;這個 tag 上面做些調整      /* css */body{  margin-left:auto;  margin-right:auto;}             /* css */body{  width: 100%;  margin: auto;}       ",
      "url": " /web/css/2018/06/11/Web-CSS-%E5%A6%82%E4%BD%95%E5%88%AA%E9%99%A4nav-ta%E5%BA%95%E8%89%B2%E5%85%A9%E9%82%8A%E7%9A%84%E7%A9%BA%E7%99%BD/",
      "author": "Shihs",
      "categories": "Web, CSS"
    }
    ,
  

    "web-css-2018-05-24-web-css-e5-9c-a8-e4-b8-8d-e5-90-8c-e8-9e-a2-e5-b9-95-e8-a7-a3-e6-9e-90-e5-ba-a6-e4-b8-8b-e8-aa-bf-e6-95-b4css": {
      "title": "[Web][CSS]在不同螢幕解析度下調整css",
      "content"	 : "除了電腦外手機、平板都可以瀏覽網頁，這篇要介紹如何依據不同裝置的螢幕寬度來調整 CSS。參考網站解析度可以這樣區分  手機：解析度為0px~320px  平板電腦：解析度為320px~768px  桌上型電腦：大於768px在 CSS 上調整使用@media設定 Max Width/* 768px以下(包含)都適用，手機和平板會符合這個設定 */@media (max-width 768px) {.class {background: #ccc;}}設定 Min Width/* 329px以上(包含)都適用，平板和電腦會符合這個設定 */@media (min-width 320px) {.class {background: #666;}}設定 Max Width and Min Width/* 介於768px與979px間適用 */@media (min-width: 768px) and (max-width: 979px) {.class {background: #666;}}如此就可以依據螢幕的寬度來顯示適合的方式了。",
      "url": " /web/css/2018/05/24/Web-CSS-%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%9E%A2%E5%B9%95%E8%A7%A3%E6%9E%90%E5%BA%A6%E4%B8%8B%E8%AA%BF%E6%95%B4css/",
      "author": "Shihs",
      "categories": "Web, CSS"
    }
    ,
  

    "python-2018-05-24-python-e4-bd-bf-e7-94-a8pyinstaller-e5-a5-97-e4-bb-b6-e6-89-93-e5-8c-85-py-e6-aa-94": {
      "title": "[Python]使用 pyinstaller 套件打包 .py 檔",
      "content"	 : "當我們今天寫好一個 .py 檔，要給使用者執行時當然可以幫使用者在他們的電腦下載 Python 等執行程式時需要的套件，但是，很麻煩！！！ 不可能每次有一個新的使用者就要重新安裝一次 Python，還要安裝套件(更不要說有時候安裝套件會碰到一些問題)，且要執行 .py 檔對於不會使用 terminal 或是 cmd 的人來說可能會選擇放棄，這就減少了讓妳/你的程式給更多人使用的機會。而 pyinstaller 是一個可以把 .py 打包成一個 .exe 檔的工具，讓使用者只要點兩下就能執行妳/你寫好的 Python 檔案。前提pyinstaller可以在 Windows、MacOS、Linux 上使用，但是不是跨平台，所以如果今天使用者是 windows 那麼就必須要在 windows 作業系統底下產生 .exe 檔，若使用者是 macOS 那就必須要在 mac 底下打包產生執行檔。安裝Windowspip install pyinstallerMacsudo pip install pyinstaller但我這邊在安裝時出現了一大串的錯誤，其中內容包括 [Errno 1] Operation not permitted後來我參考這裡把指令改成sudo pip install pyinstaller --upgrade --ignore-installed就成功安裝了。安裝好後，可以在 cmd 或是 terminal 上輸入 pyinstaller 確認。打包 .py 檔假如現在要打包一個 test.py 檔Windowspyinstaller -F test.py完成後會產生三個檔案，  build 資料夾  dist 資料夾  test.spec 檔而我們需要的 test.exe 會單獨在 dist 資料夾裡，如果要給其他 Windows 使用者執行 test.py 這支檔案，只需要給他們 .exe 就行了。如果 test.py 這支程式是會產生一個檔案，例如 .csv 檔案，則這檔案會直接儲存在和 test.exe 同一個路徑底下。MacMac的操作基本上和 Windows 指令一樣，pyinstaller -F test.py打包完後產生出來的檔案也會一樣。但如果執行 .exe 檔會產生檔案，這時候會發現檔案沒有出現在和 .exe 同一個路徑底下。而是會在 /Users/yourusername 底下。可以試試看在 .py 檔裡增加一行print os.getcwd()會發現使用 .exe 執行的結果就會是 /Users/yourusername，所以檔案才會直接產生在這路徑底下。但我想要讓檔案直接產生在桌面，因此我的方法是加上這行os.chdir(&#39;/Users/&#39;+os.getlogin()+&#39;/Desktop&#39;)讓路徑直接換到桌面，這樣儲存檔案就會產生在桌面上了。常用參數  pyinstaller -h 查看參數  -F 打包成一個exe文件  –icon=圖標路徑關於 pyinstaller 套件，這個部落格我覺得說明蠻詳細的。",
      "url": " /python/2018/05/24/Python-%E4%BD%BF%E7%94%A8pyinstaller%E5%A5%97%E4%BB%B6%E6%89%93%E5%8C%85.py%E6%AA%94/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-2018-05-23-python-e4-b8-8b-e8-bc-89-e8-88-87-e5-ae-89-e8-a3-9dpython-e5-8f-8apip-e5-a5-97-e4-bb-b6": {
      "title": "[Python]下載與安裝 Python2.7 及 pip 套件",
      "content"	 : "安裝前可以先認識 Python。這篇文章將會介紹如何在 windows 系統中下載與安裝 python2.7 以及安裝 pip 套件。主要步驟其實就是四個：  下載Python  設定環境變數  下載get-pip.py  設定環境變數1.下載 Python2.7Python2.7.14載點根據自己電腦是32位元還是64位元選擇要下載的檔案下載下來後的檔案（我的電腦是32位元）點兩下安裝，就是一直按下一步就對了2.設定環境變數設定環境變數的目的是，在執行 Python 時讓系統可以根據環境變數底下的路徑依序去找 Python 程式，而不會不知道要如何執行 Python。設定環境變數步驟，電腦(右鍵)-&amp;gt;內容1.進階系統設定 -&amp;gt; 2.環境變數 -&amp;gt; 3.點選PATH-&amp;gt;編輯在變數最後加上安裝路徑「;C:Python27」（這是預設的安裝路徑，如果安裝過程中有更改位置，這邊要改成安裝的路徑）以上步驟完成之後在 cmd 輸入 python，就開始執行 Python 了！ 基本上到這裡已經安裝好 Python 了，那為什麼要安裝 pip 呢？Python 有很多別人寫好且非常好用的套件，當我們想要使用這些套件前會需要先下載安裝套件，而 pip 是用來下載其他套件非常好用的工具。當我們下載完 pip 後，未來下載套件只需要在 cmd 輸入指令就能搞定。pip install packagename也許現在還是會有點困惑，但未來真正開始寫 Python 就會明白為什麼大家下載完 Python 都會接著安裝 pip 了。3.下載 get-pip.py先下載 get-pip.py接著開啟 cmd，使用 cd 將目前位置移到 get-pip.py 的路徑底下，並輸入python get-pip.py這時候只差最後一步了4.設定環境變數這個步驟與剛剛第2個步驟一樣，不過現在要加上的路徑是「;C:Python27Script」接著使用 pip install 安裝看看套件，例如可以安裝寫爬蟲程式必備的 requests 套件pip install requests如果沒有問題，一切就大功告成！",
      "url": " /python/2018/05/23/Python-%E4%B8%8B%E8%BC%89%E8%88%87%E5%AE%89%E8%A3%9DPython%E5%8F%8Apip%E5%A5%97%E4%BB%B6/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "r-2018-02-26-r-e5-a6-82-e4-bd-95-e8-ae-80-e5-8f-96excel-e6-aa-94-e6-a1-88": {
      "title": "[R]如何使用R讀取Excel檔案",
      "content"	 : "很多資料會使用excel檔案儲存，這邊介紹如何使用R讀取主要三種常用的excel附檔名。  csv  xlsx  xls1.csvcsv是最簡單的，不需要install任何package，read.csvd &amp;lt;- read.csv(&quot;file.csv&quot;, stringsAsFactors = FALSE) 假如很不幸，上面的程式碼讀取後你碰到長得像這樣的錯誤訊息Error in type.convert(data[[i]], as.is = as.is[i], dec = dec, numerals = numerals,  : invalid multibyte string at &#39;&amp;lt;e8&amp;gt;&amp;lt;8a&amp;gt;&amp;lt;b1&amp;gt;?&amp;lt;ae&amp;gt;&#39;那就是碰上了編碼錯誤，這時候別緊張，只要加上fileEncoding這個參數就好，d &amp;lt;- read.csv(paste0(&quot;file.csv&quot;), stringsAsFactors = FALSE, fileEncoding = &quot;UTF-8&quot;) 問題應該就可以被解決了。2.xlsx讀取xlsx檔案時依據情況，有兩個套件我會使用，  openxlsx  XLConnect這兩個套件都可以儲存多個sheet，對儲存格做顏色、合併、篩選等等一般可以做的事都可以用程式碼去做。(1)openxlsx讀檔library(openxlsx)# 可以使用sheet參數選擇要的sheet，預設是第一個sheetd &amp;lt;- read.xlsx(&quot;file.xlsx&quot;, sheet = sheetName)寫檔library(openxlsx)### 整個xlsx只有一張sheet寫檔可以簡單的使用write.xlsx就好write.xlsx(d, file = &quot;file.xlsx&quot;)### 有多個sheet要寫入檔案，或是要調整sheet的stylewb &amp;lt;- createWorkbook()# 增加sheetaddWorksheet(wb, &quot;sheetName&quot;)# 設定欄位寬度setColWidths(wb, sheet, cols = c(1:4), widths = c(rep(25, 3), 30))# 增加styleheaderStyle &amp;lt;- createStyle(fgFill = &quot;yellow&quot;, border = &quot;TopBottomLeftRight&quot;, halign = &quot;center&quot;, textDecoration = &quot;bold&quot;, fontSize = 12)addStyle(wb, sheet = sheet, headerStyle, row = 1, cols = 4, gridExpand = TRUE, stack = TRUE)# 加上filteraddFilter(wb, 1, row = 1, cols = 1:ncol(d))# 寫檔writeData(wb, sheet = sheet, d)# 存檔saveWorkbook(wb, &quot;file.xlsx&quot;, overwrite = TRUE)(2)XLConnect至於XLConnect我是在想要使用資料驗證(data validation)裡的「清單」功能時想要克服的。一開始想要直接使用openxlsx的dataValidation function，但一直失敗，且找到這裡說明 list 這個功能無法發揮，所以我想到先儲存一個 template，將我需要的資料驗證清單做好，再使用 loadworkbook 的方法就可以保留 excel 裡原本的樣式。原本是直接使用 openxlsx 這個 library 的 loadWorkbook，但在調整顏色時一直會有 error 無法解決，在改用 XLConnect 這個 library 後就成功使用我想要的cells style與保留資料驗證清單了。另外一個碰到的狀況是我也是要使用一份 template 的樣式，使用openxlsx和XLConnect的loadWorkbook時都遇到像這樣的錯誤Error in substring(x[ind], so, eo) :   invalid multibyte string at &#39;&amp;lt;e6&amp;gt;&amp;lt;96&amp;gt;&amp;lt;b0&amp;gt;蝝唳&amp;lt;98&amp;gt;&amp;lt;ab&amp;gt;&amp;lt;94&amp;gt;&quot;/&amp;gt;&#39;看起來像是編碼上的錯誤，但這份檔案上完全沒有中文，後來我甚至存一份空白的excel檔案都還是會有錯誤。我將其他可以使用 loadWorkbook 這個 function 的 xlsx 丟進 Notepad++ 看，發現可以讀的檔案是Macintosh(CR)不能讀的檔案是Unix(LF)但是，將 template 儲存成 Macintosh(CR) 後，openxlsx的 loadWorkbook function 還是有同樣的 error，而 XLConnect 的錯誤則解除了。程式碼範例，library(XLConnect)# 讀取templatewb &amp;lt;- loadWorkbook(&quot;file.xlsx&quot;)# d是要儲存的dataframe，getSheets(wb)是sheet的名稱writeWorksheet(wb, d, getSheets(wb), startRow = 7, startCol = 1, header = FALSE)# 設stylecs &amp;lt;- createCellStyle(wb)# 邊框setBorder(cs, side = c(&quot;all&quot;), type = XLC$&quot;BORDER.THIN&quot;, color = c(XLC$&quot;COLOR.BLACK&quot;))setCellStyle(wb, sheet = getSheets(wb), row = 7:(7+nrow(d)), col = 1, cellstyle = cs)# 存檔saveWorkbook(wb, file = &quot;savefile.xlsx&quot;)3.xlsxls用的是readxl套件，是R界有名的ggplot2作者Hadley Wickham所寫。下載完後只要一行指令就好，library(readxl)saleslead &amp;lt;- read_excel(paste0(PATH, &quot;2018 sales lead report (for TM only).xls&quot;), sheet = &quot;Raw Data&quot;)但要注意的是屬性問題。其他更多 library 的 function 都可以去CRAN找哦！",
      "url": " /r/2018/02/26/R-%E5%A6%82%E4%BD%95%E8%AE%80%E5%8F%96Excel%E6%AA%94%E6%A1%88/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-02-26-r-e4-bd-bf-e7-94-a8r-e5-af-84outlook-email": {
      "title": "[R]使用 R 寄Outlook Email",
      "content"	 : "之前有介紹過使用mailR這個套件夾帶檔案使用gmail信箱發送信件。這篇要介紹使用RDOCOMClient這個套件來發送outlook夾帶檔案的電子郵件。參考library(RDCOMClient)## init com apiOutApp &amp;lt;- COMCreate(&quot;Outlook.Application&quot;)## create an email outMail = OutApp$CreateItem(0)## configure  email parameter outMail[[&quot;To&quot;]] = &quot;reciever@mail.com&quot;outMail[[&quot;subject&quot;]] = &quot;subject&quot;# There are two ways you can write for mail body# First:text# outMail[[&quot;body&quot;]] = # &quot;Dear reciever,#                      # Please see attached.# # # Best regards,# Sender&quot;# Second:html textbody &amp;lt;- &#39;&amp;lt;p&amp;gt;Dear reciever,&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;Please see attached.&amp;lt;/p&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;p&amp;gt;Best regards,&amp;lt;p&amp;gt;Sender&amp;lt;/p&amp;gt;&#39;outMail[[&quot;HTMLbody&quot;]] = body# attachmentoutMail[[&quot;Attachments&quot;]]$Add(&quot;path of your attachment&quot;)## send it                     outMail$Send()",
      "url": " /r/2018/02/26/R-%E4%BD%BF%E7%94%A8R%E5%AF%84Outlook-Email/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2018-02-17-python-e7-88-ac-e8-9f-b2-requests-e7-9a-84-e7-b7-a8-e7-a2-bc": {
      "title": "[Python][爬蟲]requests 的編碼",
      "content"	 : "rep = requests.get(url)rep.content ： bytes 型別rep.text    ： unicode 型別1.是由 requests 以 rep.encoding 自動轉換的！2.rep.encoding 是以 Reponse Headers 的 Content-Type 決定！",
      "url": " /python/%E7%88%AC%E8%9F%B2/2018/02/17/Python-%E7%88%AC%E8%9F%B2-requests-%E7%9A%84%E7%B7%A8%E7%A2%BC/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2018-02-07-python-e7-88-ac-e8-9f-b2-e9-98-b2-e6-ad-a2-e8-a2-abban-e4-bb-a3-e7-90-86ip-e6-80-8e-e9-ba-bc-e7-94-a8": {
      "title": "[Python][爬蟲]防止被ban，代理IP怎麼用?",
      "content"	 : "如何讓爬蟲程式不被ban?  動態設置user agent  使用代理IP參考這裡主要介紹如何使用IP代理。proxy代理類型參考      透明代理(Transparent Proxy)REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Your IP        匿名代理(Anonymous Proxy)REMOTE_ADDR = proxy IPHTTP_VIA = proxy IPHTTP_X_FORWARDED_FOR = proxy IP        混淆代理(Distorting Proxies)REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Random IP address        高匿代理(Elite proxy或High Anonymity Proxy)REMOTE_ADDR = Proxy IPHTTP_VIA = not determinedHTTP_X_FORWARDED_FOR = not determined  代理proxy哪裡找？這裡提供兩個我覺得品質比較好的proxy代理  http://www.goubanjia.com/free/index.shtml  http://www.proxyserverlist24.top/程式碼如何確定真的使用代理IP了？import requests# 隨便google可以找到可以查詢自己IP的網站url = &quot;http://icanhazip.com/&quot;  # 這個網站可以知道目前瀏覽的IPproxies = {&quot;http&quot;:&quot;http://xx.xx.xxx:xxxx&quot;,&quot;https&quot;:&quot;https://xx.xx.xxx:xxxx&quot;,}###注意#要爬取的網站是使用什麼協定？http？https？#網址可能會有轉址的情況，最後轉的那個網址才是真正的協定喔res = requests.get(url, proxies = proxies)print res.text  # 如果這個網站print出來的和proxies一樣，那就表示成功了抓完proxy後，我將所有proxy儲存在csv檔案中，要爬取網站的時候，先讀取該檔案，只要被擋，就random使用proxy替換proxies。如果所有proxy都用完再重新爬取，網站上的proxy都會不停更換，所以只要更新proxy庫就好。",
      "url": " /python/%E7%88%AC%E8%9F%B2/2018/02/07/Python-%E7%88%AC%E8%9F%B2-%E9%98%B2%E6%AD%A2%E8%A2%ABban-%E4%BB%A3%E7%90%86IP%E6%80%8E%E9%BA%BC%E7%94%A8/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-2018-02-02-python-e5-91-bc-e5-8f-ab-e5-85-b6-e4-bb-96py-e7-9a-84function": {
      "title": "[Python]呼叫其他.py的function",
      "content"	 : "假如現在正在寫的檔案是main.py，而你想要呼叫fun.py這裡面的function，要怎麼做呢？### 這是fun.pydef itsafunction():print &quot;This is a function that I want to call.&quot;有兩種情況，1. 這兩個檔案在同一個folder底下—main.py—fun.py### 這是 main.pyfrom fun import itsafunction# 使用fun.py的itsafunction()itsafunction()2. 這兩個檔案在不同folder底下想要呼叫的fun.py在function這個folder底下—main.py—function—fun.py這時候main.py可以有兩種寫法### 這是main1.pyfrom function import fun# 使用fun.py的itsafunction()fun.itsafunction()### 這是main2.pyfrom function.fun import itsafunction# 使用fun.py的itsafunction()itsafunction()但還有一件很重要的事，要在function這個folder裡加”__init__.py”這個檔案### 這是__init___.py# 什麼都不用寫，沒錯，就是一個空白的.py檔# it&#39;s true, it&#39;s empty. But it&#39;s still important!那如果今天fun.py在function的下一層folder呢?—main.py—function—another—fun.py只要把main.py改成### 這是main.pyfrom function.another import fun# 使用fun.py的itsafunction()fun.itsafunction()#或者也可以這樣寫from function.another.fun import itsafunction# 使用fun.py的itsafunction()itsafunction()但最重要的是，function和another這兩個folder裡面都要加上”__init__.py”這個檔案!",
      "url": " /python/2018/02/02/Python-%E5%91%BC%E5%8F%AB%E5%85%B6%E4%BB%96py%E7%9A%84function/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "tutorial-2018-01-25-tutorial-computer-networking-e7-ad-86-e8-a8-98-22-26": {
      "title": "[Tutorial]Computer Networking筆記(22-26)",
      "content"	 : "Computer Networking TutorialHow Binary Code Works?  bit = binary digit  8-bit system 最高到2^8舉例，如果今天我們要表示19這個數字，那就會是2^8、2^7、2^6、2^5、2^4、2^3、2^2、2^1、2^0 0 、 0 、 0 、 0 、 1 、 0 、 0 、 1 、 1在8 bits的系統裡，可以表示從0到255的數字。也就是，111111111所以如果今天有更多的bits就可以儲存更多的data，這也就是為什麼更大的bits功能較強大了。IP Address每個device都有ip address。IP是一個32 bits的2進位表示的數字，中間以「.」隔開成四組號碼。像這樣:xxx.xxx.xxx.xxx每一組xxx都是8-bit，也就是一個八位數的0、1所組成的數字，所以，每一組有2^8(256)個數字，總共就會有2^82^82^8*2^組IP。而我們看到的IP則是再把這些2進位的數字轉換成10進位表示。這樣的方式就可以讓每個device表達它的位置。IP Addressing IssuesThe Internet is a network of networks.影片舉了一個例子：想像網路其實是聚集了所有的網絡。例如，社區網路是一個網絡，學校是一個網絡，公司是一個網絡，而這三個網絡又都可以連到網路上。當今天，公司裡有台電腦送了requests到網路另一端的server，這時候server收到訊息後，會再傳回response，可是它要如何透過IP知道到底找到這個送出requests的裝置呢？所以其實IP裡頭包含兩個訊息，  Newwork ID  Host ID但是，重點來了！那一組32 bits的IP要怎麼表示Newwork ID和Host ID呢？如果對分，讓16 bits表示Newwork ID，16 bits表示Host ID，這樣就可以有65,536個Newwork ID配上Host ID的組合。但這時候有人說，那萬一某個network的host很少，那豈不是浪費了很多host的位址嗎！但讓host多點bits或少點bits都有可能會遇到浪費或是不夠的問題，這時候大家有點爭論不休，到底該如何解決呢？所以這時有人提出了一個辦法，我們應該要用一個方法表示出Network ID和Host ID的長度。Subnet mask(子網路遮罩)當今天在傳送訊息時，device不只傳送自己的ip，也傳送subnet mask來表示network id和host id長度，subnet mask一樣是一個32 bits的2進位數字，1表示network id，0表示host id。(這裡看影片應該會比較好理解)詳細範例",
      "url": " /tutorial/2018/01/25/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(22-26)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "tutorial-2018-01-24-tutorial-computer-networking-e7-ad-86-e8-a8-98-16-21": {
      "title": "[Tutorial]Computer Networking筆記(16-21)",
      "content"	 : "Computer Networking TutorialOSI ModelOSI Model- Open System Interconnection Reference Model總之，這是一個試圖使各種電腦在世界範圍內互連為網路的標準框架，總共有七層。這有另外一個我覺得還不錯的影片ModemModem就是我們說的數據機。It’s device that connects the network to the Internet.It converges digital signals from router(or any other devices) to analog signals.簡單來說，數據機可以將數位訊號變成類比訊號(訊號轉換器的感覺)，電話、網路等等會透過數據機來轉換訊號而獲得另一方的訊號。RouterRouter是路由器。Router joins network together.SwitchSwitch是分享器。假如今天路由器的網路插孔不夠，分享器可以增加網路插孔，讓更多的電腦使用。路由器和分享器差在哪Repeater/ExtenderRepeater/Extender是中繼器。在一個比較大的空間裡，路由器的信號會因為距離而所差別，這時候使用中繼器，就可以讓網路訊號放大，讓離路由器較遠的裝置也可以有良好的訊號。即便是接網路線，如果網路線過長，訊號也會變差，所以如果使用中繼器可以解決距離較遠的問題。而路由器本身就有中繼器的功能，所以只要選擇其一使用就好。",
      "url": " /tutorial/2018/01/24/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(16-21)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "tutorial-2018-01-20-tutorial-computer-networking-e7-ad-86-e8-a8-98-12-15": {
      "title": "[Tutorial]Computer Networking筆記(12-15)",
      "content"	 : "Computer Networking TutorialTopology/LayoutTopology/Layout是網路之間連接的方式，wiki上翻成「網路拓樸」。每一種方式都各有有缺點，所以取決於使用的目的來決定適合哪種Layout。這個課程介紹三種方式：  Bus Topology(Tutorial 12)  Ring Topology(Tutorial 13)  Star Topology(Tutorial 14)1. Bus TopologyBus Topology是最簡單的一種連接方式，最主要中間有一條主幹，其他node再與主幹相連。最重要的是，主幹的尾端一定要有terminator，才能將傳到尾端的訊號吸收，否則會有回傳的訊號干擾。這樣的優點就是，簡單而且便宜，適合使用在小範圍的網絡內。但缺點是，只有主幹上出了問題，整個網路可能就會出問題。2. Ring TopologyRing Topology與Bus Topology不同的是，它是一個沒有終端環狀，所有node與該環狀線連結，訊號會順著同一個方向傳遞。一般來說，會有兩個環狀(double ring)，訊號會是反方向傳遞。這樣的優點就是，它不需要Bus Topology必須的terminator，而且如果是雙環，也比較不會有主幹出問題，整個網路就壞掉的問題。但缺點是，它比Bus Topology貴。3. Star TopologyStar Topology可能是家裡最常見的一種連結方式。Star Topology會有許多nodes連結中的device(譬如rounter)，就像是星狀一樣。例如，如果中心是rounter，它會在連結internet。這種topology的優點是，價格低、easy to expand。另一方面，如果有其中的node或是某一個node與中心的device的連結出了問題，其他nodes都不會被影響。但缺點是，因為所有nodes都連結中心，也就是所有的nodes全部都必須要依賴中心，所以只要中心的device壞掉，整個連線就會全部失效。4.Mesh TopologyMesh Topology所有nodes之間都互相連結，就像個網狀。這種方式比較會在MAN或WAN見到，不會在LAN使用。優點是，因為每個node之間都互相連結，所以假如有兩個nodes之間的連結出了問題，還可以透過其他nodes傳遞訊號，這樣在傳送訊息上也比較保險。缺點是，因為每個node之間都要連接，就會需要有很多的cable，這時候成本就會提高。有越多的node，成本就會越高。另一方面，因為一個node需要和其他所有nodes連結，這時候網卡(NIC)就需要更強大，同樣也會造成成本的提高，且每一次增加node可能都需要增加NIC。",
      "url": " /tutorial/2018/01/20/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(12-15)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "r-2018-01-17-r-read-csv-e5-87-ba-e7-8f-be-e7-b7-a8-e7-a2-bc-e9-8c-af-e8-aa-a4-e8-a8-8a-e6-81-af": {
      "title": "[R]read.csv出現編碼錯誤訊息",
      "content"	 : "在讀取csv檔案時出現錯誤訊息 d &amp;lt;- read.csv(&quot;file.csv&quot;), stringsAsFactors = FALSE) # Error in type.convert(data[[i]], as.is = as.is[i], dec = dec, numerals = numerals,  : invalid multibyte string at &#39;&amp;lt;e8&amp;gt;&amp;lt;8a&amp;gt;&amp;lt;b1&amp;gt;?&amp;lt;ae&amp;gt;&#39;會出現這樣的錯誤訊息通常是因為編碼問題。先將這份檔案丟到Notepad++，可以看到右下方顯示這份檔案的編碼，(這份檔案是UTF-8)所以只要加上fileEncoding =”UTF-8”就可以解決這個問題了。 d &amp;lt;- read.csv(paste0(&quot;file.csv&quot;), stringsAsFactors = FALSE, fileEncoding =&quot;UTF-8&quot;) ",
      "url": " /r/2018/01/17/R-read.csv%E5%87%BA%E7%8F%BE%E7%B7%A8%E7%A2%BC%E9%8C%AF%E8%AA%A4%E8%A8%8A%E6%81%AF/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-01-17-r-e5-a6-82-e4-bd-95-e5-88-aa-e9-99-a4-u-00a0": {
      "title": "[R]如何刪除 U+00A0",
      "content"	 : "在資料中有些含有空白的文字讀進R後會變成&amp;lt;U+00A0&amp;gt;而且不管用什麼方式都取代不了這個符號，這時候該怎麼辦呢？其實只要使用 “U00A0”就可以了# t是含有&quot;&amp;lt;U+00A0&amp;gt;&quot;的字串t &amp;lt;- gsub(&quot;U00A0&quot;, &quot;&quot;, t)",
      "url": " /r/2018/01/17/R-%E5%A6%82%E4%BD%95%E5%88%AA%E9%99%A4-U+00A0/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "tutorial-2018-01-15-tutorial-computer-networking-e7-ad-86-e8-a8-98-9-11": {
      "title": "[Tutorial]Computer Networking筆記(9-11)",
      "content"	 : "Computer Networking Tutorial1.What is NIC(Network Interface Card)?NIC就是網卡，所有電腦都必須要有網卡才能連上網路。(just google it, you can find tons of pictures of NIC)2.What is a Protocol?字典翻譯的意思是，協議草案、禮儀。在network裡，protocol是「網路傳輸協定」。這裡作者先不講定義，先講一個communication會有什麼要件，他用男生想要認識一個女生來舉例。一開始男生要搭訕女生他們可能會有像這樣的對話  Hey  -&amp;gt;  &amp;lt;-  Hello  Can I get your number?   -&amp;gt;  &amp;lt;- 1234-567這樣的對話中會有幾個規則，  一次只會有一個人說話  男生說話以後，會預期女生會回話  問句會有預期的回答(specific messages receive specific responses)符合這樣的規則，那麼人之間的對話(communication)才會有可能成立。同樣的，用在computer commnication也要有一些規則。Protocol are the rules for successful communication among two parties.如果今天你的mac想要和web sever communicates這時候protocol會是什麼呢？  Can I connect to you?   -&amp;gt;  &amp;lt;-   Yes, you have my permission.  GET file google.com   -&amp;gt;  &amp;lt;-  sends file在computer networking裡，最重要的protocol是format和order of massage就像是上面的請求順序，如果在mac還沒提出request，sever就送出網頁，這肯定很怪的吧！protocol有很多種，但我們先來看以下這個例子。這是個網址，http:// www.thenewboston.org /index.php  http: protocol  www.thenewboston.org: sever name  index.php: file",
      "url": " /tutorial/2018/01/15/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(9-11)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "python-2018-01-15-python-google-e7-bf-bb-e8-ad-afapi-e6-8e-a5-e5-8f-a3-library-googletrnas": {
      "title": "[Python]Google 翻譯 API 接口 googletrnas",
      "content"	 : "使用前，先安裝googletrans# windowspip install googletrans# macsudo pip install googletrans程式碼# -*- coding: utf-8 -*-from googletrans import Translatorimport sys# 這兩行很重要，不然會有編碼問題reload(sys)sys.setdefaultencoding( &quot;utf-8&quot; )translator = Translator()# src來源語言，dest要翻譯語言，如果要找其他語言可以參考說明文件print translator.translate(&#39;고마워&#39;, src = &quot;ko&quot;, dest = &quot;zh-TW&quot;)根據說明文件，這個套件可能會有不穩定的問題找到有人直接爬google翻譯的程式碼但其實如果沒有要很大量的爬取我認為這個套件應該很好用了。",
      "url": " /python/2018/01/15/Python-Google%E7%BF%BB%E8%AD%AFAPI%E6%8E%A5%E5%8F%A3-library-googletrnas/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "tutorial-2018-01-09-tutorial-computer-networking-e7-ad-86-e8-a8-98-1-8": {
      "title": "[Tutorial]Computer Networking筆記(1-8)",
      "content"	 : "Computer Networking Tutorial1.What is Computer Networking?各裝置(devices)之間的連結裝置：PC、laptop、printer、rounter等等(不限於電腦)，每一個device都是一個Node。連結：可以使用cable、wireless、copper wire等等，可以稱為communications media。Internet(網路)就是一種computer networkcomputer nework的目的是為了要資料傳輸、資料交換，這裡的資料可以是，documents、pictures、videos等等。computer newworking的兩個重點就是，Nodes和Communications Media2.Types of NetworksLAN(Local Area Network)：一個building的網絡連結，可能是一棟建築、一所學校，小範圍的區域網絡MAN(Metorpolitan Area Network)：多個建築之間的網絡連結，可能是一個城市WAN(Wide Area Network)：&amp;gt;30 miles的網絡連結，整個國家之間、跨國之間的連結3.How the Internet works?以網站為例，假如我今天有一個個人網站，別人是如何透過internet看到我的網站的呢？如果以上面computer network的邏輯來看，其他電腦可以連結到我的電腦，看到我的個人網站。但，如果所有人都可以連到我的個人電腦這樣會有網路安全的疑慮，所以實際上，要連到個人網站是透過server。server is a special computer that everyone can access it.我將個人網站建置(store)在server，其他人要看到我的網站，會在browser上打上網址，這時候就會向server提出request，sever接受到request會回傳data，這些data會是程式碼，而browser會將這些程式碼轉成我們看得懂的網站。通常建置網頁這樣的server我們稱為，web server。像google這麼大的網站，一次總是要接收非常大量來自世界各地的request，所以這個server就必須要有很大的memory，才能負荷這樣的使用流量。4.Client and Host根據上面提到的例子，使用PC的browser向sever提出request，然後server會提供給data給PC的browser。PC接收資料，而server提供資料，PC就是client，sever就是host。",
      "url": " /tutorial/2018/01/09/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(1-8)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2018-01-08-python-e7-88-ac-e8-9f-b2-url-e6-b2-92-e6-9c-89http-https-e8-88-87-e7-b6-b2-e5-9d-80-e9-87-8d-e6-96-b0-e5-b0-8e-e5-90-91": {
      "title": "[Python][爬蟲]URL沒有 HTTP/HTTPS 與網址重新導向",
      "content"	 : "這次要爬的網址長得像這樣  hazyfairyland.blogspot.tw  cartersoshkosh.tw  yungmaun.com.tw沒有www也沒有http/https，如果直接將這樣的網址丟到瀏覽器的網址列它會自動重新導向，但如果是使用request就會產生錯誤訊息。這時候該怎麼辦呢？其實只要在前方加上”http://”就行了，若其實該網址是”https//”， request也會自動重新導向。假如所有的網址都是沒有www，就直接在所有url前方加上”http://”就好了。url = &quot;cartersoshkosh.tw&quot;while True:    try:        res = requests.get(url, timeout = 30)        break    # catch requests.exceptions.MissingSchema error, add &quot;http://&quot; in the front    except requests.exceptions.MissingSchema:        url = &quot;http://&quot; + url           print res.url  # print the final url    print res.history  # print how many redirections it has gone throgh",
      "url": " /python/%E7%88%AC%E8%9F%B2/2018/01/08/Python-%E7%88%AC%E8%9F%B2-URL%E6%B2%92%E6%9C%89HTTP-HTTPS%E8%88%87%E7%B6%B2%E5%9D%80%E9%87%8D%E6%96%B0%E5%B0%8E%E5%90%91/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-2018-01-08-python-read-and-write-csv-file": {
      "title": "[Python]Read and Write CSV file",
      "content"	 : "import csv# read csv filewith open(&quot;file.csv&quot;, &quot;rb&quot;) as f:    for row in csv.reader(f):        print row    # write csv filedata = [[&quot;data1&quot;, &quot;data2&quot;], [&quot;data3&quot;, &quot;data4&quot;]]  # list with open(&quot;file.csv&quot;, &quot;wb&quot;) as f:    w = csv.writer(f)    w.writerows(data)",
      "url": " /python/2018/01/08/Python-Read-and-Write-CSV-file/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-08-18-python-e7-88-ac-e8-9f-b2-e5-a6-82-e4-bd-95-e7-88-ac-e5-8f-96-e7-b6-b2-e9-a0-81-e4-b8-adjs-e7-94-9f-e6-88-90-e7-9a-84-e9-83-a8-e5-88-86": {
      "title": "[Python][爬蟲]如何爬取網頁中js生成的部分",
      "content"	 : "這次想要爬取的是2017年汽車技術展會的參展廠商名單。網頁長得像這樣，在load網頁的時候可以發現，「AUTOMOTIVE WORLD」這個框框會比較慢才跑出來，(可以按重新整裡查看)這時候就可以猜測網頁的這個部份是js生成的。同樣的，使用右鍵「檢查元素」來查看在load這個網頁的過程發生了什麼事。一般來說Network的第一個就會是我們要找的內容，這裡是「Exhibitor/」，查看Headers的General，可以發現就是url就是原本的頁面。如果去抓取網頁，url = &quot;http://www.automotiveworld.jp/en/To-Visit/Exhibitor/&quot;res = requests.get(url)print res.text.encode(&quot;utf-8&quot;)會發現完全抓不到廠商名單的tag，這就是因為，那一個區塊是js另外生成的，所以要去找另外生成的頁面。回到「檢查元素」的Network，看看有沒有什麼可疑對象，這時候發現一個type是document的ExhiList，點進去發現長得像這樣，將網址丟到網址列，果然，就得到了我們要的部分了！完整程式碼",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/08/18/Python-%E7%88%AC%E8%9F%B2-%E5%A6%82%E4%BD%95%E7%88%AC%E5%8F%96%E7%B6%B2%E9%A0%81%E4%B8%ADjs%E7%94%9F%E6%88%90%E7%9A%84%E9%83%A8%E5%88%86/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "git-2017-07-26-git-e6-8f-90-e4-ba-a4-e4-b8-80-e5-80-8b-e6-9b-b4-e6-96-b0": {
      "title": "[Git] 提交一個更新",
      "content"	 : "以下要介紹最基本的同步，檔案在本機被修改或是增加後push到github。1.檢視所有檔案狀態$ git status  #修改或是增加的檔案會呈現紅字2.告知git需要commit的檔案$ git add &amp;lt;file&amp;gt;  #提交一個新增加的檔案$ git add -A  #stages All$ git add .  #stages new and modified, without deleted$ git add -u  #stages modified and deleted, without newadd完後用 git status 會發現原本的紅字變成綠字3.commit變化$ git commit這時候需要記錄提交的訊息4.push同步$ git push主要流程，增加、修改檔案 &amp;gt; git add &amp;gt; git commit &amp;gt; git push透過git status可以查看目前的狀態參考",
      "url": " /git/2017/07/26/Git-%E6%8F%90%E4%BA%A4%E4%B8%80%E5%80%8B%E6%9B%B4%E6%96%B0/",
      "author": "Shihs",
      "categories": "Git"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-07-25-python-e7-88-ac-e8-9f-b2-e5-a6-82-e4-bd-95-e4-b8-8b-e8-bc-89zip-e6-aa-94": {
      "title": "[Python][爬蟲]如何下載 zip 檔",
      "content"	 : "這裡要示範使用三個不同的package下載zip檔。import urllibimport urllib2import requestsurl = &#39;http://www.blog.pythonlibrary.org/wp-content/uploads/2012/06/wxDbViewer.zip&#39;print &quot;downloading with urllib&quot;urllib.urlretrieve(url, &quot;code.zip&quot;)print &quot;downloading with urllib2&quot;f = urllib2.urlopen(url)data = f.read()with open(&quot;code2.zip&quot;, &quot;wb&quot;) as code:    code.write(data)print &quot;downloading with requests&quot;r = requests.get(url)with open(&quot;code3.zip&quot;, &quot;wb&quot;) as code:    code.write(r.content)參考",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/07/25/Python-%E7%88%AC%E8%9F%B2-%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BC%89zip%E6%AA%94/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "excel-vba-2017-07-05-excel-vba-outlook-e4-bf-a1-e4-bb-b6-e5-85-a7-e6-96-87-e5-90-ab-e5-9c-96-e6-aa-94": {
      "title": "[Excel][VBA]寄出內文含圖檔的outlook信件",
      "content"	 : "這裡要介紹如何使用Excel VBA在信件內容包含截取sheet中的特定欄位區塊，並將此區塊變為圖檔包含在內文中寄出。現在要截取一份長這樣的檔案有兩種方法。第一種方法是，先將截取的區塊存成圖檔後再將此圖檔讀取到郵件內容。Sub PrintScreen()      &#39;複製工作表要存圖檔的範圍        Sheets(&quot;Sheet1&quot;).Select        Set rng = Range(&quot;A1:B3&quot;)        rng.CopyPicture      &#39; Excel 存圖檔的精簡程式碼。        With ActiveSheet.ChartObjects.Add(1, 1, rng.Width, rng.Height)  &#39;新增 圖表            .Chart.Paste                                                &#39;貼上 圖片            .Chart.Export Filename:=&quot;test.PNG&quot;, Filtername:=&quot;PNG&quot; &#39;匯出 圖片            .Delete                                                     &#39;刪除 圖表        End WithEnd SubSub SendMail_1()        Dim objOutlook As Object    Dim objMail As Object        Set objOutlook = CreateObject(&quot;Outlook.Application&quot;)    Set objMail = objOutlook.CreateItem(0)        With objMail        .to = &quot;address@email.com&quot;        .Subject = &quot;Subject&quot;        .Body = &quot;mail body&quot;        .HTMLbody = .HTMLbody &amp;amp; &quot;&amp;lt;br&amp;gt;&amp;lt;B&amp;gt;Embedded Image:&amp;lt;/B&amp;gt;&amp;lt;br&amp;gt;&quot; _                &amp;amp; &quot;&amp;lt;img src=&#39;test.PNG&#39;&quot; &amp;amp; &quot;width=&#39;250&#39; height=&#39;100&#39;&amp;gt;&amp;lt;br&amp;gt;&quot; _                &amp;amp; &quot;&amp;lt;br&amp;gt;Best Regards, &amp;lt;br&amp;gt;Sumit&amp;lt;/font&amp;gt;&amp;lt;/span&amp;gt;&quot;       &#39; objMail.Attachments.Add &quot;test.PNG&quot;       &#39; 使用附件檔案       &#39;.Display     &#39; 可以編輯郵件內容，再按下 傳送 鍵。       &#39;.Save         &#39; to save a copy in the drafts folder        .Send        &#39; 直接送出郵件            End With               Set objOutlook = Nothing    Set objMail = Nothing    End Sub第二種方法是，直接截取區要的區塊，變成圖檔，然後貼到信件內容。Sub SendMail_2()    Set objOutlook = CreateObject(&quot;Outlook.Application&quot;)    Set objMail = objOutlook.CreateItem(0)    &#39; mail body    strbody = &quot;mail body&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;    &#39;Copy range of interest    Dim r As Range    Set r = Sheets(&quot;Sheet1&quot;).Range(&quot;A1:B3&quot;)    r.Copy    &#39;Paste as picture in sheet and cut immediately    Dim p As Picture    Set p = ActiveSheet.Pictures.Paste    p.Cut            With objMail        .to = &quot;address@email.com&quot;        &#39;.cc =        &#39;.bcc = &quot;&quot;        .Subject = &quot;Subject&quot;        .HTMLbody = strbody        &#39;.Display            End With    &#39;Get its Word editor    objMail.Display    Dim wordDoc As Object    Set wordDoc = objMail.GetInspector.WordEditor    &#39;Paste picture    wordDoc.Range(Start:=wordDoc.Range.End - 3).Paste        &#39;send mail    objMail.Send        Set objOutlook = Nothing    Set objMail = NothingEnd Sub",
      "url": " /excel/vba/2017/07/05/Excel-VBA-outlook%E4%BF%A1%E4%BB%B6%E5%85%A7%E6%96%87%E5%90%AB%E5%9C%96%E6%AA%94/",
      "author": "Shihs",
      "categories": "Excel, VBA"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-06-30-python-e7-88-ac-e8-9f-b2-e4-b8-8d-e5-90-8c-e7-9a-84content-type-multipart-form-data": {
      "title": "[Python][爬蟲]不同的 Content-Type (multipart/form-data)",
      "content"	 : "這次要爬的目標是台灣精品獎得獎名單。我想要爬取的條件是，這時候會猜測這應該是個post的requests。果然，在按下查詢後，出現了一個cross_list的可疑人物，因為是post，所以會期望在headers裡找到 “Form Data”，這裡面應會藏著post需要的參數。但不幸的是，什麼也沒有，只找到長得像這樣的”Request Payload”然後Content-Type是multipart/form-data其實，我們平常需要的data form裡的資料就藏在Request Payload裡。抓取的方式是，以這行為例，------WebKitFormBoundaryTaDJAA82fTd3ug3WContent-Disposition: form-data; name=&quot;awards[]&quot;1name後的 “award[]” 就會是dictionary的key，底下的 1 ，就會是value，所以就會變成{&quot;awards[]&quot; = &quot;1&quot;}所以就把Request Payload所有的資訊寫成payload = {&quot;keyword&quot;:&quot;&quot;,&quot;awards[]&quot;:&quot;1&quot;,&quot;awards[]&quot;:&quot;2&quot;,&quot;awards[]&quot;:&quot;3&quot;,&quot;years[]&quot;:&quot;2017&quot;,&quot;years[]&quot;:&quot;2016&quot;,&quot;industry[]&quot;:&quot;A&quot;,&quot;industry[]&quot;:&quot;B&quot;,&quot;industry[]&quot;:&quot;C&quot;,&quot;industry[]&quot;:&quot;D&quot;,&quot;industry[]&quot;:&quot;E&quot;,&quot;industry[]&quot;:&quot;F&quot;,&quot;industry[]&quot;:&quot;G&quot;,&quot;industry[]&quot;:&quot;H&quot;,&quot;industry[]&quot;:&quot;I&quot;,&quot;industry[]&quot;:&quot;J&quot;,&quot;industry[]&quot;:&quot;K&quot;,&quot;industry[]&quot;:&quot;L&quot;,&quot;industry[]&quot;:&quot;Z&quot;}但這樣寫完會覺得非常不合理，因為會有一堆同樣的key但給予不同的value，也就是說會key會一直被新的value取代。我當時的想法是，看到 [] 就會很想要在裡面塞數字順位，果然，從0開始，將相同的key編號，就成功了。所以這樣送出requests，# -*- coding: utf-8 -*-#爬取台灣精品得獎名單http://www.taiwanexcellence.org/index.php/awards/now/cross_list/1/2017/2/1from bs4 import BeautifulSoupimport requestsimport mathurl = &quot;http://www.taiwanexcellence.org/index.php/awards/now/send_search/1/2017/2/1/cross_list&quot;payload = {&quot;keyword&quot;:&quot;&quot;,&quot;awards[0]&quot;:&quot;1&quot;,&quot;awards[1]&quot;:&quot;2&quot;,&quot;awards[2]&quot;:&quot;3&quot;,&quot;years[0]&quot;:&quot;2017&quot;,&quot;years[1]&quot;:&quot;2016&quot;,&quot;industry[0]&quot;:&quot;A&quot;,&quot;industry[1]&quot;:&quot;B&quot;,&quot;industry[2]&quot;:&quot;C&quot;,&quot;industry[3]&quot;:&quot;D&quot;,&quot;industry[4]&quot;:&quot;E&quot;,&quot;industry[5]&quot;:&quot;F&quot;,&quot;industry[6]&quot;:&quot;G&quot;,&quot;industry[7]&quot;:&quot;H&quot;,&quot;industry[8]&quot;:&quot;I&quot;,&quot;industry[9]&quot;:&quot;J&quot;,&quot;industry[10]&quot;:&quot;K&quot;,&quot;industry[11]&quot;:&quot;L&quot;,&quot;industry[12]&quot;:&quot;Z&quot;}s = requests.Session()res = s.post(url, data = payload)完整的程式碼",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/06/30/Python-%E7%88%AC%E8%9F%B2-%E4%B8%8D%E5%90%8C%E7%9A%84Content-Type-multipart-form-data/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "r-2017-06-27-r-e9-a1-af-e7-a4-ba-e5-ae-8c-e6-95-b4-e6-95-b8-e5-ad-97-e4-b8-8d-e9-a1-af-e7-a4-ba-e7-a7-91-e5-ad-b8-e8-a8-98-e8-99-9f": {
      "title": "[R]顯示完整數字，不顯示科學記號",
      "content"	 : "只要輸入，調整可顯示的位數options(scipen = 999)就可以改為顯示完整數字",
      "url": " /r/2017/06/27/R-%E9%A1%AF%E7%A4%BA%E5%AE%8C%E6%95%B4%E6%95%B8%E5%AD%97-%E4%B8%8D%E9%A1%AF%E7%A4%BA%E7%A7%91%E5%AD%B8%E8%A8%98%E8%99%9F/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2017-06-22-r-error-when-saving-xlsx-workbook-with-package-openxlsx": {
      "title": "[R]Error when saving xlsx workbook with package openxlsx",
      "content"	 : "如果在windows系統使用saveWorkbook()出現以下錯誤訊息Error: zipping up workbook failed. Please make sure Rtools is installed or a zip application is     available to R.Try installr::install.rtools() on Windows.installr::install.rtools()No need to install Rtools - You&#39;ve got the relevant version of Rtools installedsaveWorkbook(wb, file = &quot;dq&quot;, overwrite = TRUE)Error: zipping up workbook failed. Please make sure Rtools is installed or a zip application is available to R.Try installr::install.rtools() on Windows.1.安裝Rtools.exe2.找到Rtools底下的zip.exe路徑，並設定rools的zip.exe路徑即可解決此問題Sys.setenv(&quot;R_ZIPCMD&quot; = &quot;C:/Rtools/bin/zip.exe&quot;) ## path to zip.exe",
      "url": " /r/2017/06/22/R-Error-when-saving-xlsx-workbook-with-package-openxlsx/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-05-18-python-e7-88-ac-e8-9f-b2-e5-88-a9-e7-94-a8python-e4-b8-8b-e8-bc-89zip-e6-aa-94-e4-b8-a6-e8-a7-a3-e5-a3-93-e7-b8-ae": {
      "title": "[Python][爬蟲]利用python下載zip檔並解壓縮",
      "content"	 : "下載檔案是使用package urllib2解壓縮檔案則是使用package zipfile# 下載與解壓縮 財政部財政資訊中心-全國營業(稅籍)登記資料集 http://data.gov.tw/node/9400import urllib2 #urllib2.urlopen import zipfile #zipfile.ZipFiledef DownloadTWCompany():# 檔案下載print &quot;下載全國營業(稅籍)登記資料集壓縮擋...&quot;downloadurl = urllib2.urlopen(&#39;http://www.fia.gov.tw/opendata/bgmopen1.zip&#39;)zipcontent= downloadurl.read()with open(&quot;TWRAW.zip&quot;, &#39;wb&#39;) as f:    f.write(zipcontent)print &quot;下載完成!&quot;# 解壓縮檔案print &quot;資料解壓縮...&quot;with zipfile.ZipFile(open(&#39;TWRAW.zip&#39;, &#39;rb&#39;)) as f:f.extractall(&quot;.&quot;, pwd = &quot;1234&quot;)  # 解壓縮密碼1234print &quot;解壓縮完成!&quot;DownloadTWCompany()",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/05/18/Python-%E7%88%AC%E8%9F%B2-%E5%88%A9%E7%94%A8python%E4%B8%8B%E8%BC%89zip%E6%AA%94%E4%B8%A6%E8%A7%A3%E5%A3%93%E7%B8%AE/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-05-17-python-e7-88-ac-e8-9f-b2-e5-a6-82-e4-bd-95-e5-88-aa-e9-99-a4-e7-b6-b2-e9-a0-81-e4-b8-ad-e7-9a-84": {
      "title": "[Python][爬蟲]如何刪除網頁中的 &amp; nbsp;",
      "content"	 : "在爬取網頁時偶爾會碰到&amp;amp;nbsp;而且怎麼樣都刪不掉也取代不掉，使用strip()仍然會有空白。「&amp;amp;nbsp;」 是屬於 HTML 的特殊符號之一「空格符號」，其 nbsp 取自於英文 a non-breaking space 的英文簡稱，其原意是「不會被間斷的空白」假如現在有一個網頁內容包含&amp;lt;td&amp;gt;E601010&amp;amp;nbsp;電器承裝業&amp;lt;br&amp;gt;E601020&amp;amp;nbsp;電器安裝業&amp;lt;br&amp;gt;&amp;lt;/td&amp;gt;已經抓出td tag，接著可以使用td = td.encode(formatter=&quot;html&quot;)這時候td type會變成str，再使用replace取代就可以刪除空白了。",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/05/17/Python-%E7%88%AC%E8%9F%B2-%E5%A6%82%E4%BD%95%E5%88%AA%E9%99%A4%E7%B6%B2%E9%A0%81%E4%B8%AD%E7%9A%84/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-05-05-python-e7-88-ac-e8-9f-b2-e4-b8-8d-e5-90-8c-e7-9a-84content-type-application-json": {
      "title": "[Python][爬蟲]不同的 Content-Type (application/json)",
      "content"	 : "目標是爬取 http://waste.epa.gov.tw/WasteConfigure/VocationCode.asp所有的行業代碼與中文名稱。按下一頁發現會load一個post的網址接著想要在headers裡找到 “Form Data”，這裡面應會藏著post需要的參數。可是，這時候卻只有找到 “Requests Payload”，這個看起來很像payload的東西，它看起來是個json，且Response Headers的Content-Type正是application/json。所以我將 “Requests Payload”按下view source後的結果直接複製，然後requests結果再用json.loads就可以得到想要的結果了。程式碼如下，# -*- coding:utf-8 -*-# 爬取 http://waste.epa.gov.tw/WasteConfigure/VocationCode.asp 行業代碼(4碼)import requestsimport json# payload for requestspayload = &#39;{&quot;Cond&quot;:{&quot;KeyWord&quot;:&quot;&quot;,&quot;Paging&quot;:{&quot;Size&quot;:519,&quot;Current&quot;:1,&quot;Count&quot;:52,&quot;RecordCount&quot;:519,&quot;CanPrev&quot;:false,&quot;CanNext&quot;:true}}}&#39;headers = {&quot;Content-Type&quot;:&quot;application/json&quot;,   &quot;Referer&quot;:&quot;http://waste.epa.gov.tw/WasteConfigure/VocationCode.asp&quot;}url = &quot;http://waste.epa.gov.tw/NRS40/_ws/JsApI/CodeQuery.asmx/Vocation&quot;res = requests.post(url, data = payload, headers = headers)js = json.loads(res.text)for i in js[&quot;d&quot;][&quot;Result&quot;]:code = i[&quot;Code&quot;]name = i[&quot;Name&quot;].encode(&quot;utf-8&quot;, &quot;ignore&quot;)print code",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/05/05/Python-%E7%88%AC%E8%9F%B2-%E4%B8%8D%E5%90%8C%E7%9A%84Content-Type-application-json/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "r-2017-04-24-r-e5-9c-a8r-e4-b8-ad-e4-bd-bf-e7-94-a8system-e5-91-bc-e5-8f-abpython-e7-b5-a6-e4-ba-88-e5-8f-83-e6-95-b8": {
      "title": "[R]在R中使用system呼叫python-給予參數",
      "content"	 : "之前介紹過在R中使用system呼叫python。system(&quot;python python_script.py&quot;)假如現在我想要帶入參數給python script要怎麼做呢？首先，在python程式碼的部分，要使用 sys.arg[] 讓python程式獲取參數。還有，在 sys.arg[0] 表示的是程式名稱，所以要使用 sys.arg[1] 才是表示要讀取的第一個參數。假如今天有支 python_script.py# -*- coding: utf-8 -*-import sysstring = &quot;Hello, &quot; + sys.argv[1]print string在cmf中呼叫這支python程式python python_script.py worldR裡的system()要打的指令就是cmf中打的指令。所以在R中就會變成，system(&quot;python python_script.py world&quot;)結果就會變成Hello, world最後，在使用system()必須要先setwd將路徑設成python_script.py所在位置。",
      "url": " /r/2017/04/24/R-%E5%9C%A8R%E4%B8%AD%E4%BD%BF%E7%94%A8system%E5%91%BC%E5%8F%ABpython-%E7%B5%A6%E4%BA%88%E5%8F%83%E6%95%B8/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2016-08-24-r-e8-a8-ad-e5-ae-9ar-e5-9c-96-e5-bd-a2-e5-ad-97-e9-ab-94": {
      "title": "[R]設定 R 圖形字體",
      "content"	 : "一開始碰到需要調整圖形字體是在使用windows的自動排程時字體變成框框，以下的解法是針對windows方能使用。  使用windowsFonts函數將要使用的字體賦予一個值。    windowsFonts(BL = windowsFont(&quot;微軟正黑體&quot;))        在圖形中設定family。(1)使用par()在最一開始設定。par(family = &quot;BL&quot;)sales &amp;lt;- c(11, 13, 16, 10, 19)plot(sales, main = &quot;RWEPA公司102年1月至6月銷售統計圖&quot;,      type = &quot;b&quot;, xlab = &quot;月份&quot;, ylab = &quot;銷售金額（萬元)&quot;)(2) 在plot中設定sales &amp;lt;- c(11, 13, 16, 10, 19)plot(sales, main = &quot;RWEPA公司102年1月至6月銷售統計圖&quot;,      type = &quot;b&quot;, xlab = &quot;月份&quot;, ylab = &quot;銷售金額（萬元)&quot;, family = &quot;BL&quot;)(3) 在ggplot中設定library(ggplot2)ggplot(data.frame(x = rnorm(100))) +    geom_histogram(aes(x), fill = &quot;purple&quot;, alpha = 0.6) +    labs(x = &quot;取值&quot;, y = &quot;頻數&quot;) +    theme(text = element_text(family = &quot;BL&quot;))其實，family後是可以直接放要設定的字體完整名稱，不需定windowsFonts，只是假如字體名稱很長，便不需要一再地打上那麼長的名稱，如此以來便也適用mac。",
      "url": " /r/2016/08/24/R-%E8%A8%AD%E5%AE%9AR%E5%9C%96%E5%BD%A2%E5%AD%97%E9%AB%94/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2016-07-17-r-r-batch": {
      "title": "[R]R batch",
      "content"	 : "R batch因為.R檔無法點兩下就能執行，所以儲存一個R batch，再使用工作排程設定時間，就可以在固定時間自動執行程式。以下是在windows中的寫法，必須要先給R儲存的位置，後面放R script的位置。C:Program FilesRR-3.2.5binR.exe&quot; CMD BATCH &quot;C:UsersmypcDesktopmyrscript.R&quot;將上面的程式碼貼在記事本(確認R的版本和位置)，再將記事本副檔名存成.bat 就完成了。",
      "url": " /r/2016/07/17/R-R-batch/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "others-2016-07-17-windows7-e8-87-aa-e5-8b-95-e6-8e-92-e7-a8-8b": {
      "title": "Windows7 自動排程",
      "content"	 : "工作排程，讓程式自動執行開始 =&amp;gt; 附屬應用程式 =&amp;gt; 系統工具 =&amp;gt; 工作排程器建立基本工作 =&amp;gt; 建立基本工作、觸發程序、執行、完成",
      "url": " /others/2016/07/17/windows7%E8%87%AA%E5%8B%95%E6%8E%92%E7%A8%8B/",
      "author": "Shihs",
      "categories": "Others"
    }
    ,
  

    "r-2016-07-17-r-e4-bd-bf-e7-94-a8r-e7-99-bc-e9-80-81email": {
      "title": "[R]使用 R 發送gmail Email",
      "content"	 : "使用mailR package寫一個R的script，自動發信。以下幾個步驟，1.啟用安全性較低的應用程式存取2.使用mailR packagelibrary(mailR)send.mail(from = &quot;mymail@gmail.com&quot;,  # 寄件者          #收件者          to = c(&quot;receive1@gmail.com&quot;,                  &quot;receive2@gmail.com&quot;),          #標題          subject = &quot;測試&quot;,          #內文          body = &quot;這是一個測試&quot;,           encoding = &quot;utf-8&quot;,  # 編碼          #夾帶檔案          attach.files = c(&quot;attach.xlsx&quot;),          smtp = list(host.name = &quot;smtp.gmail.com&quot;,                       port = 465,                       user.name = &quot;mymail@gmail.com&quot;,                       passwd = &quot;mypasswd&quot;,                       ssl = TRUE),          authenticate = TRUE,          send = TRUE)另外，我其實還有查到gmailr這個package，但它有些bug，無法同時有信件內文又有夾帶檔案，所以目前找到最好的方式還是使用mailR。",
      "url": " /r/2016/07/17/R-%E4%BD%BF%E7%94%A8R%E7%99%BC%E9%80%81email/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "python-2016-07-08-python-e4-bd-bf-e7-94-a8python-e4-b8-8b-e8-bc-89gmail-e9-99-84-e4-bb-b6": {
      "title": "[Python]使用 python 下載 gmail 附件",
      "content"	 : "每天都會收到信並且要利用信中的附件整理資料，但這樣我在跑程式前還要手動去下載檔案，覺得實在太麻煩，所以找到了這個辦法！因為我的mail是gamil，所以以下的程式碼是針對gmail，在執行前要先打開imap我主要是參考這裡import imaplib, inspectimport emailimport osfrom datetime import datetimefrom email.header import decode_headerinspect.getmro(imaplib.IMAP4_SSL)#與IMAP4 server連線，gmail要開啟IMAPimap = imaplib.IMAP4_SSL(&#39;imap.gmail.com&#39;) #登入imap.login(&#39;mymailaddress@gmail.com&#39;, &#39;mypasswd&#39;)#選擇信箱標籤imap.select(&quot;label&quot;)#找所有mailresp, mails = imap.search(None, &quot;ALL&quot;)#讀取信件內容，只抓取最新一封信件(len(mails[0].split())-1)resp, data = imap.fetch(mails[0].split()[len(mails[0].split())-1], &#39;(RFC822)&#39;)emailbody = data[0][1]mail = email.message_from_string(emailbody)#找出含有附件的部分for part in mail.walk():if part.get_content_maintype() == &#39;multipart&#39;:continueif part.get(&#39;Content-Disposition&#39;) is None:continue#附件檔名fileName = part.get_filename()  #修改檔名編碼&amp;lt;http://stackoverflow.com/questions/11206489/how-to-print-next-year-from-current-year-in-python&amp;gt;fileName = str(datetime.now().year - 1911) + str(decode_header(fileName)[0][0]).decode(decode_header(fileName)[0][1])if bool(fileName):filePath = os.path.join(&quot;C:UsersmypcDesktopdata&quot;, fileName)if not os.path.isfile(filePath) :fp = open(filePath, &#39;wb&#39;)fp.write(part.get_payload(decode=True))fp.close()print &quot;attachement is downloaded!&quot;else:print &quot;file is already exist!&quot;#關閉連線與登出imap.close()imap.logout()",
      "url": " /python/2016/07/08/Python-%E4%BD%BF%E7%94%A8python%E4%B8%8B%E8%BC%89gmail%E9%99%84%E4%BB%B6/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "r-2016-07-08-r-e5-9c-a8r-e4-b8-ad-e4-bd-bf-e7-94-a8system-e5-91-bc-e5-8f-abpython": {
      "title": "[R]在 R 中使用 system 呼叫 python",
      "content"	 : "我個人比較偏好使用R做所有的事情，但某些時候還是需要使用到python，所以希望可以在R上呼叫python程式碼。一開始我找到了rPython這個library，但它似乎無法在windows上使用……所以我又找到了另一個不需要安裝任何套件且可以在windows上執行的辦法！system(&quot;python python_script.py&quot;)這個辦法是呼叫系統函數，就像是在cmd上面打的指令一樣，而且在mac上也可以執行！",
      "url": " /r/2016/07/08/R-%E5%9C%A8R%E4%B8%AD%E4%BD%BF%E7%94%A8system%E5%91%BC%E5%8F%ABpython/",
      "author": "Shihs",
      "categories": "R"
    }
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
}