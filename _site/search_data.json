{
  

    "machine-20learning-2019-03-12-machine-learning-markov-chain-monte-carlo-mcmc": {
      "title": "[Machine Learning]Markov Chain Monte Carlo (MCMC)",
      "content"	 : "MCMC 是什麼？Markov Chain Monte Carlo （MCMC）是一種抽樣方法，用來解決無法直接抽樣的分佈的隨機抽樣問題。The Goal of MCMCWe want to sample from some distribution p, or approximate an 通常 p 是一個很複雜的 distribution，要從這個分佈取 sample 根本不可能，所以這時候就會需要 MCMC。為什麼要使用 MCMC？在 Baysian Inference 中常使用到這個公式或是，它的參數  的貝式估計其中的  為先驗機率 (prior probability)，基本上我們無法獲得  的值，這時候就需要 MCMC。MCMC 由兩部分的觀念 (步驟) 組成, 一個是 「Markov Chain」 ，另一個則是「Monte Carlo integration」，接下來將說明這兩個部分。Monte Carlo IntegrationMonte Carlo Integration 可以以抽樣平均的方式計算上面的期望值式子也就是說，使用樣本平均數來估計期望值。這件事情可以成立是因為，根據大數法則，當樣本數 n 夠大時，樣本的平均數將趨近於母體平均數。這樣看起來 Monte Carlo Integration 讓我們省去了上面那個看起來複雜的積分式子。但是，現實生活中很多時候並無法從  這個 distribution 抽樣，要不就是不知道這個 distribution，要不就是這個 distribution 爆炸複雜啊。所以說，哪有這麼好的事？這時候可以採用其他的抽樣方法，譬如，rejection sampling, importance sampling 和本文的重點 MCMC。Markov Chain      Markov Chain (馬可夫鍊)：A Markov chain is a sequence  of random variables such that the distribution of the next value depends only on the current on (and parameters). 現在有一隨機變數數列 ，且每一個變數只和前一個變數有關，也就是  來自 ，像這樣的數列我們就稱為馬可夫鍊。         被稱為這個馬可夫鍊的轉換核心 (transition kernel)        A Markov chain is stationary, with stationary distribution         One shows (not trivial in general) that under certain conditions a Markov chain will converge to the stationary distribution in the limit. 在一般條件假設底下，馬可夫鍊的變數分配將收斂到目標機率函數  並且與  的選擇無關。  Monte Carlo Integration可以看這裡Reference:(ML 18.1) Markov chain Monte Carlo (MCMC) introduction-12eZWG0Z5gY.mp4The Markov Chain Monte Carlo Simulations Linköping University - 732A90 Computational Statistics 2019 Lecture 4 slide[数据分析] Markov Chain Monte Carlo徐亦达机器学习课程 Markov Chain Monte CarloMCMC(一)蒙特卡罗方法",
      "url": " /machine%20learning/2019/03/12/Machine-Learning-Markov-chain-Monte-Carlo-(MCMC)/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2019-03-02-machine-learning-covolutional-neural-networks-cnn-2": {
      "title": "[Machine Learning]Covolutional Neural Networks(CNN)(2)",
      "content"	 : "前面介紹了 Convolution operation。  Padding  Strided Convolution  Convolutions Over Volume***Padding為什麼需要 Padding?Convolution operation 的缺點：  經過 convolution fitler 後原始圖將變小。如果有很多層 convolutional layer，資訊在每次運算後不斷損失。  最邊緣的 pixel 只會被使用到一次，但中間的 pixel 會使用到較多次。也就是說，會有邊緣的很多資訊缺失。所以為了解決以上的缺點，我們將 input 的圖的邊緣加上一個 pixel，這樣經過卷積運算後的圖像仍和原圖一樣大。邊緣也是可以加 2 pixel 的。以上圖為例，原本為 6x6(nxn) 的圖，經過 3x3(fxf) 的 filter 做卷積運算後，變為 (n-f+1)x(n-f+1) 的圖。但如果今天邊緣加上 p pixel，最後圖檔就會變為 (n+2p-f+1)x(n+2p-f+1) 的圖。The choice of padding - Vaild and Same convolutions  Vaild - No padding  Same - Pad so that output size is the same as the input size根據上面的公式，如果在 input 圖邊緣加上 pixel 後經過卷積運算要和原始圖檔大小ㄧ樣，那要符合 n+2p-f+1 = n，那就會得到 p = (f-1)/2For computer vision, usually f is odd. 3 by 3 filters are very common.Strided Convolution前面我們在做 convolution 時 filter 都是一次跳一格計算，strided 則是一次跳不只一格。如下圖，這時候最後結果的 pixel 也會不同，計算公式就會是 ((n+2p-f)/2)+1 取 floor。cross-correlation vs. convolution  cross-correlation：數學家喜歡將 convolutional operation 稱為 cross-correlation。在做運算時會將 filter 做水平與垂直翻轉，如下圖。  convolution：在 deep learning 通常都稱為 convolution，且不會將 filter 做鏡射的動作。那這樣幹嘛要翻轉？因為在做訊號處理時，翻轉後會有一些好的特性可以拿來使用。但在做 deep learning 時基本上沒有影響，所以做 deep learning 時不會翻轉 filter。Convolutions Over VolumeConvolutions on RGB impages前面舉的例子都是在 2D 上計算 convolution，現在要來看如何在 3D 上實現 convolution。Reference:Coursera - Convolutional Neural Networks(deeplearning.ai)",
      "url": " /machine%20learning/2019/03/02/Machine-Learning-Covolutional-Neural-Networks(CNN)(2)/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "algorithm-2019-03-02-algorithm-e5-9f-ba-e5-9b-a0-e6-bc-94-e7-ae-97-e6-b3-95genetic-algorithm": {
      "title": "[Algorithm]基因演算法Genetic Algorithm",
      "content"	 : "基因演算法（Genetic Algorithm）是一種求函數極值的最佳化（函數的最大或最小值）的方法。它的想法是來自於基因遺傳，透過細胞分裂將好的基因保留，不好的基因淘汰，一代傳一代，最後留下最適合生存的物種，所謂「適者生存」。實現的方式就像基因的機制那樣，透過隨機選擇後，再進行 crossover 和 mutation，經過多次迭代後，最後結果將會收斂到一個最佳解。但這最佳解不ㄧ定是 global maximum（minimum），通常是 local maximum（minimum）。（但其實這與基因的真實行為完全無關，就像是 Neural Network 和人類神經反應的真實行為無關一樣。）演算法流程圖Source  一開始隨機產生n個變數 (n由使用者決定)  利用適應函數（fitness function）計算所有變數的適應值  依每個的適應值進行「選擇、複製」  對留下的變數進行交配（crossover）及突變（mutation）的動作範例以下範例是來自演算法筆記的 Optimization1.[初始化]一開始先隨便弄出幾個x。本例是四個。10101010101011001011111010101100101010002.[fitness function]根據問題特性，定義好壞程度。f(1010101010) = 6783.[selection]隨便找個位置切一刀，每個x都被分成兩段。1010101  0101011001  0111110101  0110010101  0004.[crossover]隨便找兩組你覺得夠優良的x，交叉相接變成新答案。重複一直做，直到x數目跟原先一樣多。本例是四個。1010101 / 010  -&amp;gt;  1010101 -- 0111011001 / 011      1011001 -- 010 10101010111011001010111010101010101010005.[mutation]每個x都隨便找一個地方把數字改掉，也可以不改。10101110111011001000111010101010101010016.重複3. 4. 5.，直到裡面有一個x是你滿意的，令f(x)最大的那個x。  隨機產生N個x。  計算fitness function。  重複以下步驟，直到有一個x讓人滿意。　甲、selection。　乙、crossover。　丙、mutation。　丁、計算fitness function。一開始的 x 的足夠豐富，多演化幾次就可以得到不錯的結果。一開始的 x 足夠豐富，可以避免進入區域極值。 mutation 用於增加 x 的豐富性，以跳脫區域極值。Reference:演算法筆記 - OptimizationGenetic Algorithm 基因演算法人工智慧系列之基因演算法",
      "url": " /algorithm/2019/03/02/Algorithm-%E5%9F%BA%E5%9B%A0%E6%BC%94%E7%AE%97%E6%B3%95Genetic-Algorithm/",
      "author": "Shihs",
      "categories": "Algorithm"
    }
    ,
  

    "python-2019-02-27-python-filter-map-reduce-lambd": {
      "title": "[Python]filter、map、reduce、lambda",
      "content"	 : "  lambda 可以直接定義一些簡單的 funciton。  filter、map和reduce這三個函數有點像 R 裡頭的 apply 家族系列。lambda我其實覺得就是定義 funciton，只是是定義一些簡單，可以一行完成的 funciton。# 回傳輸入的變數 + 1fun = lambda x: x + 1print (fun(3))# 上面的 func 其實就等於def fun(x):  return x+1# 輸入兩個變數fun = lambda x, y: x+yprint (fun(3, 5))# 含 iffun = lambda x: True if x % 2 == 0 else Falseprint (fun(3))filter(function, sequence)對 sequence 中的 item 依序執行 function(item)，然後將執行結果為 True 的 item 組成一個 list/string/tuple（與 sequence 類型相同）回傳。這時候 function 可以使用 lambda 定義或是平常的 def 定義。# 回傳是數字，除 0 外都是 Truefun = lambda x: x-1print (filter(fun, range(3)))# function 為 defdef f(x): return x % 2 != 0 and x % 3 != 0 print (filter(f, range(2, 25)) )# function 為 lambdaf = lambda x: x % 2 != 0 and x % 3 != 0 print (filter(f, range(2, 25)) )map(function, sequence)對 sequence 中的 item 依序執行 function(item)，執行結果以 list 回傳。# funciton 只有一個參數res = map(lambda x: x**2, range(1, 11))print (res)# 每次都回傳 1res = map(lambda i: 1, range(1, 11))print (res)# function 有兩個參數res = map(lambda x, y: x*y, range(1, 11), range(2, 12))print (res)reduce(function, sequence, starting_value)對 sequence 中的 item 順序迭代調用 function，最後回傳一個值。from functools import reduce # 在 python3 是必須的# 求 list 的和res = reduce(lambda x, y: x+y, range(1, 10))print (res)Reference:Python特殊语法：filter、map、reduce、lambda [转]",
      "url": " /python/2019/02/27/Python-filter-map-reduce-lambd/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "machine-20learning-2019-02-25-machine-learning-reinforcement-learning": {
      "title": "[Machine Learning]Reinforcement Learning",
      "content"	 : "複習機器學習可以被分為三大類：      Supervised Learning:Learn to generalize and classify new data based on labelled training data. 像是 regression 和 classification 就屬於 Supervised Learning。        Unsupervised Learning:Discover structure and relationships in complex high-dimensional data. 像是 cluster。        Reinforcement Learning:Generate policies/strategies that lead to a (possibly delayed) reward. Learn by interacting with the environment! 和人類學習的過程很像，會根據環境而行動，並做調整（像是學騎腳踏車）。這篇主要就是要介紹 Reinforcement Learning。  Reinforcement Learning 可以做什麼？  2016 年 AlphaGo 擊敗世界棋王使用的就是 Reinforcement Learning  Robot Learns to Flip Pancakes  pole balancingDifferences to other methods  Difference to supervised learning          Time! Reinforcement Learning 的學習時間會比 Supervised Learning 費時（當然要有缺點，不然大家幹嘛還要用 Supervised Learning），所以如果有 labels 通常還是會選用 Supervised Learning，但當事前沒有 labels，不知道結果的時候就可以使用 Reinforcement Learning。      Can become better than the system designer, unlike a supervised system that can never become better than the teacher. 因為 Supervised Learning 是根據 system designer 給的 labels 下去計算，但 Reinforcement Learning 是機器自己學習所獲得的結果，就像是，雖然教練教學生打球，但學生的學習成果可能比教練還好。      Feedback is usually not immediate but is given after many actions - delayed feedback! 像是下棋，要等到結果贏或輸才會知道是得到 positive reward 還是 negative reward。      Feedback is given as a scalar reward, not as the correct action to make. Supervised Learning 的 feedback 是結果是否正確，但 Reinforcement Learning 得到的 feedback 是 reward（can be positive or negative）。        Difference to control theory          No physical model of the world, e.g., in pole balancing      機器怎麼學？不像 Supervised Learning 有 lable 可以知道結果是正確還是錯誤， Reinforcement Learning 的學習方法是透過 reward 來知道學習結果正確或不正確（就像是狗狗學習技能，如果做對了就給東西吃一樣）。所以透過打分數的結果來知道怎麼樣的行為是正確的而進行調整，往正確的學習道路邁進。（所以每次學習結果所獲得的 reward 就變得有點像是 Supervised Learning 的 labels 的感覺，只是這個 labels 是從學習的過程中獲得的）Reinforcement Learning 如何進行？Reinforcement Learning 問題的基本設定&amp;lt;A, S, R, P&amp;gt;  Action space : A  State space : S  Reward: R : S × A × S → R  Transition : P :S × A → SA 代表的是 Agent 的所有動作（action）；S 是 state，是 Agent 所能感知的狀態； R 是 reward 代表獎勵或懲罰，是一個實數；P 是 Agent 所交互的世界，也被稱為 model。根據上圖（Source），電腦是 agent，地球代表 environment（環境），reward（獎勵）是環境所提供的反饋，reward 由模型設計者定義，可以是 positive 或是 negative，reward 的定義對強化學習來說是個很重要的一環。PolicyPolicy 就是 agent 根據每個 state 所做出的不同的 action，也就是根據不同的狀態 agent 會採取不同的「策略」。定義為 ，是 RL（Reinforcement Learning） 最核心的問題。可以將 policy 看成是當 agent 感知到 state(S) 採取 action(A) 的 mapping。policy 可以分為隨機的（stochastic policy）和確定性的（deterministic policy）。  stochastic policy:   deterministic policy: RewardReward 是 RL 非常重要的一環，沒有 reward，agent 就不會知道到底學習正確還是錯誤。透過 reward，agent 才知道剛剛採取的 action 好不好。以下圖（Source）為例，最一開始的 state 是 ，agent 做了  的 action，這時候產生了一個 reward ，然後因為剛剛的  這時候 state 來到 ，而 agent 要採取下一步  的時候就會根據剛剛的  來反應。agent 就這樣一步一步根據 reward 的結果來學習。但其實並不是所有的學習都會像這個例子一樣立即獲得 reward，像下棋就會是整局結束後才得到 reward。另外，需要注意的是，Reward  Goal。也就是說，agent 的目標並不是「當前」reward 最大，而是「平均累計」回報最大。總結來說，Reinforcement Learning 的目標就是找到一個最佳的 Policy（策略），讓最後平均的 reward 最大！所以現在問題就來了，要如何衡量這個 policy 好不好？哪些 policies 是我們想要 explore 的？Value functionValue function - How good is a policy?定義從長期來看 action 平均回報的好壞。例如，象棋中吃掉對方的車看起來即時收益很大，但如果因為吃掉對方的車自己的將卻被吃了，那麼從長期看這個 action 就不是一個好的選擇。 表示的是策略 ，狀態 s 的長期期望收益。 是策略  在狀態 s 下，採取動作 a 的長期期望收益。      長期回報期望： （因為  介於 0 和 1 之間，所以 makes immediate rewards more important than distant rewards）        Value function：        Q function：  How to learn V(s)?      Monte Carlo approach        Temporal Difference approach  Summary  For a given policy, the value (expected reward) V(s) of each state is unknown before we learn it by interacting with the environment.  V(s) is found iteratively, starting for example with V(s)←0, using the Monte Carlo or Temporal Difference methods.  The Temporal Difference method generally converges much faster.Q-LearningWhich policies should we explore?上面介紹了 V(s) 是狀態 s 的長期期望收益，那 agent 要如何決定根據它來決定要做什麼 action 採取什麼 policies 呢？這時候我們就會加上 action 這個變數來看，也就是上面提到的 Q(s, a)。   denote the value function for the optimal policy   is expected future reward of doing action a in state s and then following the optimal policy    未知，必須透過學習得到。,  is learning rate這篇文章翻譯了這個原文，我覺得非常好理解。但要整篇整理在這裡太麻煩了，所以自己看吧。Reference:Linköping University Neural Networks and Learning Systems TBMI26 / 732A55 2019 Lectures.深度强化学习（Deep Reinforcement Learning）入门：RL base &amp;amp; DQN-DDPG-A3C introductionwikipedia - 強化學習強化學習 Reinforcement Learning莫凡python[機器學習 ML NOTE] Reinforcement Learning 強化學習(DQN原理)如何用简单例子讲解 Q - learning 的具体过程？A Painless Q-learning Tutorial (一个 Q-learning 算法的简明教程)",
      "url": " /machine%20learning/2019/02/25/Machine-Learning-Reinforcement-Learning/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2019-02-25-machine-learning-covolutional-neural-networks-cnn": {
      "title": "[Machine Learning]Covolutional Neural Networks(CNN)(1)",
      "content"	 : "這篇為 Coursera 上 Convolutional Neural Networks 這門課第一週的 Computer Vision、Edge Detection Example 和 More Edge Detection 筆記。前言：因為 Deep Learning 的快速發展，所以電腦視覺（computer vision）這幾年也迅速的超展開。像是自動駕駛就受惠於 computer vision 的進步，讓自駕車能更準確的偵測路人和其他車輛，提升安全性；或是人臉辨識系統也變得更厲害，像是手機的人臉辨識解鎖；或是使用 Deep Learning 辨別照片是屬於風景照、人、動物還是車輛等等（像是 iphone 的相簿現在就很變態的會自動歸類照片是什麼）；甚至在藝術作品上都有 Deep Learning 的蹤影。為什麼要使用 Covolutional Neural Networks(CNN)？Computer Vision Problem以上圖的例子來看，第一張是 64x64 的照片，第二張畫素則是 1000x1000，這時候如果再加上 RGB 三原色的維度，兩張照片的維度分別會是 64x64x3 和 1000x1000x3。以 Neural Network 來實作的話（右下角），input layer 的 Xn 的 n = 1000x1000x3，如果第一層的 hidden 是 1000 個 nodes，這時候轉換的 W 的維度就會是 1000x3000000，這是不是很 CRAZY？所以這時候就會碰到以下的問題。缺點  很難避免 overfitting  計算上需要大量的電腦效能和 CPU，實在太不切實際了因此，為了解決的這個問題，我們就需要用到 CNN。CNN 的流程圖SourseHow the convolution operation works?現在先來看 convolutional layer 的部分，也是 CNN 非常重要的一個環節。這邊使用 Edge detection 作為範例操作 convolution operation 是如何運作的。Edge detection example在辨識下圖時我們可能會想要做垂直的邊緣辨識和水平的邊緣辨識。那要如何操作呢？Vertical edge detection最左邊的圖是一張 6x6 pixel 的黑白圖，每個 pixel 的數字表示灰階的深度，數字越小代表顏色越深。中間是一個 3x3 的 filter，在有些地方會被稱為 kernel，但這門課都會稱作 filter。這樣的兩個 matrix 做 convolution 運算後（用 * 表示），會產生一個 4x4 的 matrix。運算方法則是，將 3x3 的 filter 與圖片的左上方 match（如圖片淺藍底），對應到的格子相乘，最後再將九個數字相加。依序移動 3x3 的 filter，如此最後就會產生一個 4x4 的 matrix。而中間的 filter 可以看到是一個由左至右從淺到深的圖。因為現在做的是 Vertical edge detection，所以才會選擇這樣的 filter。再看一個例子，我們可以看到，最右邊最後產生的是一個中間一條白色的圖，這就偵測到了我們的想找垂直邊緣的圖（最左邊）的正中間有個邊界。（這個例子看起來邊緣很寬，是因為我們這個圖只有 6x6，如果今天用大一點的圖 1000x1000 就會發現這樣的偵測效果是很好的）Different transitions剛剛的例子是由亮到暗（上），現在的例子是由暗到亮（下），會發現時候最後運算出來的 matrix 也會不同，根據中間的數字我們可以知道，這張圖是由亮到暗還是由暗到亮。下圖的中間偵測得到邊緣數字是 -30，如果今天需要偵測的結果需要知道深淺的變化，那數字就是重要的，但如果今天只是要抓邊緣，也可以將 -30 取絕對值，一樣能抓到轉換的邊界。Vertical and horizontal edge detection看完了垂直的範例，我們再看一下偵測水平邊緣的 filter。Different filters從上面的結果可以發現，不同的 filter 可以讓我們偵測出不同的狀況。這邊提了一下兩個 filter，Sobel filter 和 Scharr filter。其實我們可以不需要直接使用現成的 filter，而是可以訓練出一個 filter 針對我們的需求，這之後會再提。Reference:Coursera - Convolutional Neural Networks(deeplearning.ai)",
      "url": " /machine%20learning/2019/02/25/Machine-Learning-Covolutional-Neural-Networks(CNN)/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "others-2019-01-22-ascii-unicode-e5-92-8c-utf-8": {
      "title": "字元編碼，ASCII、Unicode、UTF-8",
      "content"	 : "關於編碼，相信大家很常聽到 ASCII、Unicode、UTF-8 這幾個名詞，這篇要根據我的理解來介紹這三個名詞。若有錯歡迎指正:)字元編碼電腦採用二進位的方式理解符號與文字，而將字元與二進位的 0 和 1 組合作轉換就是編碼的基礎。ASCIIASCII 是電腦早期發展時由美國制定的一套編碼規則，且沿用至今。ASCII 使用了 7 個 bits，包含字母大小寫、數字及一些符號共有 128 個字元被編入 ASCII 中。空白是 32(00100000)，字母 A 是 65(01000001)，以此類推。Extended ASCII但因為一個 byte 共有 8 個 bits，也就是說還有很多個位元並未使用到，所以後來又產生了 Extended ASCII。很多歐洲國家有一些字母並未在 ASCII 中，所以除了 ASCII 為固定的字元外，每個國家根據自己所需給與字元，但也造成每個國家並未統一編碼。Unicode隨著網際網路的發展，世界各國交換訊息，未統一的編碼便造成了很大的問題。這時候有了 Unicode 的誕生。Unicode 協會將所有的文字與符號都分配一個數字，這個數字的寫起來像是，U+0645，而這個數字就稱為，Code point。U+ 的意思是 Unicode，數字則是用十六進位表示。但 Unicode 編碼使用至少兩個位元儲存字元，若是今天只有英文，仍舊是每個字元使用兩個位元儲存，這表示浪費了很多的資源。所以這時候有有人想出了更好的辦法。UTF-8有人發明了 UTF-8 這種儲存方式。UTF-8 編碼把一個 Unicode 字元根據不同的數字大小編碼成 1-6 個字節，常用的英文本母被編碼成 1 個字節，漢字通常是 3 個字節。如果今天要傳輸的內容都是英文，這時使用用 UTF-8 編碼就能省下空間。比較Unicode 是一種編碼方式，和 ASCII 是同一個概念，而 UTF-8 是一種存儲方式，在存儲和傳輸上節約空間、提高性能的一種編碼形式Reference:字符编码笔记：ASCII，Unicode 和 UTF-8淺談電腦編碼與 Unicode (一) 基礎概念篇常見三種字符編碼的區別：ASCII、Unicode、UTF-8[轉錄] [doc] 每個軟體開發者都絕對一定要會的Unicode及字元集必備知",
      "url": " /others/2019/01/22/ASCII-Unicode-%E5%92%8C-UTF-8/",
      "author": "Shihs",
      "categories": "Others"
    }
    ,
  

    "python-2019-01-02-python-pyinstaller-e5-87-ba-e7-8f-be-e9-8c-af-e8-aa-a4-e8-a8-8a-e6-81-afattributeerror-type-object-pandas-tsobject-has-no-attribute-reduce-cython": {
      "title": "[Python]pyinstaller出現錯誤訊息AttributeError:type object pandas._TSObject has no attribute _reduce_cython_",
      "content"	 : "在打包含有 pandas 套件的程式碼時產生了以下的錯誤訊息，根據Hooks: Add hook-pandas.py to fix issue #2978. #2998的討論串，有人回答when run pyinstaller -F xxx.py in windows10 , I get error AttributeError: type object &#39;pandas._libs.tslib._TSObject&#39; has no attribute &#39;__reduce_cython__&#39;, and solve it by degrade pandas version to 0.20.0.我將 pandas 套件的版本降至 0.20.3 也確實解決問題了。先檢查一下 pandas 版本pip show pandas將版本降至 0.20.3pip install pandas==0.20.3這時候打包完後執行應該就不會有問題了！Reference:Hooks: Add hook-pandas.py to fix issue #2978. #2998成功解决pyinstaller打包AttributeError:type object pandas.TSObject has no attribute _reduce_cython",
      "url": " /python/2019/01/02/Python-pyinstaller%E5%87%BA%E7%8F%BE%E9%8C%AF%E8%AA%A4%E8%A8%8A%E6%81%AFAttributeError-type-object-pandas._TSObject-has-no-attribute-_reduce_cython_/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-2019-01-02-python-e8-ae-80-e5-8f-96-e8-88-87-e5-af-ab-e5-85-a5xlsx-e6-aa-94-e6-a1-88": {
      "title": "[Python]讀取與寫入xlsx檔案",
      "content"	 : "這裡要介紹使用 pandas 套件讀取與寫入 xlsx 檔案。在開始前請先安裝 pandas 套件，pip install pandas讀取檔案df = pd.read_excel(&quot;filename.xlsx&quot;, header = None)# 獲取列數rows = df.shape[0]# 獲取儲存格內容df.iat[1, 0]# 修改儲存格內容df.iloc[1, 0] = &quot;test&quot;# 但修改後必須要儲存才會修正檔案內容# df.to_excel(&#39;test_result.xlsx&#39;, sheet_name = &#39;sheet1&#39;)若在執行以上程式碼時產生錯誤訊息：Pandas pd.read_excel giving ImportError: Install xlrd &amp;gt;= 0.9.0 for Excel support這時候只要安裝 xlrd 套件就能解決問題。pip install xlrd寫入檔案import pandas as pd# Create a Pandas dataframe from some data.df = pd.DataFrame({&#39;Data&#39;: [10, 20, 30, 20, 15, 30, 45]})# Create a Pandas Excel writer using XlsxWriter as the engine.writer = pd.ExcelWriter(&#39;pandas_simple.xlsx&#39;, engine=&#39;xlsxwriter&#39;)# Convert the dataframe to an XlsxWriter Excel object.df.to_excel(writer, sheet_name=&#39;Sheet1&#39;)# Close the Pandas Excel writer and output the Excel file.writer.save()以上的程式碼是參考這裡。我存的檔案內容是中文，這時候產生了像這樣的錯誤訊息Python pandas to excel UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xe2 in position 11只要將 pd.ExcelWriter 裡的參數 engine=&#39;xlsxwriter&#39; 改成 engine=&#39;openpyxl&#39; 就可以了。Reference:Example: Pandas Excel examplePython: Pandas pd.read_excel giving ImportError: Install xlrd &amp;gt;= 0.9.0 for Excel supportPython pandas to excel UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe2 in position 11PYTHON pandas 操作Excel 基本介紹",
      "url": " /python/2019/01/02/Python-%E8%AE%80%E5%8F%96%E8%88%87%E5%AF%AB%E5%85%A5xlsx%E6%AA%94%E6%A1%88/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-2019-01-02-python-e5-85-a8-e5-bd-a2-e8-88-87-e5-8d-8a-e5-bd-a2-e8-bd-89-e6-8f-9b": {
      "title": "[Python]全形與半形轉換",
      "content"	 : "因為全形字元的 unicode 編碼從 65281~65374，而半形字元的 unicode 編碼從 33~126，也就是同樣的字在全形與半形數字會差 65248。例如，半形的驚嘆號（!）是 unicode 編碼是 33，則全形的驚嘆號（！）unicode 就會編碼是 33 + 65248 = 65281但要將數字解析成半形時是使用 chr() function，而全形則是使用 unichr() function。以下將 33~126 全部列出來，並轉換成全形。for i in xrange(33,127):print i, chr(i), i+65248, unichr(i+65248).encode(&quot;utf-8&quot;)結果，33 ! 65281 ！34 &quot; 65282 ＂35 # 65283 ＃36 $ 65284 ＄37 % 65285 ％38 &amp;amp; 65286 ＆39 &#39; 65287 ＇40 ( 65288 （41 ) 65289 ）42 * 65290 ＊43 + 65291 ＋44 , 65292 ，45 - 65293 －46 . 65294 ．47 / 65295 ／48 0 65296 ０49 1 65297 １50 2 65298 ２51 3 65299 ３52 4 65300 ４53 5 65301 ５54 6 65302 ６55 7 65303 ７56 8 65304 ８57 9 65305 ９58 : 65306 ：59 ; 65307 ；60 &amp;lt; 65308 ＜61 = 65309 ＝62 &amp;gt; 65310 ＞63 ? 65311 ？64 @ 65312 ＠65 A 65313 Ａ66 B 65314 Ｂ67 C 65315 Ｃ68 D 65316 Ｄ69 E 65317 Ｅ70 F 65318 Ｆ71 G 65319 Ｇ72 H 65320 Ｈ73 I 65321 Ｉ74 J 65322 Ｊ75 K 65323 Ｋ76 L 65324 Ｌ77 M 65325 Ｍ78 N 65326 Ｎ79 O 65327 Ｏ80 P 65328 Ｐ81 Q 65329 Ｑ82 R 65330 Ｒ83 S 65331 Ｓ84 T 65332 Ｔ85 U 65333 Ｕ86 V 65334 Ｖ87 W 65335 Ｗ88 X 65336 Ｘ89 Y 65337 Ｙ90 Z 65338 Ｚ91 [ 65339 ［92  65340 ＼93 ] 65341 ］94 ^ 65342 ＾95 _ 65343 ＿96 ` 65344 ｀97 a 65345 ａ98 b 65346 ｂ99 c 65347 ｃ100 d 65348 ｄ101 e 65349 ｅ102 f 65350 ｆ103 g 65351 ｇ104 h 65352 ｈ105 i 65353 ｉ106 j 65354 ｊ107 k 65355 ｋ108 l 65356 ｌ109 m 65357 ｍ110 n 65358 ｎ111 o 65359 ｏ112 p 65360 ｐ113 q 65361 ｑ114 r 65362 ｒ115 s 65363 ｓ116 t 65364 ｔ117 u 65365 ｕ118 v 65366 ｖ119 w 65367 ｗ120 x 65368 ｘ121 y 65369 ｙ122 z 65370 ｚ123 { 65371 ｛124 | 65372 ｜125 } 65373 ｝126 ~ 65374 ～Reference:Python實現全形半形字元互轉的方法",
      "url": " /python/2019/01/02/Python-%E5%85%A8%E5%BD%A2%E8%88%87%E5%8D%8A%E5%BD%A2%E8%BD%89%E6%8F%9B/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "machine-20learning-2018-12-27-machine-learning-linear-regression": {
      "title": "[Machine Learning]Linear Regression",
      "content"	 : "Linear Regression 屬於 Supervised Learning(監督式學習)，用來預測連續型(continuous)的變數。Simple Linear RegressionSimple Linear Regression 假設 (X, Y) 存在線性關係，且可以使用以下的式子來表示 (X, Y)的關係。  而現實中我們無法知道參數 (beta_0, beta_1)，這時候我們會使用 train data 找出估計參數 (hat{beta_0}, hat{beta_1})。簡單線性回歸的估計式可以寫成，  其中，(hat{y}) 是當 (X = x) 時 (Y)的預測值。Estimating the Coefficients現在有一堆 data， ((x_i, y_i), thinspace i = 1, 2, 3, …, n)，根據上面的迴歸式可以將這些 data 表示成，已經知道迴歸模型可以用上面的式子表示，那現在的任務是要找到 (hat{beta_0}) 和 (hat{beta_1})，只要找到這兩個參數就可以預測 (y) 了。找 (hat{beta_0}, hat{beta_1}) 的方法叫 The Least Square Method（最小平方法）。以上圖為例，紅色的點為 observations，深藍色的線是用最小平方法找到的迴歸線。The Least Square Method 是什麼？式子 ( hat{y_i} = hat{beta_0} + hat{beta_1} x_i ) 為 (X = x_i) 時 (Y) 的預測值。我們使用 Residual(殘差) 來看這個預測的結果與實際數值的差距，定義為 (e_i = y_i - hat{y_i}) (上圖中紅點到深藍色線的灰色線段們)。將所有 Residual 相加便能RSS =Reference:An Introduction to Statistical Learning with Applications in R",
      "url": " /machine%20learning/2018/12/27/Machine-Learning-Linear-Regression/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-09-machine-learning-regression-splines": {
      "title": "[Machine Learning]Regression splines",
      "content"	 : "上圖是一個 x, y 的分佈圖，紅線是這些點分部的方程式。但現實中，我們並無法真的知道紅線的方程式，我們可能使用一次方程式、二次方程式甚至更高次方的方程式去嘗試（如下圖）。我們可以將擬合的多項式方程式（polynomial function）寫成，(y = beta_0 + beta_1 x^1 + beta_2 x^2 + … + beta_n x^n + epsilon)但只是一味的提高多項式的次方只是增加模型的複雜度會導致 overfitting 的問題，在 testing data 上的結果也不會太好。這時候我們可以使用 Piecewise 將 data 劃分成多個區間，根據每個區間的 data 給予一個模型去擬合。Basis function(y_i = beta_0 + beta_1 b_1(x_i) + beta_2 b_2(x_i) + … + beta_n b_n(x_i) + epsilon_i)透過 (b_1(X))、(b_2(X))、……、(b_n(X)) 可以將非線性的自變量轉換成線性。Piecewise Function將 data 劃分多個區段後，每個區段再各自找到可以擬合的 model，model 可以是一次方程式、二次方程式或是三次方程式等等，不過三次方最常使用。如下圖每個區段都是用一次方程式去擬合。(xi) 為區段的分隔點，稱為 knot，每個分段函數稱為 piecewise function。From: 《Elements of Statistical Learning》但這些 piecewise function 是有條件的。雖然 piecewise function 是每個區段各自擬合出來的 function，但所有區段 function 必須整個為連續，也就是在 (xi) 的交界處的值必須相同。Cubic Spline這裡則是使用三次方程式。From: 《Elements of Statistical Learning》cubic spline 除了邊界的值相同外，還必須要一階和二階倒數相同。看上圖左上的圖加上邊界連續後成為右上，雖然看起來是連續的函數，但並不是完美的曲線，如果再加上一階導數相同就變成左下，再加上二階導數就可以畫出右下的圖。這個 R code 是畫出最上面圖的程式碼，使用 Introduction to Splines 裡頭的範例。set.seed(100)# functionf &amp;lt;- function(x) {  f_x &amp;lt;- 0.2*x^11*(10*(1-x))^6 + 10*(10*x)^3*(1-x)^10}x &amp;lt;- seq(from = 0, to = 1, length = 500)f_x &amp;lt;- f(x)eps &amp;lt;- rnorm(n = 500, mean = 0, sd = 2) # epsilony &amp;lt;- f_x + epsd &amp;lt;- data.frame(  x = x,  f_x = f_x,  y = y)# plotggplot(d, aes(x = x)) +  geom_point(aes(y = y), size = 0.5) +   geom_line(aes(y = f_x), colour = &quot;red&quot;, size = 0.8) +  theme_bw()ggplot(d, aes(x = x, y = y)) +  geom_point(size = 0.5) +   geom_smooth(method = &quot;lm&quot;, se = FALSE) +  stat_smooth(method = &quot;lm&quot;, formula = y ~ x + I(x^2), se = FALSE, colour = &quot;green&quot;) +  # stat_smooth(method = &quot;lm&quot;, formula = y ~ x + I(x^2) + I(x^3), se = FALSE, colour = &quot;gold1&quot;) +  # stat_smooth(method = &#39;loess&#39;, se = FALSE, colour = &quot;red&quot;) +  theme_bw()Reference:一文读懂回归样条（regression splines），附Python代码Introduction to SplinesSpline Regression | Non Linear Model | Polynomial Regressionwikipedia - 樣條函數Cubic and Smoothing Splines in R《An Introduction to Statistical Learning with Applications in R》",
      "url": " /machine%20learning/2018/12/09/Machine-Learning-Regression-splines/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-08-machine-learning-principal-component-analysis-pca": {
      "title": "[Machine Learning]Principal Component Analysis(PCA)",
      "content"	 : "From: «Pattern Recognition and Machine Learning» P.561What is PCA?Principal Component Analysis(PCA)，中文翻作「主成分分析」。PCA 是一種將多維度降維的方法。一個變數其實可能是多個潛在變因（laten variables）組成，但我們無法實際測量出那些 laten variables，而 PCA 就是要拆解出影響較大的變因。使用較少的變數解釋多個 variables。舉個例子，股市的點數上上下下，我們所能觀測到的是點數這個變數，但其實影響點數變動的潛在變因可能包含了很多市場因素，且每個因素可能又是互相影響。如果用數學符號表示，(x_i) 是我們有的變數，(z_i) 是裡頭含有的潛在變因，(x_i) 是 (z_i) 的線性組合（linear combination）。(x_1 = a_{11} z_1 + a_{12} z_2 + a_{13} z_3 + epsilon_1)(x_2 = a_{21} z_1 + a_{22} z_2 + a_{23} z_3 + epsilon_2)(x_3 = a_{31} z_1 + a_{32} z_2 + a_{33} z_3 + epsilon_3)……可以將上式改寫成，(z_1 = x_1 u_{i1} + x_2 u_{i2} + x_3 u_{i3})……如何降維？根據 «Pattern Recognition and Machine Learning» 這本書第 561 頁給了 PCA 兩種定義  PCA can be defined as the orthogonal projection of the data onto a lower dimensional linear space, known as the principal subspace, such that the variance of the projected data is maximized (Hotelling, 1933).  PCA can be defined as the linear projection that minimizes the average projection cost, defined as the mean squared distance tbtween the data points and their projections (Pearson, 1901).可以用上圖來理解，或是 StatQuest: Principal Component Analysis (PCA), Step-by-Step 這段。根據上面的定義，可以看到，降維的方法是要做 orthogonal projection，且找到投影向量讓投影後的資料變異量最大。這邊我使用 StatQuest: Principal Component Analysis (PCA), Step-by-Step 影片的內容來介紹。  maximized 什麼？假如現在座標上有個綠色的點，以座標((0, 0))原點，其長度為 a（影片沒有表示這是 a 向量，方便起見，後面以 a, b, c 向量表示），c 向量為 a 向量的投影方向與長度。根據畢氏定理，可以畫出一個正三角形，現在三角形的三邊長分別為 a, b, c（因為我懶得再圖上修正了，現在又變回長度）。而 PCA 要找的投影向量就是，最小化 (b^2) 的值，或是最大化 (c^2) 的值。  投影根據上圖，這個二維座標上有好幾個點，我們現在就是要找到一條能讓投影後 variance 最大的投影向量（紅色虛線），如下圖。要找到 SS（eigenvalue） 最小的投影向量。在投影前，我們會先將資料平移 (x_i - mu_i)，也就是不改變點之間的相對位置，這樣不但不會影響找投影向量的結果，在計算上也比較容易。Variation 變異量變異量 = (SS/(n-1), n )是點的數量有了變異量以後，我們通常會想要知道每個投影向量的變異量占比。假如現在有 PC1 其變異量為 15，PC2 的變異量為 3，則 PC1 與 PC2 的變異量總和為 18。所以 PC1 = 15*100%/18 = 83%，PC2 = 3*100%/18 = 17%。在做 PCA 的時候，我們會根據轉換的 (PC_i) 的比重，來決定要考慮要使用幾個 (PC_i)。如果可以解釋百分之九十基本上就可以拿來使用。假如今天有一筆多維度的資料，但轉換後 PC1 與 PC2 可以表示百分之九十的變異量，那麼這時候只要使用 PC1 與 PC2 就好，且還可以在平面座標上看點的分佈。基本上 PCA 就是在做座標變換，將原變數投影成新變數。接著以最少的新變數來代表原始資料最大的成分（variation 涵蓋量最大）。其原則如下  新變數是原變數的線性組合  保留原變數間的最大變異量（variance）Reference:StatQuest: Principal Component Analysis (PCA), Step-by-Step機器/統計學習:主成分分析(Principal Component Analysis, PCA)wikipedia - 主成分分析The Elements of Statistical LearningPattern Recognition and Machine Learning",
      "url": " /machine%20learning/2018/12/08/Machine-Learning-Principal-Component-Analysis(PCA)/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-03-machine-learning-boosting-and-adaboost": {
      "title": "[Machine Learning]Boosting and Adaboost",
      "content"	 : "BoostingFrom: Introduction to Boosted TreesBoosting 也是一種 Ensemble learning，它會結合多個弱分類器（weak classifiers）成為一個較準確的分類器，也可以應用在 regression 上。和 Bagging 有什麼不同？Bagging 各個 classifier 產生的過程是獨立的，但 Boosting 後產生的 classifier 與前面的 classifier 有關。也就是說，Bagging 的 classifier 可以並行產生，但 Boosting 必須要有順序的產生。所以時間上來說，Bagging 可以節省比較多的時間。與前面的分類器有關？在 Boosting 中，每一次產生 classifier 後，後面的 classifier 會根據前面 classifier 的結果調整每個點的權重。在前一個 classifier 分類錯誤後，在後一個 classifier 的權重會比較重，而表現較好的則會權重減少。這就是和 Bagging 最大的不同，Bagging 中所有的點都是隨機選取，且權重都是一樣的。簡單來說，Boosting learns features from data.步驟  用最原始的 training data 跑一個 classifiers  利用這個 classifiers 提高分類錯誤的點的權重，降低分類正確的點的權重。  重複第二步驟 N 次，最後使用權重的平均值。AdaBoostFrom: 機器學習: Ensemble learning之Bagging、Boosting和AdaBoostAdaBoost 應用了 boosting 的方法。概念假設現在有 n 個樣本，要執行 boosting T 次。第一次將所有樣本的權重都設為 (alpha_i) = 1/n, i = 1, …, n對所有 t = 1, …, T  根據樣本的權重 (alpha_i) 建立出 classifier (f_t(x))  使用 (f_t(x)) 後計算 (epsilon_t) 誤差  利用 (epsilon_t) 算出係數 (w_t)  再重新計算 (alpha_i)最後的 model 就會是：(hat{y} = sign sum_{t=1}^{T} w_i f_t(x))AdaBoost 的優勢就是讓 model 能夠從錯中學，使用提升與降低權重的方式讓分類錯誤的點可以在下一次的 model 中被改進。Reference:决策树（二）機器學習: Ensemble learning之Bagging、Boosting和AdaBoostAdaBoost和随机森林的区别Machine Learning -  University of Washington机器学习算法优缺点及其应用领域",
      "url": " /machine%20learning/2018/12/03/Machine-Learning-Boosting-and-Adaboost/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-03-machine-learningdecision-tree": {
      "title": "[Machine Learning]Random Forest",
      "content"	 : "基本上 Random Frost 是要改善 Decision Tree 容易 overfitting 的問題，它結合了 Decision Tree 和 bagging 的方法。Random Forest 是建立很多顆決策樹，再利用多數決選出最好的選項，和 bagging 這篇提到的方法有點類似，但有些小差異。使用的方法是 bagging（結合多個 model），所以這也是 Ensemble learning。Random Forest步驟假如有一 training data，有 N 個樣本，p 個features。今天要利用這個 training data 建立一個 Random Forest model，裡頭共有 B 棵決策樹，  使用 boostrap 從 training data 中抽出 N 個樣本產生一組 data  在這組 data 中隨機從 p 個 featrues 中選取 m (m &amp;lt; p) 個 features，再從這 m 個 features 找出最好的一個分割結果，如此產生一個 node  重複步驟 2，直到完成這個 model 為止  重複步驟 1~3 B 次，共會產生 B 棵擁有不同 feature 的決策樹最後要進行 predict 時，分類問題使用多數決，回歸問題使用平均數決定。  因為每一棵樹的隨機選取的樣本與 feature 都不同，所以每棵樹的結果都不會相同。  Random Frost 建立的 decision tree 不需要 pruning。在 decision tree 剪枝是爲了避免 overfitting，但在 Random Frost 使用 bagging 的方式就已經避免 overfitting 了。  因為每一棵決策樹都是隨機篩選 feature 的結果，所以可以想像每棵樹就像是精通某個領域的專家。當有個新的數據近來，經由各個領域的專家投票表決，做出最後的選擇。      Random Forest 中有兩個參數需要人為控制，一個是樹的數量（B），一般建議取很大。另一個是 feature 的大小（m）。    優點：          不用做特徵（feature）選擇。      訓練完後可以知道哪些 feature 比較重要。      Reference:StatQuest: Random Forests Part 1 - Building, Using and Evaluating随机森林（Random Forest）算法原理AdaBoost和随机森林的区别",
      "url": " /machine%20learning/2018/12/03/Machine-LearningDecision-Tree/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-03-machine-learning-bagging": {
      "title": "[Machine Learning]Bagging",
      "content"	 : "BaggingFrom: Hastie, T., Tibshirani, R. and Friedman, J. The Elements of Statistical Learning. Springer, 2009. p.285Bagging 是什麼？Bootstrap aggregating (bagging) is a machine learning ensemble meta-algorithm to improve classification and regression models in terms of stability and classification accuracy. It also reduces variance and helps to avoid ‘overfitting’. Although it is usually applied to decision tree models, it can be used with any type of model. (Decision Tree - Bagging)簡單來說，Bagging是一種 Ensemble learning方法，它集結一些 model 來做最後的決策。通常會是集結表現沒那麼好的 model，讓這些 model 一起做決定，一種三個臭皮匠勝過一個諸葛亮的感覺。Decision tree 是一個常見的 weak classifier，所以如果在 decision tree 上使用 bagging，可以讓最後表現結果比較好，也避免 overfitting 的情況。Boostrap在開始說明 bagging 步驟前先介紹 bootstrap。bootstrap 是一種抽樣方法。假設今天有一組資料，裡頭共有 N 個樣本，我們想要有 m 個大小為 N 的樣本作為訓練資料。方法是，每次從這 N 個樣本隨機抽取，且每次都是取後放回(也就是有些樣本可能被抽到一次以上，有些樣本可能沒被抽到)，同樣的方法重複 m 次，這樣我們就會有 m 組樣本數為 N 的 y 資料集。這樣的方法在樣本數量少時很有用。如果樣本小，但我們用 train-validation-test 這樣的方式訓練資料，訓練的樣本資料非常小，會造成 bias 較大的問題。而使用 bootstrap 不會減少樣本的數量，也能保留 test data。如何操作？  使用 boostrap 方法從 training data 中採集 B 組樣本數與 training data 相同的資料集。  這 B 組資料集都建立一個 model， (f_b(x))，共產生 B 個 model。  最後預測的結果就是將這 B 個 model 做統合。在分類問題上，可以平均各個 model 的 posterior class probabilities，或是使用 majority voting。（選機率比較大的結果或是多數決）；在回歸上，則取平均值。從最上圖可以看到，不論是使用機率或是投票決定，bagging 選出的結果的 test error 都要比個別的 model 表現較好。除了 Bagging 外，Ensemble learning 還有另一種常見的方法 Boosting，這篇先到這裡之後繼續介紹。Reference:機器學習: Ensemble learning之Bagging、Boosting和AdaBoost随机森林（Random Forest）算法原理The Elements of Statistical LearningPattern Recognition and Machine Learning",
      "url": " /machine%20learning/2018/12/03/Machine-Learning-Bagging/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "machine-20learning-2018-12-03-machine-learning-decision-tree-e5-92-8c-bagging": {
      "title": "[Machine Learning]Decision Tree",
      "content"	 : "Decision TreeDecision Tree是什麼？簡單來說，decision tree 是一個分類模型。  Tree-based methods partition the feature space into a set of rectangles, and then fit a simple model (like a constant) in each one.這是 Pattern Recognition and Machine Learning 裡頭的定義。根據上圖，想像一下，在右邊的二維座標平面上有一堆散布的點，而 decision tree，就是將這個平面一一分割，每一個框框都是一個分類結果。但我們可以用右邊那樣一層一層的樹枝結構狀來表示右邊難懂的圖。（這裡的例子是二維平面，當變數 (x_i) 增加時，這樣的概念可以推廣到多維空間）每一個分支都像是一個 if-else 問題，如果是就選某一邊，不是就選另外一邊。上圖左，我們可以看到有兩個變數，(x_1), (x_2)，第一關是 (x_1 &amp;gt; theta_1 )，如果小於就往左邊分，如果大於就往右邊分，以此類推往下繼續細分，最後給予分類結果。最後共分成 A, B, C, D, E 五個類別，也就是右邊的五個框框。Decision Tree 又可以分為      Regression trees - 最後分類結果為連續變數        Classification trees - 最後分類結果為類別變數  名詞  Root node (The Root) - 第一個起始的點  (Internal) Nodes - 中間的節點。上方會有箭頭指向 node，且 node 也會往下指向其他點。  Leaves (terminal nodes) - 最後的節點，也就是最後的分類結果。如何分類？假如今天我有一份 data，decision tree 是如何決定要先使用哪一個變數與什麼值作為分割呢？分割的原則是，這樣的分割要能得到最大的資訊增益 (Information gain, IG) ([資料分析&amp;amp;機器學習] 第3.5講 : 決策樹(Decision Tree)以及隨機森林)資訊量根據最後的分類結果可以使用，  Regression trees:          MSE (mean-squared error)        Classification trees:          Entropy (Deviance)      Gini impurity      Missclassification error      在 Classification tree 裡，Entropy 和 Gini impurity 是常用的兩種方式，詳細的公式請參考 Wikipedia假如今天碰到兩種 model 算出來的資訊量都ㄧ樣，請選擇比較簡單的那個 model。（分支、leaves node 較少）R 範例這裡使用 tree 這個 library 做範例，另外還有像是 rpart 也是做 decision 常用的 package。library(tree)data(&quot;iris&quot;)# 使用 Entropy (Deviance)fit &amp;lt;- tree(Species ~ Sepal.Length + Petal.Length, iris, split = c(&quot;deviance&quot;))plot(fit)text(fit, pretty=0)summary(fit)# 使用 Gini impurityfit &amp;lt;- tree(Species ~ Sepal.Length + Petal.Length, iris, split = c(&quot;gini&quot;))plot(fit)text(fit, pretty=0)summary(fit)優缺點  優點：          Simple to understand and interpret. 容易理解與解釋      Able to handle both numerical and categorical data. 可以用在類別與 numerical 資料        缺點          Low bias and high variance with respect to the training data.（當 decision tree model 變得太過複雜時，太多 nodes，就會導致 overfitting (bias-variance trade off 的狀況）      所以為了讓 model 不要 overfitting，我們可以使用 pruning 的方式，砍掉底下的樹枝。在 R 可以使用，prune.tree()，並且可以使用 best 這個參數來決定最後要保留多少 leaves。使用剛剛最後的 fit示範prune_fit &amp;lt;- prune.tree(fit, best = 5)plot(prune_fit)text(prune_fit, pretty=0)summary(prune_fit)這時候 leaves 由原本的 9，修剪到了剩下 5，但 Misclassification error rate 卻是相同的。修剪過後的 model 較簡單，且 variance 也會比較小，在預測上表現也會較佳。Reference:[資料分析&amp;amp;機器學習] 第3.5講 : 決策樹(Decision Tree)以及隨機森林StatQuest: Decision TreesThe Elements of Statistical LearningPattern Recognition and Machine Learning",
      "url": " /machine%20learning/2018/12/03/Machine-Learning-Decision-Tree-%E5%92%8C-bagging/",
      "author": "Shihs",
      "categories": "Machine Learning"
    }
    ,
  

    "r-2018-11-10-r-e5-a6-82-e4-bd-95-e5-9c-a8-ggplot2-e5-9c-96-e5-bd-a2-e4-b8-8a-e5-b8-8c-e8-87-98-e5-ad-97-e6-af-8d": {
      "title": "[R]如何在 ggplot2 圖形上希臘字母？",
      "content"	 : "1. 圖形文字Text Labels: Use parse = T inside geom_text or annotate.2. 座標軸標籤Axis Labels: Use expression(alpha) to get greek alpha.3. LegendLegend Labels: Use bquote(alpha == .(value)) in legend label.4. Fecet圖形Facet 圖形比較特殊，要將 labeller = label_parsedFacet Labels: Use labeller = label_parsed inside facet.來源",
      "url": " /r/2018/11/10/R-%E5%A6%82%E4%BD%95%E5%9C%A8-ggplot2-%E5%9C%96%E5%BD%A2%E4%B8%8A%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-10-20-r-environment": {
      "title": "[R]Environments (1)",
      "content"	 : "這篇要介紹 R 的環境(Environments)。我個人覺得環境是一個寫程式很重要但一開始會很困惑的東西，之前一直處於似懂非懂的狀態。其實如果只是用 R 來跑一些數據分析，其實不理解環境並不會造成什麼太大的問題，但如果能夠懂當然絕對是有利無弊。最近有了寫 R package 的經驗後，讓我開始對「環境」比較了解，所以這篇想要將我的理解記錄下來。1. 什麼是環境（Environments）？當我們每次打開 R studio 這時候便是打開了某個環境，接著我們產生了一些變數，這些變數便是在這個環境底下。很抽象嗎？打開 R studio 時，在右上的框框（或是在某個位置）有個「Environment」，然後可以看到如下圖的「Gloabal Environment」，並且在下面的框框可以看到我們產生的變數（圖中的 x）。這就表示，我們現在在「Gloabal Environment」這個環境底下，且 x 這個變數在「Gloabal Environment」環境中。當我們把「Gloabal Environment」這個圖往下拉，可以看到像下圖這樣（每個人的可能都不太一樣）依序往下就會是「Gloabal Environment」的 「parent 環境」。（「parent 環境」是殺毀？！）環境就像是房間我覺得可以把「環境」想像是一個房間。當妳/你在操作 R ，產生任何變數，做任何動作，都是在這個房間裡面操作（通常一打開 R studio 都會是在 Global 環境）。所以這些變數全部都會被放在這個房間裡。或是想像在一個房間裡縫娃娃這些娃娃做完都會被放在這個房間裡。那「parent 環境」就會是，妳/你走出這個房間來到客廳，也就是說，這個房間是被包在家裡的，走出家裡，整個家是被包在建築物裡的，然後社區，然後某條路，某個區，某個縣市……就是一個俄羅斯娃娃的感覺。往上一層就會是「parent 環境」、「grand parent 環境」…..以此類推。2. R 是如何在環境裡找變數的？根據上面的解釋我們知道，每次操作 R 的時候我們都會是在某個環境底下。那這和 R 要找變數有什麼關係呢？在這之前我們先來看我現在有幾間房間呢？search()# [1] &quot;.GlobalEnv&quot;        &quot;tools:rstudio&quot;     &quot;package:stats&quot;     &quot;package:graphics&quot;  &quot;package:grDevices&quot;# [6] &quot;package:utils&quot;     &quot;package:datasets&quot;  &quot;package:methods&quot;   &quot;Autoloads&quot;         &quot;package:base&quot;這表示，最底下的環境是.GlobalEnv(Gloabal Environment)，它的 parent 變數是tools:rstudio，再往上是package:stats……等等，最後會是package:base，但其實最上層會是 Empty environment。在房間裡找東西？如果今天妳/你人在一個房間裡找東西妳/你會怎麼找？一定會先在房間裡搜尋一遍，如果怎麼都找不到，就會去客廳找，再找不到就到這棟建築物找……一直往外找對吧？所以同樣的，如果今天我們想要找個變數 x，結果 R 發現找不到，那它就會往 parent 環境（search()的順序）找，再找不到就會再往上找，如果一直找到最上層還是沒有，就會跳出像這樣的錯誤。x# Error: object &#39;x&#39; not found找的方式就像是這個圖，sourceparent 是誰？我們可以用parent.env()來查看上一層環境，now.env &amp;lt;- environment()parent.env &amp;lt;- parent.env(now.env)grandparent.env &amp;lt;- parent.env(parent.env)3. 可以增加環境嗎？如果仔細看剛剛search()的結果會發現，那些都是 package 呢！其實在每次使用 library()或是require() attache 一個 pacakge 後環境就會被改變，這時 Gloabal Environment 的 parent 環境就會變成這個 package。（請自行實驗）（題外話）library() v.s require()這兩者到底有什麼差別呢？基本上兩個的差別只有在於找不到這個 package 時，library() 會產生 Error 暫停程式，require()會 FALSE 並吐出 Warning ，然後繼續執行程式。所以可以把require()包在 if 裡，如果沒有這個 package 就安裝，程式也能繼續執行。&amp;gt; library(x)# Error in library(x) : there is no package called ‘x’require(x)# Loading required package: x# Warning message:# In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :#  there is no package called ‘x’（題外話結束）也就是說，如果我們今天使用library()或是require()就會讓環境改變。所以如果今天是要 create package 的話，千萬不要將 library()和require()包在任何 function，這樣非常危險，可能會造成 Namespace 的混亂。（如果看不懂可以先忽略這段）那如果今天需要用到這個包，但是又不想讓它加到 search path（parent 環境）裡怎麼辦？這時候請使用::。例如，今天想要呼叫 pkg1 裡頭的 fun()，pkg1::fun()::還有一個很好用的時刻，就是當今天有兩個不同的 package 擁有兩個同樣名稱的 function 時，先載入的 package 順序會被放在後面，所以如果直接呼叫 funciton ，一定會用到後載入的 package 的 function。如果現在是 pkg1 和 pkg2 都有 fun()，那我們可以這樣用，# 呼叫 pkg1 的 funpkg1::fun()# 呼叫 pkg2 的 funpkg2::fun()這樣就絕對不會出錯了。不過記得，要使用::必須要有 install 這個 package 才能使用。Attaching v.s Loadinglibrary() 和 require() 這兩個 function 的動作都是 Attaching，也就是會將這 package 加到 parent 環境 (search path)。但 ::則是 Loading，也就是說，這個 pacakge 在 loading 後可以在記憶體（memory）中被找到，但不會被加到 parent 環境 (search path) 中。source下次介紹  new.env()和 function 中的環境  &amp;lt;- 和 «- 的差別Reference:Advance R - EnvironmentsR package - NamespaceBuild a R package for yourselfMaking Your First R Package",
      "url": " /r/2018/10/20/R-Environment/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-10-19-r-variable-types": {
      "title": "[R]variable types",
      "content"	 : "We know there are several common types in R, such as, vector, list, matrix, and data.frame.Here I’m going to see these 4 types more details.  What are the differences between vector, list, matrix, and data.frame?  What are the outputs of is.atomic() and is.vector()?  What are the outputs of typeof()?1. What are the differences between vector, list, matrix, and data.frame?We can seperate these four types to two groups from different aspects.(a) Elements type aspect  Homogeneous data: vector, matrix  Heterogeneous data: list, data.frameWhich means all elements in vector and matrix have to be the same type (integer, double, or character ect.).But elements in list and data.frame can be different types.For example:Vector has same type of elements# vectorv &amp;lt;- 1:4#  v# [1] 1 2 3 4v_ch &amp;lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)# v_ch# [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;What if we give a vector different type of elements?v &amp;lt;- c(1, &quot;2&quot;)# v#[1] &quot;1&quot; &quot;2&quot;As you can see, R forces 1 to be character.But what is the priority? Why not “2” become numeric?Because the hierarchy for coercion is:  logical &amp;lt; integer &amp;lt; numeric &amp;lt; characterSo this is why numeric would be force to character.reference(b) Dimension aspect  1 Dimension: vector, list  2 Dimensions: matrix, data.frame2. What are the outputs of is.atomic() and is.vector()?Let’s see the outputs of these four types.v &amp;lt;- 1:4 # vectorl &amp;lt;- list(1:4) # listmat &amp;lt;- matrix(1:2, ncol = 2) # matrixdf &amp;lt;- data.frame(a = 1, b = 2) # data.frame(a) is.atomic()# &amp;gt; is.atomic(v)# [1] TRUE# &amp;gt; is.atomic(l)# [1] FALSE# &amp;gt; is.atomic(mat)# [1] TRUE# &amp;gt; is.atomic(df)# [1] FALSEAs you can see the results, is.atomic() gives boolean values.And the output is to see if the object is Homogeneous data or Hetergeneous data.Hence, vector and matrix get TRUE, list and data.frame get FALSE.(b) is.vector()# is.vector(v)# [1] TRUE# is.vector(l)# [1] TRUE# is.vector(mat)# [1] FALSE# is.vector(df)# [1] FALSEIn contrast with is.atomic(), is.vector() checks from Dimension aspect.3. What are the outputs of typeof()# vectorv &amp;lt;- 1:4  # all elements are numericv_ch &amp;lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)  # all elements are characters# listl &amp;lt;- list(1:4)  # all elements are numericl_ch &amp;lt;- list(a = &quot;a&quot;, b = &quot;b&quot;) # all elements are characters# matrixmat &amp;lt;- matrix(1:2, ncol = 2)  # all elements are numericmat_ch &amp;lt;- matrix(c(&quot;a&quot;, &quot;b&quot;), ncol = 2)  # all elements are characters# data.framedf &amp;lt;- data.frame(a = 1, b = 2)Let’s see the results,# ---vector-------------# &amp;gt; typeof(v)# [1] &quot;integer&quot;# &amp;gt; typeof(v_ch)# [1] &quot;character&quot;# ---list-------------# &amp;gt; typeof(l)# [1] &quot;list&quot;# &amp;gt; typeof(l_ch)# [1] &quot;list&quot;# ---matrix-------------# &amp;gt; typeof(mat)# [1] &quot;integer&quot;# &amp;gt; typeof(mat_ch)# [1] &quot;character&quot;# ---data.frame-------------# &amp;gt; typeof(df)# [1] &quot;list&quot;From the result of ouputs, we can see it checks if the object is Homogeneous data or not.If it is Homogeneous data then typeof() will show the type of elements.But if the object is Hetergeneous data, it will give only list as output result.More detail about Data Structure can be found hereReference:R深入|数据类型",
      "url": " /r/2018/10/19/R-variable-types/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-10-04-r-rstudtio-e7-b7-a8-e7-a2-bc-e5-95-8f-e9-a1-8c": {
      "title": "[R]RStudtio編碼問題",
      "content"	 : "解決編碼問題可以說最惱人的事了……在使用中文或是其他歐語系語言時經常碰到編碼問題，這篇我根據我自己的一些經驗整理了一些在使用 RStudio 時解決編碼問題的辦法。根據我的經驗，我覺得編碼問題可以分成三種，  R 程式碼編碼問題  檔案編碼問題  系統編碼問題1. R 程式碼編碼問題當你打開一份 R Script 時，發現 script 中的中文都是亂碼時，這時應該是這份 script 檔案的編碼與你電腦的 RScript 預設的不同。這時選擇 File -&amp;gt; Reopen with Encoding… 更改編碼(UTF-8、BIG5、ASCII試試)，問題應該就可以解決了。或是可以直接更改預設的讀檔編碼，到 Tools -&amp;gt; Global Options… -&amp;gt; (左邊選單) Code -&amp;gt; Saving 更改 Default text encoding。2. 檔案編碼問題當你讀進一份檔案，可能碰到以下幾種狀況a. 讀檔時出現編碼錯誤解決方法： (1)讀檔時設定 fileEncoding：讀檔時提供檔案本身編碼資訊，參考(2)更改檔案編碼：先更改檔案本身的編碼，再使用 RStudio 讀取檔案。   如果是 Windows，我個人推薦直接使用記事本更改最方便。另存新檔直接存成需要的編碼。(3)更改預設讀檔編碼：如第一個提到的 R 程式碼編碼問題的解決方案，直接更改預設的編碼，設定成 UTF-8 應該是最好的。b. 順利讀進檔案，但無法正確顯示讀檔時，使用 encoding 參數來決定要顯示什麼語言read.csv(&quot;filename.csv&quot;, encoding = &quot;latin1&quot;)3. 系統編碼問題順利讀進檔案，已更改輸入時的編碼，但顯示仍舊錯誤。這問題是在讀一份含有瑞典文的檔案時碰到的，已經更改過檔案的編碼，但開啟後仍無法正確顯示瑞典文。可以檢查一下系統本身的編碼是不是 UTF-8sessionInfo() # 裡的 local# 或是Sys.getlocale()# MAC 會長得大概像這樣# &quot;en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8&quot;如果不是，更改系統的語系，以下更改為 UTF-8# for windowsSys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;UTF-8&quot;)# for macSys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;en_US.UTF-8&quot;)另外，要查看 vector 的編碼可以使用# x is a vectorEncoding(x)我個人認為，解決編碼問題最重要的就是要先知道編碼出錯的問題在哪。是檔案本身編碼問題，還是系統的問題，那是要修改檔案還是要修改系統？",
      "url": " /r/2018/10/04/R-RStudtio%E7%B7%A8%E7%A2%BC%E5%95%8F%E9%A1%8C/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "algorithm-2018-09-28-algorithm-hamiltonian-path-and-travelling-salesman-problem-tsp": {
      "title": "[Algorithm]Hamiltonian path and Travelling Salesman Problem(TSP)",
      "content"	 : "以下簡單地整理網路上查到的 Hamiltonian path 與 Travelling Salesman Problem 介紹。Hamiltonian pathWhat is Hamiltonian path?Hamiltonian path is a path that visit every node only once. It can be an undirected or directed graph. Also itHamiltonian cycleIf a Hamiltonian path is a cycle then we call it A Hamiltonian cycle (or Hamiltonian circuit).Hamiltonian path problemDetermining whether such paths and cycles exist in graphs is the Hamiltonian path problem, which is NP-completeTravelling Salesman ProblemWhat is Travelling Salesman Problem(TSP)?There is a man traveling. He departures from a city and he wants to visit every cities(nods) with the shortest distance. In the end, he will go back to the origin city, and he can only stop in each city once.Which means, TSP is looking for the shortest distance of Hamiltonian cycle.reference:演算法筆記Wikipedia - TSPWikipedia - Hamiltonian path",
      "url": " /algorithm/2018/09/28/Algorithm-Hamiltonian-path-and-Travelling-Salesman-Problem(TSP)/",
      "author": "Shihs",
      "categories": "Algorithm"
    }
    ,
  

    "r-2018-09-27-r-scale-e8-88-87-dist-function": {
      "title": "[R]scale 與 dist function",
      "content"	 : "這篇文章會介紹 R 中的 scale 與 dist 兩個 function。在做資料分析前會需要先標準化scalescale 的主要作用在標準化數據，共有三個 arguments，  x: 必須要是 matrix，以「行」為每組數據計算  center: TRUE or FALSE。中心化，TRUE 會減去數據的平均值  scale: TRUE or FALSE。 TRUE 會將數據中的每個值除以數據的標準差預設 center 和 scale 都是 TRUE，也就是算出來的值是 z-score。  (z = frac{x - mu}{sigma}, sigma neq 0)其中：(x)：數據(mu)：平均值(sigma)：標準差x &amp;lt;- matrix(1:10, nrow = 5)scale(x)distdist 是在算數據間的距離，主要的 arguments有  x: 可以是 matrix, data.frame ，但必須要是 numeric。  methods: 共有六種計算距離的方法，”euclidean”, “maximum”, “manhattan”, “canberra”, “binary” 和 “minkowski”，預設是使用 euclidean 距離。以「列」為數據，兩兩計算，x &amp;lt;- matrix(1:10, nrow = 5)dist(x)",
      "url": " /r/2018/09/27/R-scale-%E8%88%87-dist-function/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-09-14-r-e5-a6-82-e4-bd-95-e5-9c-a8r-package-e5-8a-a0-e4-b8-8acode-coverage-codecov": {
      "title": "[R]如何在R Package加上code coverage (codecov)?",
      "content"	 : "code coverage(代碼覆蓋率)?這篇是根據這篇的步驟操作。如果要找 package 內容物該有的東西可以參考我完成的一個 R package。以下會將步驟一一列下。1. 完成 R package 與建立 test 測試建立 R package 可以參考大神的書，test 則可以參考這本書的 testing 章節。基本上使用，devtools::use_testthat()就會自己建立一個 tests 資料夾，再把要測試的程式碼加進下一層的 testthat 資料夾內。最後進行測試，devtools::test()2. 建立所有 code coverage 需要的檔案與內容先跑一下程式碼，devtools::use_coverage()跑完後會出現以下的步驟提示，* Creating `codecov.yml` from template.* Adding `codecov.yml` to `.Rbuildignore`.* Add to `README.md`: [![Coverage Status](https://img.shields.io/codecov/c/github/shihs/LiUAdRLab3/master.svg)](https://codecov.io/github/shihs/LiUAdRLab3?branch=master)* Add to `.travis.yml`:after_success:  - Rscript -e &#39;covr::codecov()&#39;基本上就一步一步照著做就對了，前面兩件事程式已經幫你處理好了，從第三步開始就行。3. 將 Github 與 codecov 連結使用 Github 帳號登入 codecov.io 。連結你要使用 codecov 的 reposity，會出現像這樣的畫面得到一組 token，將 token 複製，在 R 中跑以下程式碼，install.packages(&quot;covr&quot;)library(covr)codecov(token = &quot;YOUR_TOKEN_GOES_HERE&quot;)大功告成！這時候會看到你剛剛貼上的 coverage 圖案出現 code coverage 的結果。如果想要先在 R studio 上看測試結果可以使用，library (covr)report()viewer 視窗就會顯示測試結果了。",
      "url": " /r/2018/09/14/R-%E5%A6%82%E4%BD%95%E5%9C%A8R-Package%E5%8A%A0%E4%B8%8Acode-coverage-(codecov)/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-git-2018-09-08-r-git-e5-a6-82-e4-bd-95-e9-80-a3-e6-8e-a5rstudio-e8-88-87githu": {
      "title": "[R][Git]如何在 Rstudio 上連接 R project 與 Github",
      "content"	 : "本篇介紹如何將 Rstudio 中的 R project 與 Github 連結，讓每次專案在進行中都可以簡單快速的 commit 與 push。在進入主題前，請先安裝好 R、Rstudio 和 Git ，並且申請好 Github 帳號。前置作業設置 SSH RSA key1.複製 public keyTool &amp;gt; Global Options &amp;gt; Git/SVN &amp;gt; Create RSA Key &amp;gt; View public key 點開 View public key 後，複製裡頭所有的東西。2.將 public key 貼到 github開始建立 connection建立專案請先建立一個專案，這裡就不多加解釋了。在本機建立 repositoryBuild &amp;gt; Configure public Tools &amp;gt; Git/SVN將 Version control system 由 None 改為 Git這時候就會發現 Rstudio 的視窗長得不太一樣了。下方視窗應該會有一些還未 commit 的檔案，但因為我都已經 commit 了，所以沒有內容。且這時候 pull 和 push 鍵應該還無法操作。Github 同步終於來到最後一哩路。到 Github 上創建一個新的 repository，且名稱要和 project 相同，只要單純創建 repository 就好，什麼檔案都不要。最後，打開 Rstudio 工具列的， Tools &amp;gt; Shell然後在 Shell 裡輸入，git remote add origin https://github.com/你的github帳號/你的專案名稱.gitgit push -u origin master完成後就會發現專案已經和 Github 連結了！專案的檔案都出現在 Github 上了。這時候 pull 和 push 鍵也已經可以操作了。未來只要更新專案內容，就可以直接在 Rstudio 上 commit 和 push 就好了！補充移除 project 與該 repository 的 connection rm -rf .git參考：  Hadley Wickham 的 R Package Git 章節",
      "url": " /r/git/2018/09/08/R-Git-%E5%A6%82%E4%BD%95%E9%80%A3%E6%8E%A5Rstudio%E8%88%87githu/",
      "author": "Shihs",
      "categories": "R, Git"
    }
    ,
  

    "e7-b5-b1-e8-a8-88-2018-09-04-e7-b5-b1-e8-a8-88-e4-bb-80-e9-ba-bc-e6-98-afcdf": {
      "title": "[統計]什麼是 CDF (Cumulative Distribution Function)?",
      "content"	 : "在進入連續型隨機變數（Continuous Random Variable）前先插播介紹何謂 CDF。CDF (Cumulative Distribution Function)定義 Definition  The cumulative distribution function (CDF) of random variable (X) is defined asSource  Mathematical Statistics with Applications 這本書將 CDF 稱為 distribution function，wikipedia 則翻譯為累積分布函數。以下再分 1.離散型函數 與 2.連續型函數 來看，離散型隨機變數的 CDF以擲兩枚硬幣為例，出現 head 為 1，tail 為 0，其隨機變數 (X) 的 PMF 函數為PMF 函數圖為，則它的 CDF 累積分佈函數為CDF 函數圖為，可以發現，離散型的 CDF (F_X(x)) 為不連續的函數圖。關於離散型的 CDF 這影片有更詳細的說明。連續型隨機變數的 CDF那如果今天有個隨機變數 (X)，它的 CDF (F(X)) 為連續函數呢？定義 Definition  A random variable (X) with CDF (F(X)) is said to be continuous if (F(X)) is a continuous function for all (X in {Bbb R} ). Source參考：  Introduce To Proability, Statistics and Random Process",
      "url": " /%E7%B5%B1%E8%A8%88/2018/09/04/%E7%B5%B1%E8%A8%88-%E4%BB%80%E9%BA%BC%E6%98%AFCDF/",
      "author": "Shihs",
      "categories": "統計"
    }
    ,
  

    "e7-b5-b1-e8-a8-88-2018-09-04-e7-b5-b1-e8-a8-88-e9-9b-a2-e6-95-a3-e5-9e-8b-discrete-e9-9a-a8-e6-a9-9f-e8-ae-8a-e6-95-b8-e8-88-87-e5-85-b6-e6-a9-9f-e7-8e-87-e5-88-86-e4-bd-88-3": {
      "title": "[統計]離散型(Discrete)隨機變數與其機率分佈(3)",
      "content"	 : "這一系列我是以 Wackerley, Mendenhall and Scheaffer 的 Mathematical Statistics with Applications, 7th edition 這本書為主，有些名詞與定理解釋會再參考其他書籍與網路作為輔助（下方有參考連結）。這一篇要介紹常見的離散型分佈（Discrete Distribution），這篇主要是參考  Source伯努利分佈 Bernoulli Distribution定義 Definition  A random variable (X) is said to be a bernoulli random variable with peremeter (p), shown as (X sim Bernoulli(p)), if its PMF is given by  where (0 &amp;lt; p &amp;lt; 1)簡單來說，一個事件只有兩種可能。生活中有非常多的例子都會是 Bernoulli Distribution，譬如，  考試有及格、不及格  丟擲一枚銅板有正面、反面  小孩子性別可能是男生、女生幾何分布 Geometric Distribution定義 Definition  A random variable (X) is said to be a geometric random variable with peremeter (p), shown as (X sim Geometric(p)), if its PMF is given by  where (0 &amp;lt; p &amp;lt; 1)Geometric Distribution 的例子：擲一枚銅板，且此銅板擲到 Head 的機率為 (p)。今天擲這枚到出現第一個 Head 為止，則其機率分佈為 Geometric Distribution。另外，每一次擲這枚銅板都會是獨立的 Bernoulli 試驗。所以，Geometric Distribution 就是很多次的 Bernoulli 試驗直到成功為止。以 (p = 0.3) 為例，其 Geometric Distribution 的 PMF 會是這樣，二項分布 Binomial Distribution定義 Definition  A random variable (X) is said to be a binomial random variable with peremeter (n) and (p), shown as (X sim Binomial(n, p)), if its PMF is given by  where (0 &amp;lt; p &amp;lt; 1)Binomial Distribution 也是很多次獨立 Bernoulli 試驗的結果，但和 Geometric Distribution 不一樣的是，Binomial Distribution 會執行 (n) 次的 Bernoulli 試驗，且成功了 (k) 次。所以它的 PMF 會有 ，表示執行了(n) 次，其中有 (k) 次成功，且這 (k) 次並沒有限定在哪個位置。可以以丟擲 (n) 枚銅板來想，其中 (k) 枚硬幣為 Head，((n-k)) 為 Tail。以 (n = 10,; p = 0.3) 為例，其 PMF 圖會是，Binomial random variable as a sum of Bernoulli random variables  If (X_1,;X_2,;X_3,…,;X_n) are independent (Bernoulli(p)) random variable,  then the random variable (X) defined by (X = X_1 + X_2 + X_3 + … + X_n) has a (Binomial(n,p)) distribution.也就是，二項分布可以看成是每個獨立的伯努利分佈的和。布瓦松分布 Poisson Distribution定義 Definition  A random variable (X) is said to be a poisson random variable with peremeter (lambda), shown as (X sim Poisson(lambda)), if its range is (R_X = { 0, 1, 2, 3,… } ), and if its PMF is given byPoisson Distribution 的意義為：單位時間內，事件出現平均 (lambda) 次的機率分布。既然上面的式子為 PMF，那我們來檢驗(sum_{k in R_X}{P_k(x)} = 1)是否正確。  Note: 根據 Taylor Series(泰勒展開式) (; e^{x} = sum_{k=0}^{infty} frac{x^k}{k!})，上列式子可以寫成，Example:  The number of emails that I get in a weekday can be modeled by a Poisson distribution with an average of 0.2 emails per minute.      What is the probability that I get no emails in an interval of length 5 minutes?    What is the probability that I get more than 3 emails in an interval of length 10 minutes?  Poisson as an approximation for binomial  Let (X sim Binomial(n, p = frac{lambda}{n})), where (lambda &amp;gt; 0) is fixed. Then for any (k in {0, 1, 2,…} ), we have(X sim Poisson(lambda = 5)) 的函數圖形，參考：  Mathematical Statistics with Applications 7th Edition  Introduce To Proability, Statistics and Random Process  陳鍾誠的網站",
      "url": " /%E7%B5%B1%E8%A8%88/2018/09/04/%E7%B5%B1%E8%A8%88-%E9%9B%A2%E6%95%A3%E5%9E%8B(Discrete)%E9%9A%A8%E6%A9%9F%E8%AE%8A%E6%95%B8%E8%88%87%E5%85%B6%E6%A9%9F%E7%8E%87%E5%88%86%E4%BD%88(3)/",
      "author": "Shihs",
      "categories": "統計"
    }
    ,
  

    "e7-b5-b1-e8-a8-88-2018-09-02-e7-b5-b1-e8-a8-88-e9-9b-a2-e6-95-a3-e5-9e-8b-discrete-e9-9a-a8-e6-a9-9f-e8-ae-8a-e6-95-b8-e8-88-87-e5-85-b6-e6-a9-9f-e7-8e-87-e5-88-86-e4-bd-88-2": {
      "title": "[統計]離散型(Discrete)隨機變數與其機率分佈(2)",
      "content"	 : "這一系列我是以 Wackerley, Mendenhall and Scheaffer 的 Mathematical Statistics with Applications, 7th edition 這本書為主，有些名詞與定理解釋會再參考其他書籍與網路作為輔助（下方有參考連結）。這篇關於期望值的介紹在書中的 3.3，但這篇內容有很大部分也來自 Source期望值 Expectation定義 Definition  Let (X) be a discrete random variable with range (R_X = { x_1, x_2, x_3,… } )(finite or countably infinite). The expectation of (X) is defined as且期望值 (E(X)) 會等於平均數 (mu)說明：  There is a discrete random variable with range (R_X = { x_1, x_2, x_3,… } ). Suppose that we repeat this experiment a very large number of times (N), and that the trials are independent. Let (N_1) be the number of times we observe (x_1), (N_2) be the number of times we observe (x_2, ….), (N_k) be the number of times we observe (x_k).  從以上式子我們可以得到 (N_k = NP_X(x_k))以上就是 (E(X) = mu) 的說明。另外，可能會看到一些不同的寫法表示期望值這部分內容主要來源為 SourceLaw of the unconscious statistician (LOTUS)THEOREM 3.2  Let (X) be a discrete random variable with probability function (P(x)) and (g(X)) be a real-valued function of (Y). Then the expected value of (g(X)) is given byExample: Source  Let (X) be a discrete random variable with range (R_X = { 0, frac{pi}{4}, frac{pi}{2}, frac{3pi}{4}, pi… } ), such that (P_X(0)=P_X(frac{pi}{4})=P_X(frac{pi}{2})=P_X(frac{3pi}{4})=P_X(pi)=frac{1}{5}).  Find (E[sin(X)]).Solution:  根據 LOTUS，變異數 Variance定義 Definition  If (X) is a random variable with mean (E[X] = mu), the variance of (X) is defined as  且根據 LOTUS，這個式子可以再寫成期望值的運算THEOREM 3.3  Let X be a discrete random variable with probability function (p(x)) and (c) be a constant. ThenTHEOREM 3.4  Let X be a discrete random variable with probability function (p(x)) and (g(X)) be a function of X, and c be as constant. ThenTHEOREM 3.5  Let X be a discrete random variable with probability function (p(x)) and (g_1(X), g_2(X), …, g_k(X)) be (k) functions of (X). Then根據以上定理，可以再產生THEOREM 3.6  Let X be a discrete random variable with probability function (p(x)) and mean (E(X) = mu). Then證明：  參考：  Mathematical Statistics with Applications 7th Edition  Introduce To Proability, Statistics and Random Process  陳鍾誠的網站",
      "url": " /%E7%B5%B1%E8%A8%88/2018/09/02/%E7%B5%B1%E8%A8%88-%E9%9B%A2%E6%95%A3%E5%9E%8B(Discrete)%E9%9A%A8%E6%A9%9F%E8%AE%8A%E6%95%B8%E8%88%87%E5%85%B6%E6%A9%9F%E7%8E%87%E5%88%86%E4%BD%88(2)/",
      "author": "Shihs",
      "categories": "統計"
    }
    ,
  

    "e7-b5-b1-e8-a8-88-2018-09-01-e7-b5-b1-e8-a8-88-e9-9b-a2-e6-95-a3-e5-9e-8b-discrete-e9-9a-a8-e6-a9-9f-e8-ae-8a-e6-95-b8-e8-88-87-e5-85-b6-e6-a9-9f-e7-8e-87-e5-88-86-e4-bd-88-1": {
      "title": "[統計]離散型(Discrete)隨機變數與其機率分佈(1)",
      "content"	 : "這一系列我是以 Wackerley, Mendenhall and Scheaffer 的 Mathematical Statistics with Applications, 7th edition 這本書為主，有些名詞與定理解釋會再參考其他書籍與網路作為輔助（下方有參考連結）。這篇內容為書中的 3.1 與 3.2。在開始前，何謂「隨機變數」？隨機變數 Random Variable定義 Definition  隨機變數 (X) 是一個以樣本空間 (S) 為定義域（Domain）的實數值函數。 Source  A random variable (X) is a funcion from sample space to real number. Source  ( X: S  to {Bbb R},  S  is  sample  space  ) ( i.e.  forall  s in S,  X(s) in {Bbb R}  )Example:  擲兩枚硬幣，其樣本空間為 ( R = {HH, HT, TH, TT}  )，共有 (2^2) 種可能。 若將 H 定義為 1，T 定義為 0，則其隨機變數 (X) 的值為 ( {0, 1, 2})而隨機變數又分為 1. 離散型 與 2. 連續型，這一章節我們只會討論離散型。離散型隨機變數 Discrete Random Variable定義 Definition  A random variable (Y) is said to be discrete if it can assume only a finite or countably infinite number of distinct values. (DEFINITION 3.1)  (X) is a discrete random variable, if its range is countable. Source根據定義，離散型隨機變數（Discrete Random Variable）必須為可數（countable）。所以像是擲銅板或是擲骰子就會是離散型隨機變數。以擲一顆骰子一次為例，其可能值為 ({1, 2, 3, 4, 5, 6}), 我們用 (X)來表示其隨機變數，但因為隨機變數為 function，所以我們可以用 (R_X)來表示它的範圍，  ( Range(X) = R_X = {1, 2, 3, 4, 5, 6}  ) 機率質量函數 Probability Mass Function (PMF)定義 Definition  Let (X) be a discrete random variable with range (R_X = { x_1, x_2, x_3,… } ) (finite or countably infinite). The function  is called the probability mass function (PMF) of (X). Source機率質量函數 Probability Mass Function (PMF) 可以用來表達樣本空間中某事件的機率。譬如說，擲一顆公平的骰子，骰子點數為 1 的機率我們可以這樣表示，  ( P(X = 1) = 1/6  )另外，( P_X(x) )還有兩個很重要的性質 Source，  ( 0 leqslant P_X(x) leqslant 1 , forall x )  ( sum_{substack{x in R_X}}P_X(x) = 1 )簡單來說就是，  任何事件發生的機率都只會介於 0 和 1 之間  所有事件機率總和等於 1離散型 PMF 圖擲兩枚硬幣，出現 head 為 1，tail 為 0 ，其 PMF 函數為  函數圖為，參考：  Mathematical Statistics with Applications 7th Edition  Introduce To Proability, Statistics and Random Process  陳鍾誠的網站",
      "url": " /%E7%B5%B1%E8%A8%88/2018/09/01/%E7%B5%B1%E8%A8%88-%E9%9B%A2%E6%95%A3%E5%9E%8B(Discrete)%E9%9A%A8%E6%A9%9F%E8%AE%8A%E6%95%B8%E8%88%87%E5%85%B6%E6%A9%9F%E7%8E%87%E5%88%86%E4%BD%88(1)/",
      "author": "Shihs",
      "categories": "統計"
    }
    ,
  

    "r-2018-08-27-r-e5-a6-82-e4-bd-95-e4-bf-ae-e7-95-8c-e9-9d-a2-e8-aa-9e-e8-a8-80-e7-9a-84-e8-a8-ad-e5-ae-9a": {
      "title": "[R]如何更改R介面語言的設定",
      "content"	 : "當安裝完 R 後，原本設定的語言為中文，但現在想要將中文改為英文該如何操作？以下為 mac 的 ios 系統解法，system(&quot;defaults write org.R-project.R force.LANG en_US.UTF-8&quot;)然後關閉 R 再重新打開就會改為英文介面囉！",
      "url": " /r/2018/08/27/R-%E5%A6%82%E4%BD%95%E4%BF%AE%E7%95%8C%E9%9D%A2%E8%AA%9E%E8%A8%80%E7%9A%84%E8%A8%AD%E5%AE%9A/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "python-2018-07-13-python-e5-9f-b7-e8-a1-8cpyinstaller-e7-94-a2-e7-94-9f-e7-9a-84exe-e6-aa-94-e5-87-ba-e7-8f-beno-module-e9-8c-af-e8-aa-a4-e8-a8-8a-e6-81-af": {
      "title": "[Python]執行pyinstaller產生的執行檔出現No module錯誤訊息",
      "content"	 : "前面介紹過使用 pyinstaller 將 .py 打包成執行檔，方便使用者執行程式。我在 mac 終端機輸入 pyinstaller -F pyscript.py 後， 執行在 dist 資料夾底下的檔案，卻出現`no module named ‘somepackagename’`的錯誤訊息。這表示，在打包這支程式時，並未把需要的套件打包進去？ 但是我使用 .py 執行時並沒有這樣的問題啊？ 表示我的電腦確實是有安裝該套件才是。原來是因為在打包時 pyinstaller 並不知道這個套件的路徑， 所以只要加上套件的路徑位置，讓 pyinstaller 執行打包時可以找得到就好。 假如缺少的套件在 /usr/local/lib/python2.7/site-packages， 只要將原本的 pyinstaller -F pyscript.py 改成 pyinstaller -F -p /usr/local/lib/python2.7/site-packages pyscript.py 就好了。 可以用， import sysprint sys.path查看系統路徑，就可以知道套件可能的位置。",
      "url": " /python/2018/07/13/Python-%E5%9F%B7%E8%A1%8Cpyinstaller%E7%94%A2%E7%94%9F%E7%9A%84exe%E6%AA%94%E5%87%BA%E7%8F%BENo-module%E9%8C%AF%E8%AA%A4%E8%A8%8A%E6%81%AF/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-2018-07-05-python-e5-bd-88-e5-87-ba-e8-a6-96-e7-aa-97alert-box": {
      "title": "[Python]彈出視窗 alert box",
      "content"	 : "介紹如何使用 python 寫彈跳視窗，其實網路上可以找到蠻多方法的，我這邊就簡單介紹幾個。以下會分為 mac 和 windows 兩個系統來討論。Mac1. easygui 套件# 記得先安裝 easygui 套件from easygui import msgboxmsgbox(&#39;Stuff&#39;)這個套件基本上蠻簡單的，只要使用msgbox()就好，如果只是要在跑程式的時候使用沒有太大問題，更多 easygui 套件 的介紹但如果要把程式碼打包時（pyinstaller套件） 這個方法就會失效，會出現錯誤訊息ImportError: No module named easygui[3310] Failed to execute script alterwindow所以如果要讓程式碼打包後可以出現彈跳視窗可以使用內建的 system。2. os.system()import osos.system(&quot;osascript -e &#39;Tell application &quot;System Events&quot; to display dialog &quot;&quot;+&quot;Some Funky Message&quot;+&quot;&quot;&#39;&quot;)這方法其實就是使用 python 執行系統命令。也就是，其實把 os.system() 括號裡的東西osascript -e &#39;Tell application &quot;System Events&quot; to display dialog &quot;Some Funky Message&quot;&#39;打在 terminal 裡會執行的東西。將以上命令打在 terminal 會發現出現一個彈跳視窗，內容是 Some Funcky Message。所以在 python 裡面同樣執行會產生同樣的結果。而這個方法將程式打包後可以正確執行。Windows1. easygui 套件# 記得先安裝 easygui 套件from easygui import msgboxmsgbox(&#39;Stuff&#39;)基本上和 mac 一樣，將程式碼打包後也無法正常執行。2. ctypes 套件# 不需另外安裝import ctypesctypes.windll.user32.MessageBoxA(0, &quot;Your text&quot;, &quot;Your title&quot;, 1)# 或著你可以定義一個 functiondef Mbox(title, text, style):    return ctypes.windll.user32.MessageBoxA(0, text, title, style)Mbox(&#39;Your title&#39;, &#39;Your text&#39;, 1)# 如果是要輸出中文，記得重新 encodectypes.windll.user32.MessageBoxA(0, &quot;內容&quot;.decode(&quot;utf-8&quot;).encode(&quot;big5&quot;), &quot;標題&quot;.decode(&quot;utf-8&quot;).encode(&quot;big5&quot;), 1)這個方法也可以打包後執行。另外，會看到有些地方使用ctypes.windll.user32.MessageBoxW()而不是ctypes.windll.user32.MessageBoxA()但執行後會發現，ctypes.windll.user32.MessageBoxW()這個方法會出現亂碼。這兩個的差別在MessageBoxW要使用 unicode 編碼，而MessageBoxA是 ascii 編碼。有人回答這個問題。這邊 mac 和 windows 各介紹了兩種方法，其實還有很多方法啦，只要能符合需求的都是好方法！",
      "url": " /python/2018/07/05/Python-%E5%BD%88%E5%87%BA%E8%A6%96%E7%AA%97alert-box/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2018-07-03-python-e8-ae-80-e5-8f-96-e9-a9-97-e8-ad-89-e7-a2-bc": {
      "title": "[Python][爬蟲]使用 pytesseract 與 Image 套件解析驗證碼",
      "content"	 : "當爬網站碰到需要讀取驗證碼的網站時可以使用pytesseract 與 Image 套件來讀取圖片上的數字與英文。基本流程：  找到圖片的來源網址  下載圖片  調整圖片、解析圖片，獲得圖片上的數字與英文  帶入參數以經濟部公司及分公司基本資料查詢系統為例，從檢查元素中可以發現，在載入這個頁面時會有一個產生圖片的網址同時被載入。而這個頁面正是送出 requests 時會產生的驗證碼圖片。所以只要能下載這個圖片並解析它，就能將解析出來的結果帶進 post 的參數裡，就能完成一個 post requests 。解析驗證碼完整程式碼s = requests.Session()# 1. 找到圖片的來源網址img_url = &quot;https://serv.gcis.nat.gov.tw/pub/kaptcha.jpg&quot;res = s.get(img_url, stream = True, verify = True, timeout = 30)# 2. 下載圖片with open(&#39;pic.jpg&#39;,&#39;wb&#39;) as f:    f.write(res.content)# 3. 調整圖片、解析圖片，獲得圖片上的數字與英文image = Image.open(&#39;pic.jpg&#39;)# adjust pitcure size, it would read more correctlyimage.resize((150, 50),Image.ANTIALIAS).save(&quot;pic.jpg&quot;)image = Image.open(&quot;pic.jpg&quot;)captcha = pytesseract.image_to_string(image).replace(&quot; &quot;, &quot;&quot;).replace(&quot;-&quot;, &quot;&quot;).replace(&quot;$&quot;, &quot;&quot;)程式碼步驟解析session()這裡使是 session 是因為要記錄載入頁面的 cookies，以確保讓網站覺得和等下要送出 requests 時事同時載入的。s = requests.Session()找到圖片的來源網址與存檔img_url = &quot;https://serv.gcis.nat.gov.tw/pub/kaptcha.jpg&quot;res = s.get(img_url, stream = True, verify = True, timeout = 30)with open(&#39;pic.jpg&#39;,&#39;wb&#39;) as f:    f.write(res.content)這前面兩行很簡單，就是送出驗證碼來源網址的 requests，接著下載該圖檔，會發現這時候產生了一個 pic.jpg 的檔案。調整圖片、解析圖片，獲得圖片上的數字與英文image = Image.open(&#39;pic.jpg&#39;)print image# adjust pitcure size, it would read more correctlyimage.resize((150, 50),Image.ANTIALIAS).save(&quot;pic.jpg&quot;)image = Image.open(&quot;pic.jpg&quot;)print imagecaptcha = pytesseract.image_to_string(image).replace(&quot; &quot;, &quot;&quot;).replace(&quot;-&quot;, &quot;&quot;).replace(&quot;$&quot;, &quot;&quot;)print captcha有時候將下載下來的圖片直接丟進 pytesseract.image_to_string() 解析結果正確率會很低，但如果調整一下圖片的 size 反而會有較正確的結果。所以前面我先使用 resize 調整圖片的大小，並重新存檔。最後再使用 pytesseract.image_to_string() 解析圖片。可以根據 pytesseract.image_to_string() 解析出來的結果做些調整以提高正確率。因為發現這個圖片解析出來後常會有些多餘的符號，所以使用 replace 修正。圖片的 mode 必須要為 RGB另外，可以使用print image看 open() 後的圖片的資訊。像是被調整過後的圖片變成&amp;lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=150x50 at 0x109355D90&amp;gt;圖片的尺寸(size)變成 150x50，mode 為 RGB。這點很重要，因為如果 mode 不是 RGB 就會無法 使用 pytesseract.image_to_string()解析圖片。會碰到錯誤訊息/usr/local/lib/python2.7/site-packages/PIL/Image.py:971: UserWarning: Couldn&#39;t allocate palette entry for transparency  &quot;for transparency&quot;)---省略--TypeError: int() argument must be a string or a number, not &#39;tuple&#39;譬如我曾經抓到一個圖片，print 出來的圖片資訊是&amp;lt;PIL.GifImagePlugin.GifImageFile image mode=P size=60x20 at 0x10F1DCD10&amp;gt;這時候必須要把 mode 由 P 轉為 RGB，只要在 open() 後加上一行，image = Image.open(&#39;pic.gif&#39;)image = image.convert(&#39;RGB&#39;)# print image這是後print image會發現 mode 已被改為 RGB，且可以正確執行了。基本上，根據上面的概念就可以破解驗證碼，只要再根據個別網站的狀況做調整就好。經濟部公司及分公司基本資料查詢系統爬蟲網站完整程式碼。或是，另外比較複雜的驗證碼可以參考我的github。",
      "url": " /python/%E7%88%AC%E8%9F%B2/2018/07/03/Python-%E8%AE%80%E5%8F%96%E9%A9%97%E8%AD%89%E7%A2%BC/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-sql-2018-06-30-python-sql-pytho-e6-8e-a5-sqlite": {
      "title": "[Python][SQL]Python 連接 SQLite",
      "content"	 : "這篇是 Python 連接 SQL 的一些基本語法，內容來自 Udacity 上 Intro to Relational Databases 的免費課程與我自己整理的資訊。import sqlite3conn = sqlite3.connect(&quot;Cookies&quot;) # 連接 SQLite 資料庫cursor = conn.cursor() # 獲得連接的游標# 要下的 SQL 指令cursor.execute(    &quot;select host_key from cookies limit 10;&quot;)results = cursor.fetchall()print resutls # 結果為 turpleconn.close() # 每次都要記得 close 連線",
      "url": " /python/sql/2018/06/30/Python-SQL-Pytho%E6%8E%A5-SQLite/",
      "author": "Shihs",
      "categories": "Python, SQL"
    }
    ,
  

    "sql-psql-2018-06-29-sql-psql-e5-9f-ba-e6-9c-ac-e4-bb-a4-e8-88-87-2": {
      "title": "[SQL][psql]基本觀念(2)",
      "content"	 : "這篇是整理一些 psql 的基本觀念，內容來自 Udacity 上 Intro to Relational Databases 的免費課程與我自己整理的資訊。Normalized DesignWhat is Normalized Design?  Every row has the same number of columns. 每一列都必須有同樣的行數。  There is a unique key, and everything in a row says something about the key. 每個 table 會有一個 unique key，且 table 中的每一行的資訊都必須要和 unique key 有關。  Facts that don’t relate to the key belong in different tables. 與 unique key 無關的訊息要放在另一個 table。  Table shouldn’t imply relationships that don’t exist. 行之間不存在關係的資料不能產生會讓人誤會訊息。More about Normalization:William Kent’s paper A Simple Guide to Five Normal Forms in Relational Database TheoryWikipedia’s article on database normalizationUnique Key v.s. Foreign KeyWhat is Unique Key?唯一值不能重複。譬如像是，學號、身分證字號等等，只存在唯一的值，但像名字這種可能會重複的值就不能當 unique key。另外還有一個和 unique key 很像的東西，叫 primary key。它同樣必需要是唯一值不能重複，但他們的差別在於，unique key 可以有 null，但 primary key 不能有 null。譬如，在一間公司裡，公司有台灣人和外國人。公司的每位員工都有職編，但只有台灣人會有身分證字號，這時候職編可以作為 primary key 或是 unique key，但身分證字號只能是 unique key。詳細說明可以看這裡。What is Foreign Key?對照到另一個資料表的 primary key。譬如，有一份資料表是學生資料，欄位包含「學號」和「姓名」，另一份是學生的數學成績，包含「學號」、「分數」。右邊的表格對照到左邊姓名那份表格，學號在左邊的表格是 primary key，所以右邊表格中「學號」那個欄位就會是 foreign key。",
      "url": " /sql/psql/2018/06/29/SQL-psql-%E5%9F%BA%E6%9C%AC%E4%BB%A4%E8%88%87(2)/",
      "author": "Shihs",
      "categories": "SQL, psql"
    }
    ,
  

    "others-python-2018-06-28-google-map-api-geocoding-e5-9c-b0-e5-9d-80-e7-b6-93-e7-b7-af-e5-ba-a6": {
      "title": "Google Map API - Geocoding 地址經緯度",
      "content"	 : "Google Map 提供了很多 API，方便開發者根據自己的需求使用。不過大部分的 API 都需要使用 Google 帳號申請一個 API KEY 。 API KEY 申請時要填上信用卡資訊，有一年的免費使用時間，過了一年以後會自動扣款，但隨時都可以停用，而且時間快到時 Google 也會寄信通知你。這次要介紹Geocoding這個 API 。 根據說明文件上的介紹Geocoding is the process of converting addresses (like &quot;1600 Amphitheatre Parkway, Mountain View, CA&quot;) into geographic coordinates (like latitude 37.423021 and longitude -122.083739), which you can use to place markers on a map, or position the map.簡單來說，你可以根據地址找到該地址在地理上的座標（經緯度），方便應用在地圖上標記位置。根據Geocoding說明文件，這個 API 的 format 有 json 和 xml 兩種格式。來看文件上給的一個輸出 json 格式的範例，https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;amp;key=YOUR_API_KEY看起來這個 API 是需要 API KEY 。但其實，這個 API 是可以不需要 KEY 的（我不知道為什麼 XD）。而且使用 API key 反而還會被限制一天可以搜尋的數量……所以其實上面的例子只要這樣就好，https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA當然也可以搜尋中文地址，https://maps.googleapis.com/maps/api/geocode/json?address=台北市中正區重慶南路一段122號就可以獲取該地址完整的地址資訊（包括郵遞區號）與經緯度。其實只要搜尋「重慶南路一段122號」就可以找到該地址完整的資訊了。使用 python 快速爬取 API 內容這邊我寫了一個簡單的 python 程式可以快速地使用這個 API 獲得地址的經緯度。import requestsimport urllibimport jsondef get_latitude_longtitude(address):    # decode url    address = urllib.quote(address)    url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=&quot; + address        while True:        res = requests.get(url)        js = json.loads(res.text)        if js[&quot;status&quot;] != &quot;OVER_QUERY_LIMIT&quot;:            time.sleep(1)            break    result = js[&quot;results&quot;][0][&quot;geometry&quot;][&quot;location&quot;]    lat = result[&quot;lat&quot;]    lng = result[&quot;lng&quot;]    return lat, lngaddress = &quot;重慶南路一段122號&quot;lat, lng = get_latitude_longtitude()",
      "url": " /others/python/2018/06/28/Google-Map-API-Geocoding-%E5%9C%B0%E5%9D%80%E7%B6%93%E7%B7%AF%E5%BA%A6/",
      "author": "Shihs",
      "categories": "Others, Python"
    }
    ,
  

    "sql-psql-2018-06-15-psql-e5-9f-ba-e6-9c-ac-e6-8c-87-e4-bb-a4": {
      "title": "[SQL][psql]基本指令(1)",
      "content"	 : "這篇是整理一些 psql 的基本指令，內容來自 Udacity 上 Intro to Relational Databases 的免費課程。BASIC COMMANDSConnect to psql$ psqlQuit psql$ qList all databases$ list# or$ l#  exit from query result viewer$ qList all datatables in current database# connect to the database$ connect dbname# or$ c dbname# list all tables $ dtSQL COMMANDSCreate and Drop DATABASECREATE DATABASE dbname;DROP DATABASE dbname;Create and Drop TABLE# Example: Create a table with a text column and a serial columnCREATE TABLE dtname (id serial,name text);# drop table dtnameDROP TABLE dtname;Insert valuesINSERT INTO dtname VALUES(&#39;This is a test&#39;);Show all data in a tableTABLE dtname# orSELECT * FROM dtnameSet primary key# single column primary keyCREATE TABLE dtname (id serial primary key,name text,birthday date);# multiple columns primary keyCREATE TABLE postal_places (postal_code text,country text,name text,primary key (postal_code, country));Declaring relationshipsCREATE TABLE sales (sku text references products (sku),sale_date date,count integer);",
      "url": " /sql/psql/2018/06/15/psql-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/",
      "author": "Shihs",
      "categories": "SQL, psql"
    }
    ,
  

    "python-2018-06-13-python-args-e5-92-8c-kwargs": {
      "title": "[Python]Python 中的 *args 和 *kwargs",
      "content"	 : "簡單來說，*args和**kwargs是 function 的參數，在不確定會有多少參數時使用。args 是 arguments 縮寫，kwargs 是 keyword argments 的縮寫。也就是， args 是沒有 keyword 的變數， kwargs 有 keyword。如果 *args和**kwargs 同時使用，*args必需在**kwargs之前。先簡單看以下的例子def test(*args, **kwargs):    for i in args:        print &quot;agrs=&quot; + str(i)    for j in kwargs:        print &quot;kwargs=&quot; + jtest(1, 2, 3, 4, first = &quot;a&quot;, second = &quot;b&quot;, third = &quot;c&quot;)結果agrs=1agrs=2agrs=3agrs=4kwargs=secondkwargs=thirdkwargs=firstargs 和 kwargs 不是重點，* 才是args 和 kwargs 這兩個參數名稱並不是重點，重點是前面的星號 *。所以，if you like 其實參數也可以寫成 *var 和 **vars，*args 和 **kwargs 只是一個大家使用的習慣。*args 的用法first_arg = &quot;this is first arguments&quot;def arg_test(first_arg, *args):    print &quot;first_arg=&quot; + first_arg    if args is not None:        print &quot;other *args...&quot;        for i in args:            print &quot;agrs=&quot; + str(i)    arg_test(first_arg, 1, 2, 3, 4)結果first_arg=this is first argumentsother *args...agrs=1agrs=2agrs=3agrs=4*kwargs 的用法def greet_me(**kwargs):    if kwargs is not None:        for key, value in kwargs.iteritems():            print &quot;%s == %s&quot; %(key,value) greet_me(name=&quot;yasoob&quot;)name == yasoob從以上兩個範例可以看出 args 和 kwargs 用法的差異。使用 list 和 dictionary 當參數def test_arg(arg1, arg2, arg3):    print arg1    print arg2    print arg3#===args===========args = [1, 2, 3]test_arg(*args)# resultarg1=1arg2=2arg3=3#===kwargs===========kwargs = {    &quot;arg3&quot;:1,    &quot;arg2&quot;:2,    &quot;arg1&quot;:3}test_arg(**kwargs)# resultarg1=3arg2=2arg3=1根據以上範例，可以發現*arg print 的順序就是 list 的順序，但 **kwargs 會根據 dictionary 的 key 來賦予 value。參考",
      "url": " /python/2018/06/13/Python-args-%E5%92%8C-kwargs/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "web-css-2018-06-11-web-css-e5-a6-82-e4-bd-95-e5-88-aa-e9-99-a4nav-ta-e5-ba-95-e8-89-b2-e5-85-a9-e9-82-8a-e7-9a-84-e7-a9-ba-e7-99-bd": {
      "title": "[Web][CSS]如何刪除 nav tag 底色兩邊的空白？",
      "content"	 : "&amp;lt;nav&amp;gt;的作用  &amp;lt;nav&amp;gt; 為 HTML 文件的區域元素 (element)，&amp;lt;nav&amp;gt;用來規劃網頁的導覽區域，通常裡頭會放網站其他網頁的連結。  &amp;lt;nav&amp;gt; 除了全域屬性外，沒有定義其他屬性 (attribute) 。參考像我的網頁上面黑色那條有 “About” 和 “Contact Me” 連結的區域就是在 &amp;lt;nav&amp;gt;裡。&amp;lt;!-- html --&amp;gt;&amp;lt;body&amp;gt;  &amp;lt;nav class=&quot;wrapper-nav&quot; id=&quot;nav&quot;&amp;gt;    &amp;lt;ul&amp;gt;      &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#about&quot;&amp;gt;About&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;          &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#contact&quot;&amp;gt;Contact Me&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;    &amp;lt;/ul&amp;gt;             &amp;lt;/nav&amp;gt;&amp;lt;/body&amp;gt;/* css */nav {  background-color: black;}如何刪除 &amp;lt;nav&amp;gt; 背景的空白 How to remove the space on both sides of navbar若使用上面的程式碼會發現 nav 底色變成黑色，但兩邊會有無法移除的空白，這時候有兩種解決方法。皆是在&amp;lt;body&amp;gt;這個 tag 上面做些調整      /* css */body{  margin-left:auto;  margin-right:auto;}             /* css */body{  width: 100%;  margin: auto;}       ",
      "url": " /web/css/2018/06/11/Web-CSS-%E5%A6%82%E4%BD%95%E5%88%AA%E9%99%A4nav-ta%E5%BA%95%E8%89%B2%E5%85%A9%E9%82%8A%E7%9A%84%E7%A9%BA%E7%99%BD/",
      "author": "Shihs",
      "categories": "Web, CSS"
    }
    ,
  

    "web-css-2018-05-24-web-css-e5-9c-a8-e4-b8-8d-e5-90-8c-e8-9e-a2-e5-b9-95-e8-a7-a3-e6-9e-90-e5-ba-a6-e4-b8-8b-e8-aa-bf-e6-95-b4css": {
      "title": "[Web][CSS]在不同螢幕解析度下調整css",
      "content"	 : "除了電腦外手機、平板都可以瀏覽網頁，這篇要介紹如何依據不同裝置的螢幕寬度來調整 CSS。參考網站解析度可以這樣區分  手機：解析度為0px~320px  平板電腦：解析度為320px~768px  桌上型電腦：大於768px在 CSS 上調整使用@media設定 Max Width/* 768px以下(包含)都適用，手機和平板會符合這個設定 */@media (max-width 768px) {.class {background: #ccc;}}設定 Min Width/* 329px以上(包含)都適用，平板和電腦會符合這個設定 */@media (min-width 320px) {.class {background: #666;}}設定 Max Width and Min Width/* 介於768px與979px間適用 */@media (min-width: 768px) and (max-width: 979px) {.class {background: #666;}}如此就可以依據螢幕的寬度來顯示適合的方式了。",
      "url": " /web/css/2018/05/24/Web-CSS-%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%9E%A2%E5%B9%95%E8%A7%A3%E6%9E%90%E5%BA%A6%E4%B8%8B%E8%AA%BF%E6%95%B4css/",
      "author": "Shihs",
      "categories": "Web, CSS"
    }
    ,
  

    "python-2018-05-24-python-e4-bd-bf-e7-94-a8pyinstaller-e5-a5-97-e4-bb-b6-e6-89-93-e5-8c-85-py-e6-aa-94": {
      "title": "[Python]使用 pyinstaller 套件打包 .py 檔",
      "content"	 : "當我們今天寫好一個 .py 檔，要給使用者執行時當然可以幫使用者在他們的電腦下載 Python 等執行程式時需要的套件，但是，很麻煩！！！ 不可能每次有一個新的使用者就要重新安裝一次 Python，還要安裝套件(更不要說有時候安裝套件會碰到一些問題)，且要執行 .py 檔對於不會使用 terminal 或是 cmd 的人來說可能會選擇放棄，這就減少了讓妳/你的程式給更多人使用的機會。而 pyinstaller 是一個可以把 .py 打包成一個 .exe 檔的工具，讓使用者只要點兩下就能執行妳/你寫好的 Python 檔案。前提pyinstaller可以在 Windows、MacOS、Linux 上使用，但是不是跨平台，所以如果今天使用者是 windows 那麼就必須要在 windows 作業系統底下產生 .exe 檔，若使用者是 macOS 那就必須要在 mac 底下打包產生執行檔。安裝Windowspip install pyinstallerMacsudo pip install pyinstaller但我這邊在安裝時出現了一大串的錯誤，其中內容包括 [Errno 1] Operation not permitted後來我參考這裡把指令改成sudo pip install pyinstaller --upgrade --ignore-installed就成功安裝了。安裝好後，可以在 cmd 或是 terminal 上輸入 pyinstaller 確認。打包 .py 檔假如現在要打包一個 test.py 檔Windowspyinstaller -F test.py完成後會產生三個檔案，  build 資料夾  dist 資料夾  test.spec 檔而我們需要的 test.exe 會單獨在 dist 資料夾裡，如果要給其他 Windows 使用者執行 test.py 這支檔案，只需要給他們 .exe 就行了。如果 test.py 這支程式是會產生一個檔案，例如 .csv 檔案，則這檔案會直接儲存在和 test.exe 同一個路徑底下。MacMac的操作基本上和 Windows 指令一樣，pyinstaller -F test.py打包完後產生出來的檔案也會一樣。但如果執行 .exe 檔會產生檔案，這時候會發現檔案沒有出現在和 .exe 同一個路徑底下。而是會在 /Users/yourusername 底下。可以試試看在 .py 檔裡增加一行print os.getcwd()會發現使用 .exe 執行的結果就會是 /Users/yourusername，所以檔案才會直接產生在這路徑底下。但我想要讓檔案直接產生在桌面，因此我的方法是加上這行os.chdir(&#39;/Users/&#39;+os.getlogin()+&#39;/Desktop&#39;)讓路徑直接換到桌面，這樣儲存檔案就會產生在桌面上了。常用參數  pyinstaller -h 查看參數  -F 打包成一個exe文件  –icon=圖標路徑關於 pyinstaller 套件，這個部落格我覺得說明蠻詳細的。",
      "url": " /python/2018/05/24/Python-%E4%BD%BF%E7%94%A8pyinstaller%E5%A5%97%E4%BB%B6%E6%89%93%E5%8C%85.py%E6%AA%94/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-2018-05-23-python-e4-b8-8b-e8-bc-89-e8-88-87-e5-ae-89-e8-a3-9dpython-e5-8f-8apip-e5-a5-97-e4-bb-b6": {
      "title": "[Python]下載與安裝 Python2.7 及 pip 套件",
      "content"	 : "安裝前可以先認識 Python。這篇文章將會介紹如何在 windows 系統中下載與安裝 python2.7 以及安裝 pip 套件。主要步驟其實就是四個：  下載Python  設定環境變數  下載get-pip.py  設定環境變數1.下載 Python2.7Python2.7.14載點根據自己電腦是32位元還是64位元選擇要下載的檔案下載下來後的檔案（我的電腦是32位元）點兩下安裝，就是一直按下一步就對了2.設定環境變數設定環境變數的目的是，在執行 Python 時讓系統可以根據環境變數底下的路徑依序去找 Python 程式，而不會不知道要如何執行 Python。設定環境變數步驟，電腦(右鍵)-&amp;gt;內容1.進階系統設定 -&amp;gt; 2.環境變數 -&amp;gt; 3.點選PATH-&amp;gt;編輯在變數最後加上安裝路徑「;C:Python27」（這是預設的安裝路徑，如果安裝過程中有更改位置，這邊要改成安裝的路徑）以上步驟完成之後在 cmd 輸入 python，就開始執行 Python 了！ 基本上到這裡已經安裝好 Python 了，那為什麼要安裝 pip 呢？Python 有很多別人寫好且非常好用的套件，當我們想要使用這些套件前會需要先下載安裝套件，而 pip 是用來下載其他套件非常好用的工具。當我們下載完 pip 後，未來下載套件只需要在 cmd 輸入指令就能搞定。pip install packagename也許現在還是會有點困惑，但未來真正開始寫 Python 就會明白為什麼大家下載完 Python 都會接著安裝 pip 了。3.下載 get-pip.py先下載 get-pip.py接著開啟 cmd，使用 cd 將目前位置移到 get-pip.py 的路徑底下，並輸入python get-pip.py這時候只差最後一步了4.設定環境變數這個步驟與剛剛第2個步驟一樣，不過現在要加上的路徑是「;C:Python27Script」接著使用 pip install 安裝看看套件，例如可以安裝寫爬蟲程式必備的 requests 套件pip install requests如果沒有問題，一切就大功告成！",
      "url": " /python/2018/05/23/Python-%E4%B8%8B%E8%BC%89%E8%88%87%E5%AE%89%E8%A3%9DPython%E5%8F%8Apip%E5%A5%97%E4%BB%B6/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "r-2018-02-26-r-e5-a6-82-e4-bd-95-e8-ae-80-e5-8f-96excel-e6-aa-94-e6-a1-88": {
      "title": "[R]如何使用R讀取Excel檔案",
      "content"	 : "很多資料會使用excel檔案儲存，這邊介紹如何使用R讀取主要三種常用的excel附檔名。  csv  xlsx  xls1.csvcsv是最簡單的，不需要install任何package，read.csvd &amp;lt;- read.csv(&quot;file.csv&quot;, stringsAsFactors = FALSE) 假如很不幸，上面的程式碼讀取後你碰到長得像這樣的錯誤訊息Error in type.convert(data[[i]], as.is = as.is[i], dec = dec, numerals = numerals,  : invalid multibyte string at &#39;&amp;lt;e8&amp;gt;&amp;lt;8a&amp;gt;&amp;lt;b1&amp;gt;?&amp;lt;ae&amp;gt;&#39;那就是碰上了編碼錯誤，這時候別緊張，只要加上fileEncoding這個參數就好，d &amp;lt;- read.csv(paste0(&quot;file.csv&quot;), stringsAsFactors = FALSE, fileEncoding = &quot;UTF-8&quot;) 問題應該就可以被解決了。2.xlsx讀取xlsx檔案時依據情況，有兩個套件我會使用，  openxlsx  XLConnect這兩個套件都可以儲存多個sheet，對儲存格做顏色、合併、篩選等等一般可以做的事都可以用程式碼去做。(1)openxlsx讀檔library(openxlsx)# 可以使用sheet參數選擇要的sheet，預設是第一個sheetd &amp;lt;- read.xlsx(&quot;file.xlsx&quot;, sheet = sheetName)寫檔library(openxlsx)### 整個xlsx只有一張sheet寫檔可以簡單的使用write.xlsx就好write.xlsx(d, file = &quot;file.xlsx&quot;)### 有多個sheet要寫入檔案，或是要調整sheet的stylewb &amp;lt;- createWorkbook()# 增加sheetaddWorksheet(wb, &quot;sheetName&quot;)# 設定欄位寬度setColWidths(wb, sheet, cols = c(1:4), widths = c(rep(25, 3), 30))# 增加styleheaderStyle &amp;lt;- createStyle(fgFill = &quot;yellow&quot;, border = &quot;TopBottomLeftRight&quot;, halign = &quot;center&quot;, textDecoration = &quot;bold&quot;, fontSize = 12)addStyle(wb, sheet = sheet, headerStyle, row = 1, cols = 4, gridExpand = TRUE, stack = TRUE)# 加上filteraddFilter(wb, 1, row = 1, cols = 1:ncol(d))# 寫檔writeData(wb, sheet = sheet, d)# 存檔saveWorkbook(wb, &quot;file.xlsx&quot;, overwrite = TRUE)(2)XLConnect至於XLConnect我是在想要使用資料驗證(data validation)裡的「清單」功能時想要克服的。一開始想要直接使用openxlsx的dataValidation function，但一直失敗，且找到這裡說明 list 這個功能無法發揮，所以我想到先儲存一個 template，將我需要的資料驗證清單做好，再使用 loadworkbook 的方法就可以保留 excel 裡原本的樣式。原本是直接使用 openxlsx 這個 library 的 loadWorkbook，但在調整顏色時一直會有 error 無法解決，在改用 XLConnect 這個 library 後就成功使用我想要的cells style與保留資料驗證清單了。另外一個碰到的狀況是我也是要使用一份 template 的樣式，使用openxlsx和XLConnect的loadWorkbook時都遇到像這樣的錯誤Error in substring(x[ind], so, eo) :   invalid multibyte string at &#39;&amp;lt;e6&amp;gt;&amp;lt;96&amp;gt;&amp;lt;b0&amp;gt;蝝唳&amp;lt;98&amp;gt;&amp;lt;ab&amp;gt;&amp;lt;94&amp;gt;&quot;/&amp;gt;&#39;看起來像是編碼上的錯誤，但這份檔案上完全沒有中文，後來我甚至存一份空白的excel檔案都還是會有錯誤。我將其他可以使用 loadWorkbook 這個 function 的 xlsx 丟進 Notepad++ 看，發現可以讀的檔案是Macintosh(CR)不能讀的檔案是Unix(LF)但是，將 template 儲存成 Macintosh(CR) 後，openxlsx的 loadWorkbook function 還是有同樣的 error，而 XLConnect 的錯誤則解除了。程式碼範例，library(XLConnect)# 讀取templatewb &amp;lt;- loadWorkbook(&quot;file.xlsx&quot;)# d是要儲存的dataframe，getSheets(wb)是sheet的名稱writeWorksheet(wb, d, getSheets(wb), startRow = 7, startCol = 1, header = FALSE)# 設stylecs &amp;lt;- createCellStyle(wb)# 邊框setBorder(cs, side = c(&quot;all&quot;), type = XLC$&quot;BORDER.THIN&quot;, color = c(XLC$&quot;COLOR.BLACK&quot;))setCellStyle(wb, sheet = getSheets(wb), row = 7:(7+nrow(d)), col = 1, cellstyle = cs)# 存檔saveWorkbook(wb, file = &quot;savefile.xlsx&quot;)3.xlsxls用的是readxl套件，是R界有名的ggplot2作者Hadley Wickham所寫。下載完後只要一行指令就好，library(readxl)saleslead &amp;lt;- read_excel(paste0(PATH, &quot;2018 sales lead report (for TM only).xls&quot;), sheet = &quot;Raw Data&quot;)但要注意的是屬性問題。其他更多 library 的 function 都可以去CRAN找哦！",
      "url": " /r/2018/02/26/R-%E5%A6%82%E4%BD%95%E8%AE%80%E5%8F%96Excel%E6%AA%94%E6%A1%88/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-02-26-r-e4-bd-bf-e7-94-a8r-e5-af-84outlook-email": {
      "title": "[R]使用 R 寄Outlook Email",
      "content"	 : "之前有介紹過使用mailR這個套件夾帶檔案使用gmail信箱發送信件。這篇要介紹使用RDOCOMClient這個套件來發送outlook夾帶檔案的電子郵件。參考library(RDCOMClient)## init com apiOutApp &amp;lt;- COMCreate(&quot;Outlook.Application&quot;)## create an email outMail = OutApp$CreateItem(0)## configure  email parameter outMail[[&quot;To&quot;]] = &quot;reciever@mail.com&quot;outMail[[&quot;subject&quot;]] = &quot;subject&quot;# There are two ways you can write for mail body# First:text# outMail[[&quot;body&quot;]] = # &quot;Dear reciever,#                      # Please see attached.# # # Best regards,# Sender&quot;# Second:html textbody &amp;lt;- &#39;&amp;lt;p&amp;gt;Dear reciever,&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;Please see attached.&amp;lt;/p&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;p&amp;gt;Best regards,&amp;lt;p&amp;gt;Sender&amp;lt;/p&amp;gt;&#39;outMail[[&quot;HTMLbody&quot;]] = body# attachmentoutMail[[&quot;Attachments&quot;]]$Add(&quot;path of your attachment&quot;)## send it                     outMail$Send()",
      "url": " /r/2018/02/26/R-%E4%BD%BF%E7%94%A8R%E5%AF%84Outlook-Email/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2018-02-17-python-e7-88-ac-e8-9f-b2-requests-e7-9a-84-e7-b7-a8-e7-a2-bc": {
      "title": "[Python][爬蟲]requests 的編碼",
      "content"	 : "rep = requests.get(url)rep.content ： bytes 型別rep.text    ： unicode 型別1.是由 requests 以 rep.encoding 自動轉換的！2.rep.encoding 是以 Reponse Headers 的 Content-Type 決定！",
      "url": " /python/%E7%88%AC%E8%9F%B2/2018/02/17/Python-%E7%88%AC%E8%9F%B2-requests-%E7%9A%84%E7%B7%A8%E7%A2%BC/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2018-02-07-python-e7-88-ac-e8-9f-b2-e9-98-b2-e6-ad-a2-e8-a2-abban-e4-bb-a3-e7-90-86ip-e6-80-8e-e9-ba-bc-e7-94-a8": {
      "title": "[Python][爬蟲]防止被ban，代理IP怎麼用?",
      "content"	 : "如何讓爬蟲程式不被ban?  動態設置user agent  使用代理IP參考這裡主要介紹如何使用IP代理。proxy代理類型參考      透明代理(Transparent Proxy)REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Your IP        匿名代理(Anonymous Proxy)REMOTE_ADDR = proxy IPHTTP_VIA = proxy IPHTTP_X_FORWARDED_FOR = proxy IP        混淆代理(Distorting Proxies)REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Random IP address        高匿代理(Elite proxy或High Anonymity Proxy)REMOTE_ADDR = Proxy IPHTTP_VIA = not determinedHTTP_X_FORWARDED_FOR = not determined  代理proxy哪裡找？這裡提供兩個我覺得品質比較好的proxy代理  http://www.goubanjia.com/free/index.shtml  http://www.proxyserverlist24.top/程式碼如何確定真的使用代理IP了？import requests# 隨便google可以找到可以查詢自己IP的網站url = &quot;http://icanhazip.com/&quot;  # 這個網站可以知道目前瀏覽的IPproxies = {&quot;http&quot;:&quot;http://xx.xx.xxx:xxxx&quot;,&quot;https&quot;:&quot;https://xx.xx.xxx:xxxx&quot;,}###注意#要爬取的網站是使用什麼協定？http？https？#網址可能會有轉址的情況，最後轉的那個網址才是真正的協定喔res = requests.get(url, proxies = proxies)print res.text  # 如果這個網站print出來的和proxies一樣，那就表示成功了抓完proxy後，我將所有proxy儲存在csv檔案中，要爬取網站的時候，先讀取該檔案，只要被擋，就random使用proxy替換proxies。如果所有proxy都用完再重新爬取，網站上的proxy都會不停更換，所以只要更新proxy庫就好。",
      "url": " /python/%E7%88%AC%E8%9F%B2/2018/02/07/Python-%E7%88%AC%E8%9F%B2-%E9%98%B2%E6%AD%A2%E8%A2%ABban-%E4%BB%A3%E7%90%86IP%E6%80%8E%E9%BA%BC%E7%94%A8/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-2018-02-02-python-e5-91-bc-e5-8f-ab-e5-85-b6-e4-bb-96py-e7-9a-84function": {
      "title": "[Python]呼叫其他.py的function",
      "content"	 : "假如現在正在寫的檔案是main.py，而你想要呼叫fun.py這裡面的function，要怎麼做呢？### 這是fun.pydef itsafunction():print &quot;This is a function that I want to call.&quot;有兩種情況，1. 這兩個檔案在同一個folder底下—main.py—fun.py### 這是 main.pyfrom fun import itsafunction# 使用fun.py的itsafunction()itsafunction()2. 這兩個檔案在不同folder底下想要呼叫的fun.py在function這個folder底下—main.py—function—fun.py這時候main.py可以有兩種寫法### 這是main1.pyfrom function import fun# 使用fun.py的itsafunction()fun.itsafunction()### 這是main2.pyfrom function.fun import itsafunction# 使用fun.py的itsafunction()itsafunction()但還有一件很重要的事，要在function這個folder裡加”__init__.py”這個檔案### 這是__init___.py# 什麼都不用寫，沒錯，就是一個空白的.py檔# it&#39;s true, it&#39;s empty. But it&#39;s still important!那如果今天fun.py在function的下一層folder呢?—main.py—function—another—fun.py只要把main.py改成### 這是main.pyfrom function.another import fun# 使用fun.py的itsafunction()fun.itsafunction()#或者也可以這樣寫from function.another.fun import itsafunction# 使用fun.py的itsafunction()itsafunction()但最重要的是，function和another這兩個folder裡面都要加上”__init__.py”這個檔案!",
      "url": " /python/2018/02/02/Python-%E5%91%BC%E5%8F%AB%E5%85%B6%E4%BB%96py%E7%9A%84function/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "tutorial-2018-01-25-tutorial-computer-networking-e7-ad-86-e8-a8-98-22-26": {
      "title": "[Tutorial]Computer Networking筆記(22-26)",
      "content"	 : "Computer Networking TutorialHow Binary Code Works?  bit = binary digit  8-bit system 最高到2^8舉例，如果今天我們要表示19這個數字，那就會是2^8、2^7、2^6、2^5、2^4、2^3、2^2、2^1、2^0 0 、 0 、 0 、 0 、 1 、 0 、 0 、 1 、 1在8 bits的系統裡，可以表示從0到255的數字。也就是，111111111所以如果今天有更多的bits就可以儲存更多的data，這也就是為什麼更大的bits功能較強大了。IP Address每個device都有ip address。IP是一個32 bits的2進位表示的數字，中間以「.」隔開成四組號碼。像這樣:xxx.xxx.xxx.xxx每一組xxx都是8-bit，也就是一個八位數的0、1所組成的數字，所以，每一組有2^8(256)個數字，總共就會有2^82^82^8*2^組IP。而我們看到的IP則是再把這些2進位的數字轉換成10進位表示。這樣的方式就可以讓每個device表達它的位置。IP Addressing IssuesThe Internet is a network of networks.影片舉了一個例子：想像網路其實是聚集了所有的網絡。例如，社區網路是一個網絡，學校是一個網絡，公司是一個網絡，而這三個網絡又都可以連到網路上。當今天，公司裡有台電腦送了requests到網路另一端的server，這時候server收到訊息後，會再傳回response，可是它要如何透過IP知道到底找到這個送出requests的裝置呢？所以其實IP裡頭包含兩個訊息，  Newwork ID  Host ID但是，重點來了！那一組32 bits的IP要怎麼表示Newwork ID和Host ID呢？如果對分，讓16 bits表示Newwork ID，16 bits表示Host ID，這樣就可以有65,536個Newwork ID配上Host ID的組合。但這時候有人說，那萬一某個network的host很少，那豈不是浪費了很多host的位址嗎！但讓host多點bits或少點bits都有可能會遇到浪費或是不夠的問題，這時候大家有點爭論不休，到底該如何解決呢？所以這時有人提出了一個辦法，我們應該要用一個方法表示出Network ID和Host ID的長度。Subnet mask(子網路遮罩)當今天在傳送訊息時，device不只傳送自己的ip，也傳送subnet mask來表示network id和host id長度，subnet mask一樣是一個32 bits的2進位數字，1表示network id，0表示host id。(這裡看影片應該會比較好理解)詳細範例",
      "url": " /tutorial/2018/01/25/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(22-26)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "tutorial-2018-01-24-tutorial-computer-networking-e7-ad-86-e8-a8-98-16-21": {
      "title": "[Tutorial]Computer Networking筆記(16-21)",
      "content"	 : "Computer Networking TutorialOSI ModelOSI Model- Open System Interconnection Reference Model總之，這是一個試圖使各種電腦在世界範圍內互連為網路的標準框架，總共有七層。這有另外一個我覺得還不錯的影片ModemModem就是我們說的數據機。It’s device that connects the network to the Internet.It converges digital signals from router(or any other devices) to analog signals.簡單來說，數據機可以將數位訊號變成類比訊號(訊號轉換器的感覺)，電話、網路等等會透過數據機來轉換訊號而獲得另一方的訊號。RouterRouter是路由器。Router joins network together.SwitchSwitch是分享器。假如今天路由器的網路插孔不夠，分享器可以增加網路插孔，讓更多的電腦使用。路由器和分享器差在哪Repeater/ExtenderRepeater/Extender是中繼器。在一個比較大的空間裡，路由器的信號會因為距離而所差別，這時候使用中繼器，就可以讓網路訊號放大，讓離路由器較遠的裝置也可以有良好的訊號。即便是接網路線，如果網路線過長，訊號也會變差，所以如果使用中繼器可以解決距離較遠的問題。而路由器本身就有中繼器的功能，所以只要選擇其一使用就好。",
      "url": " /tutorial/2018/01/24/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(16-21)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "tutorial-2018-01-20-tutorial-computer-networking-e7-ad-86-e8-a8-98-12-15": {
      "title": "[Tutorial]Computer Networking筆記(12-15)",
      "content"	 : "Computer Networking TutorialTopology/LayoutTopology/Layout是網路之間連接的方式，wiki上翻成「網路拓樸」。每一種方式都各有有缺點，所以取決於使用的目的來決定適合哪種Layout。這個課程介紹三種方式：  Bus Topology(Tutorial 12)  Ring Topology(Tutorial 13)  Star Topology(Tutorial 14)1. Bus TopologyBus Topology是最簡單的一種連接方式，最主要中間有一條主幹，其他node再與主幹相連。最重要的是，主幹的尾端一定要有terminator，才能將傳到尾端的訊號吸收，否則會有回傳的訊號干擾。這樣的優點就是，簡單而且便宜，適合使用在小範圍的網絡內。但缺點是，只有主幹上出了問題，整個網路可能就會出問題。2. Ring TopologyRing Topology與Bus Topology不同的是，它是一個沒有終端環狀，所有node與該環狀線連結，訊號會順著同一個方向傳遞。一般來說，會有兩個環狀(double ring)，訊號會是反方向傳遞。這樣的優點就是，它不需要Bus Topology必須的terminator，而且如果是雙環，也比較不會有主幹出問題，整個網路就壞掉的問題。但缺點是，它比Bus Topology貴。3. Star TopologyStar Topology可能是家裡最常見的一種連結方式。Star Topology會有許多nodes連結中的device(譬如rounter)，就像是星狀一樣。例如，如果中心是rounter，它會在連結internet。這種topology的優點是，價格低、easy to expand。另一方面，如果有其中的node或是某一個node與中心的device的連結出了問題，其他nodes都不會被影響。但缺點是，因為所有nodes都連結中心，也就是所有的nodes全部都必須要依賴中心，所以只要中心的device壞掉，整個連線就會全部失效。4.Mesh TopologyMesh Topology所有nodes之間都互相連結，就像個網狀。這種方式比較會在MAN或WAN見到，不會在LAN使用。優點是，因為每個node之間都互相連結，所以假如有兩個nodes之間的連結出了問題，還可以透過其他nodes傳遞訊號，這樣在傳送訊息上也比較保險。缺點是，因為每個node之間都要連接，就會需要有很多的cable，這時候成本就會提高。有越多的node，成本就會越高。另一方面，因為一個node需要和其他所有nodes連結，這時候網卡(NIC)就需要更強大，同樣也會造成成本的提高，且每一次增加node可能都需要增加NIC。",
      "url": " /tutorial/2018/01/20/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(12-15)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "r-2018-01-17-r-read-csv-e5-87-ba-e7-8f-be-e7-b7-a8-e7-a2-bc-e9-8c-af-e8-aa-a4-e8-a8-8a-e6-81-af": {
      "title": "[R]read.csv出現編碼錯誤訊息",
      "content"	 : "在讀取csv檔案時出現錯誤訊息 d &amp;lt;- read.csv(&quot;file.csv&quot;), stringsAsFactors = FALSE) # Error in type.convert(data[[i]], as.is = as.is[i], dec = dec, numerals = numerals,  : invalid multibyte string at &#39;&amp;lt;e8&amp;gt;&amp;lt;8a&amp;gt;&amp;lt;b1&amp;gt;?&amp;lt;ae&amp;gt;&#39;會出現這樣的錯誤訊息通常是因為編碼問題。先將這份檔案丟到Notepad++，可以看到右下方顯示這份檔案的編碼，(這份檔案是UTF-8)所以只要加上fileEncoding =”UTF-8”就可以解決這個問題了。 d &amp;lt;- read.csv(paste0(&quot;file.csv&quot;), stringsAsFactors = FALSE, fileEncoding =&quot;UTF-8&quot;) ",
      "url": " /r/2018/01/17/R-read.csv%E5%87%BA%E7%8F%BE%E7%B7%A8%E7%A2%BC%E9%8C%AF%E8%AA%A4%E8%A8%8A%E6%81%AF/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2018-01-17-r-e5-a6-82-e4-bd-95-e5-88-aa-e9-99-a4-u-00a0": {
      "title": "[R]如何刪除 U+00A0",
      "content"	 : "在資料中有些含有空白的文字讀進R後會變成&amp;lt;U+00A0&amp;gt;而且不管用什麼方式都取代不了這個符號，這時候該怎麼辦呢？其實只要使用 “U00A0”就可以了# t是含有&quot;&amp;lt;U+00A0&amp;gt;&quot;的字串t &amp;lt;- gsub(&quot;U00A0&quot;, &quot;&quot;, t)",
      "url": " /r/2018/01/17/R-%E5%A6%82%E4%BD%95%E5%88%AA%E9%99%A4-U+00A0/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "tutorial-2018-01-15-tutorial-computer-networking-e7-ad-86-e8-a8-98-9-11": {
      "title": "[Tutorial]Computer Networking筆記(9-11)",
      "content"	 : "Computer Networking Tutorial1.What is NIC(Network Interface Card)?NIC就是網卡，所有電腦都必須要有網卡才能連上網路。(just google it, you can find tons of pictures of NIC)2.What is a Protocol?字典翻譯的意思是，協議草案、禮儀。在network裡，protocol是「網路傳輸協定」。這裡作者先不講定義，先講一個communication會有什麼要件，他用男生想要認識一個女生來舉例。一開始男生要搭訕女生他們可能會有像這樣的對話  Hey  -&amp;gt;  &amp;lt;-  Hello  Can I get your number?   -&amp;gt;  &amp;lt;- 1234-567這樣的對話中會有幾個規則，  一次只會有一個人說話  男生說話以後，會預期女生會回話  問句會有預期的回答(specific messages receive specific responses)符合這樣的規則，那麼人之間的對話(communication)才會有可能成立。同樣的，用在computer commnication也要有一些規則。Protocol are the rules for successful communication among two parties.如果今天你的mac想要和web sever communicates這時候protocol會是什麼呢？  Can I connect to you?   -&amp;gt;  &amp;lt;-   Yes, you have my permission.  GET file google.com   -&amp;gt;  &amp;lt;-  sends file在computer networking裡，最重要的protocol是format和order of massage就像是上面的請求順序，如果在mac還沒提出request，sever就送出網頁，這肯定很怪的吧！protocol有很多種，但我們先來看以下這個例子。這是個網址，http:// www.thenewboston.org /index.php  http: protocol  www.thenewboston.org: sever name  index.php: file",
      "url": " /tutorial/2018/01/15/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(9-11)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "python-2018-01-15-python-google-e7-bf-bb-e8-ad-afapi-e6-8e-a5-e5-8f-a3-library-googletrnas": {
      "title": "[Python]Google 翻譯 API 接口 googletrnas",
      "content"	 : "使用前，先安裝googletrans# windowspip install googletrans# macsudo pip install googletrans程式碼# -*- coding: utf-8 -*-from googletrans import Translatorimport sys# 這兩行很重要，不然會有編碼問題reload(sys)sys.setdefaultencoding( &quot;utf-8&quot; )translator = Translator()# src來源語言，dest要翻譯語言，如果要找其他語言可以參考說明文件print translator.translate(&#39;고마워&#39;, src = &quot;ko&quot;, dest = &quot;zh-TW&quot;)根據說明文件，這個套件可能會有不穩定的問題找到有人直接爬google翻譯的程式碼但其實如果沒有要很大量的爬取我認為這個套件應該很好用了。",
      "url": " /python/2018/01/15/Python-Google%E7%BF%BB%E8%AD%AFAPI%E6%8E%A5%E5%8F%A3-library-googletrnas/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "tutorial-2018-01-09-tutorial-computer-networking-e7-ad-86-e8-a8-98-1-8": {
      "title": "[Tutorial]Computer Networking筆記(1-8)",
      "content"	 : "Computer Networking Tutorial1.What is Computer Networking?各裝置(devices)之間的連結裝置：PC、laptop、printer、rounter等等(不限於電腦)，每一個device都是一個Node。連結：可以使用cable、wireless、copper wire等等，可以稱為communications media。Internet(網路)就是一種computer networkcomputer nework的目的是為了要資料傳輸、資料交換，這裡的資料可以是，documents、pictures、videos等等。computer newworking的兩個重點就是，Nodes和Communications Media2.Types of NetworksLAN(Local Area Network)：一個building的網絡連結，可能是一棟建築、一所學校，小範圍的區域網絡MAN(Metorpolitan Area Network)：多個建築之間的網絡連結，可能是一個城市WAN(Wide Area Network)：&amp;gt;30 miles的網絡連結，整個國家之間、跨國之間的連結3.How the Internet works?以網站為例，假如我今天有一個個人網站，別人是如何透過internet看到我的網站的呢？如果以上面computer network的邏輯來看，其他電腦可以連結到我的電腦，看到我的個人網站。但，如果所有人都可以連到我的個人電腦這樣會有網路安全的疑慮，所以實際上，要連到個人網站是透過server。server is a special computer that everyone can access it.我將個人網站建置(store)在server，其他人要看到我的網站，會在browser上打上網址，這時候就會向server提出request，sever接受到request會回傳data，這些data會是程式碼，而browser會將這些程式碼轉成我們看得懂的網站。通常建置網頁這樣的server我們稱為，web server。像google這麼大的網站，一次總是要接收非常大量來自世界各地的request，所以這個server就必須要有很大的memory，才能負荷這樣的使用流量。4.Client and Host根據上面提到的例子，使用PC的browser向sever提出request，然後server會提供給data給PC的browser。PC接收資料，而server提供資料，PC就是client，sever就是host。",
      "url": " /tutorial/2018/01/09/Tutorial-Computer-Networking%E7%AD%86%E8%A8%98(1-8)/",
      "author": "Shihs",
      "categories": "Tutorial"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2018-01-08-python-e7-88-ac-e8-9f-b2-url-e6-b2-92-e6-9c-89http-https-e8-88-87-e7-b6-b2-e5-9d-80-e9-87-8d-e6-96-b0-e5-b0-8e-e5-90-91": {
      "title": "[Python][爬蟲]URL沒有 HTTP/HTTPS 與網址重新導向",
      "content"	 : "這次要爬的網址長得像這樣  hazyfairyland.blogspot.tw  cartersoshkosh.tw  yungmaun.com.tw沒有www也沒有http/https，如果直接將這樣的網址丟到瀏覽器的網址列它會自動重新導向，但如果是使用request就會產生錯誤訊息。這時候該怎麼辦呢？其實只要在前方加上”http://”就行了，若其實該網址是”https//”， request也會自動重新導向。假如所有的網址都是沒有www，就直接在所有url前方加上”http://”就好了。url = &quot;cartersoshkosh.tw&quot;while True:    try:        res = requests.get(url, timeout = 30)        break    # catch requests.exceptions.MissingSchema error, add &quot;http://&quot; in the front    except requests.exceptions.MissingSchema:        url = &quot;http://&quot; + url           print res.url  # print the final url    print res.history  # print how many redirections it has gone throgh",
      "url": " /python/%E7%88%AC%E8%9F%B2/2018/01/08/Python-%E7%88%AC%E8%9F%B2-URL%E6%B2%92%E6%9C%89HTTP-HTTPS%E8%88%87%E7%B6%B2%E5%9D%80%E9%87%8D%E6%96%B0%E5%B0%8E%E5%90%91/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-2018-01-08-python-read-and-write-csv-file": {
      "title": "[Python]Read and Write CSV file",
      "content"	 : "import csv# read csv filewith open(&quot;file.csv&quot;, &quot;rb&quot;) as f:    for row in csv.reader(f):        print row    # write csv filedata = [[&quot;data1&quot;, &quot;data2&quot;], [&quot;data3&quot;, &quot;data4&quot;]]  # list with open(&quot;file.csv&quot;, &quot;wb&quot;) as f:    w = csv.writer(f)    w.writerows(data)",
      "url": " /python/2018/01/08/Python-Read-and-Write-CSV-file/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-08-18-python-e7-88-ac-e8-9f-b2-e5-a6-82-e4-bd-95-e7-88-ac-e5-8f-96-e7-b6-b2-e9-a0-81-e4-b8-adjs-e7-94-9f-e6-88-90-e7-9a-84-e9-83-a8-e5-88-86": {
      "title": "[Python][爬蟲]如何爬取網頁中js生成的部分",
      "content"	 : "這次想要爬取的是2017年汽車技術展會的參展廠商名單。網頁長得像這樣，在load網頁的時候可以發現，「AUTOMOTIVE WORLD」這個框框會比較慢才跑出來，(可以按重新整裡查看)這時候就可以猜測網頁的這個部份是js生成的。同樣的，使用右鍵「檢查元素」來查看在load這個網頁的過程發生了什麼事。一般來說Network的第一個就會是我們要找的內容，這裡是「Exhibitor/」，查看Headers的General，可以發現就是url就是原本的頁面。如果去抓取網頁，url = &quot;http://www.automotiveworld.jp/en/To-Visit/Exhibitor/&quot;res = requests.get(url)print res.text.encode(&quot;utf-8&quot;)會發現完全抓不到廠商名單的tag，這就是因為，那一個區塊是js另外生成的，所以要去找另外生成的頁面。回到「檢查元素」的Network，看看有沒有什麼可疑對象，這時候發現一個type是document的ExhiList，點進去發現長得像這樣，將網址丟到網址列，果然，就得到了我們要的部分了！完整程式碼",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/08/18/Python-%E7%88%AC%E8%9F%B2-%E5%A6%82%E4%BD%95%E7%88%AC%E5%8F%96%E7%B6%B2%E9%A0%81%E4%B8%ADjs%E7%94%9F%E6%88%90%E7%9A%84%E9%83%A8%E5%88%86/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "git-2017-07-26-git-e6-8f-90-e4-ba-a4-e4-b8-80-e5-80-8b-e6-9b-b4-e6-96-b0": {
      "title": "[Git] 提交一個更新",
      "content"	 : "以下要介紹最基本的同步，檔案在本機被修改或是增加後push到github。1.檢視所有檔案狀態$ git status  #修改或是增加的檔案會呈現紅字2.告知git需要commit的檔案$ git add &amp;lt;file&amp;gt;  #提交一個新增加的檔案$ git add -A  #stages All$ git add .  #stages new and modified, without deleted$ git add -u  #stages modified and deleted, without newadd完後用 git status 會發現原本的紅字變成綠字3.commit變化$ git commit這時候需要記錄提交的訊息4.push同步$ git push主要流程，增加、修改檔案 &amp;gt; git add &amp;gt; git commit &amp;gt; git push透過git status可以查看目前的狀態參考",
      "url": " /git/2017/07/26/Git-%E6%8F%90%E4%BA%A4%E4%B8%80%E5%80%8B%E6%9B%B4%E6%96%B0/",
      "author": "Shihs",
      "categories": "Git"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-07-25-python-e7-88-ac-e8-9f-b2-e5-a6-82-e4-bd-95-e4-b8-8b-e8-bc-89zip-e6-aa-94": {
      "title": "[Python][爬蟲]如何下載 zip 檔",
      "content"	 : "這裡要示範使用三個不同的package下載zip檔。import urllibimport urllib2import requestsurl = &#39;http://www.blog.pythonlibrary.org/wp-content/uploads/2012/06/wxDbViewer.zip&#39;print &quot;downloading with urllib&quot;urllib.urlretrieve(url, &quot;code.zip&quot;)print &quot;downloading with urllib2&quot;f = urllib2.urlopen(url)data = f.read()with open(&quot;code2.zip&quot;, &quot;wb&quot;) as code:    code.write(data)print &quot;downloading with requests&quot;r = requests.get(url)with open(&quot;code3.zip&quot;, &quot;wb&quot;) as code:    code.write(r.content)參考",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/07/25/Python-%E7%88%AC%E8%9F%B2-%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BC%89zip%E6%AA%94/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "excel-vba-2017-07-05-excel-vba-outlook-e4-bf-a1-e4-bb-b6-e5-85-a7-e6-96-87-e5-90-ab-e5-9c-96-e6-aa-94": {
      "title": "[Excel][VBA]寄出內文含圖檔的outlook信件",
      "content"	 : "這裡要介紹如何使用Excel VBA在信件內容包含截取sheet中的特定欄位區塊，並將此區塊變為圖檔包含在內文中寄出。現在要截取一份長這樣的檔案有兩種方法。第一種方法是，先將截取的區塊存成圖檔後再將此圖檔讀取到郵件內容。Sub PrintScreen()      &#39;複製工作表要存圖檔的範圍        Sheets(&quot;Sheet1&quot;).Select        Set rng = Range(&quot;A1:B3&quot;)        rng.CopyPicture      &#39; Excel 存圖檔的精簡程式碼。        With ActiveSheet.ChartObjects.Add(1, 1, rng.Width, rng.Height)  &#39;新增 圖表            .Chart.Paste                                                &#39;貼上 圖片            .Chart.Export Filename:=&quot;test.PNG&quot;, Filtername:=&quot;PNG&quot; &#39;匯出 圖片            .Delete                                                     &#39;刪除 圖表        End WithEnd SubSub SendMail_1()        Dim objOutlook As Object    Dim objMail As Object        Set objOutlook = CreateObject(&quot;Outlook.Application&quot;)    Set objMail = objOutlook.CreateItem(0)        With objMail        .to = &quot;address@email.com&quot;        .Subject = &quot;Subject&quot;        .Body = &quot;mail body&quot;        .HTMLbody = .HTMLbody &amp;amp; &quot;&amp;lt;br&amp;gt;&amp;lt;B&amp;gt;Embedded Image:&amp;lt;/B&amp;gt;&amp;lt;br&amp;gt;&quot; _                &amp;amp; &quot;&amp;lt;img src=&#39;test.PNG&#39;&quot; &amp;amp; &quot;width=&#39;250&#39; height=&#39;100&#39;&amp;gt;&amp;lt;br&amp;gt;&quot; _                &amp;amp; &quot;&amp;lt;br&amp;gt;Best Regards, &amp;lt;br&amp;gt;Sumit&amp;lt;/font&amp;gt;&amp;lt;/span&amp;gt;&quot;       &#39; objMail.Attachments.Add &quot;test.PNG&quot;       &#39; 使用附件檔案       &#39;.Display     &#39; 可以編輯郵件內容，再按下 傳送 鍵。       &#39;.Save         &#39; to save a copy in the drafts folder        .Send        &#39; 直接送出郵件            End With               Set objOutlook = Nothing    Set objMail = Nothing    End Sub第二種方法是，直接截取區要的區塊，變成圖檔，然後貼到信件內容。Sub SendMail_2()    Set objOutlook = CreateObject(&quot;Outlook.Application&quot;)    Set objMail = objOutlook.CreateItem(0)    &#39; mail body    strbody = &quot;mail body&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;    &#39;Copy range of interest    Dim r As Range    Set r = Sheets(&quot;Sheet1&quot;).Range(&quot;A1:B3&quot;)    r.Copy    &#39;Paste as picture in sheet and cut immediately    Dim p As Picture    Set p = ActiveSheet.Pictures.Paste    p.Cut            With objMail        .to = &quot;address@email.com&quot;        &#39;.cc =        &#39;.bcc = &quot;&quot;        .Subject = &quot;Subject&quot;        .HTMLbody = strbody        &#39;.Display            End With    &#39;Get its Word editor    objMail.Display    Dim wordDoc As Object    Set wordDoc = objMail.GetInspector.WordEditor    &#39;Paste picture    wordDoc.Range(Start:=wordDoc.Range.End - 3).Paste        &#39;send mail    objMail.Send        Set objOutlook = Nothing    Set objMail = NothingEnd Sub",
      "url": " /excel/vba/2017/07/05/Excel-VBA-outlook%E4%BF%A1%E4%BB%B6%E5%85%A7%E6%96%87%E5%90%AB%E5%9C%96%E6%AA%94/",
      "author": "Shihs",
      "categories": "Excel, VBA"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-06-30-python-e7-88-ac-e8-9f-b2-e4-b8-8d-e5-90-8c-e7-9a-84content-type-multipart-form-data": {
      "title": "[Python][爬蟲]不同的 Content-Type (multipart/form-data)",
      "content"	 : "這次要爬的目標是台灣精品獎得獎名單。我想要爬取的條件是，這時候會猜測這應該是個post的requests。果然，在按下查詢後，出現了一個cross_list的可疑人物，因為是post，所以會期望在headers裡找到 “Form Data”，這裡面應會藏著post需要的參數。但不幸的是，什麼也沒有，只找到長得像這樣的”Request Payload”然後Content-Type是multipart/form-data其實，我們平常需要的data form裡的資料就藏在Request Payload裡。抓取的方式是，以這行為例，------WebKitFormBoundaryTaDJAA82fTd3ug3WContent-Disposition: form-data; name=&quot;awards[]&quot;1name後的 “award[]” 就會是dictionary的key，底下的 1 ，就會是value，所以就會變成{&quot;awards[]&quot; = &quot;1&quot;}所以就把Request Payload所有的資訊寫成payload = {&quot;keyword&quot;:&quot;&quot;,&quot;awards[]&quot;:&quot;1&quot;,&quot;awards[]&quot;:&quot;2&quot;,&quot;awards[]&quot;:&quot;3&quot;,&quot;years[]&quot;:&quot;2017&quot;,&quot;years[]&quot;:&quot;2016&quot;,&quot;industry[]&quot;:&quot;A&quot;,&quot;industry[]&quot;:&quot;B&quot;,&quot;industry[]&quot;:&quot;C&quot;,&quot;industry[]&quot;:&quot;D&quot;,&quot;industry[]&quot;:&quot;E&quot;,&quot;industry[]&quot;:&quot;F&quot;,&quot;industry[]&quot;:&quot;G&quot;,&quot;industry[]&quot;:&quot;H&quot;,&quot;industry[]&quot;:&quot;I&quot;,&quot;industry[]&quot;:&quot;J&quot;,&quot;industry[]&quot;:&quot;K&quot;,&quot;industry[]&quot;:&quot;L&quot;,&quot;industry[]&quot;:&quot;Z&quot;}但這樣寫完會覺得非常不合理，因為會有一堆同樣的key但給予不同的value，也就是說會key會一直被新的value取代。我當時的想法是，看到 [] 就會很想要在裡面塞數字順位，果然，從0開始，將相同的key編號，就成功了。所以這樣送出requests，# -*- coding: utf-8 -*-#爬取台灣精品得獎名單http://www.taiwanexcellence.org/index.php/awards/now/cross_list/1/2017/2/1from bs4 import BeautifulSoupimport requestsimport mathurl = &quot;http://www.taiwanexcellence.org/index.php/awards/now/send_search/1/2017/2/1/cross_list&quot;payload = {&quot;keyword&quot;:&quot;&quot;,&quot;awards[0]&quot;:&quot;1&quot;,&quot;awards[1]&quot;:&quot;2&quot;,&quot;awards[2]&quot;:&quot;3&quot;,&quot;years[0]&quot;:&quot;2017&quot;,&quot;years[1]&quot;:&quot;2016&quot;,&quot;industry[0]&quot;:&quot;A&quot;,&quot;industry[1]&quot;:&quot;B&quot;,&quot;industry[2]&quot;:&quot;C&quot;,&quot;industry[3]&quot;:&quot;D&quot;,&quot;industry[4]&quot;:&quot;E&quot;,&quot;industry[5]&quot;:&quot;F&quot;,&quot;industry[6]&quot;:&quot;G&quot;,&quot;industry[7]&quot;:&quot;H&quot;,&quot;industry[8]&quot;:&quot;I&quot;,&quot;industry[9]&quot;:&quot;J&quot;,&quot;industry[10]&quot;:&quot;K&quot;,&quot;industry[11]&quot;:&quot;L&quot;,&quot;industry[12]&quot;:&quot;Z&quot;}s = requests.Session()res = s.post(url, data = payload)完整的程式碼",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/06/30/Python-%E7%88%AC%E8%9F%B2-%E4%B8%8D%E5%90%8C%E7%9A%84Content-Type-multipart-form-data/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "r-2017-06-27-r-e9-a1-af-e7-a4-ba-e5-ae-8c-e6-95-b4-e6-95-b8-e5-ad-97-e4-b8-8d-e9-a1-af-e7-a4-ba-e7-a7-91-e5-ad-b8-e8-a8-98-e8-99-9f": {
      "title": "[R]顯示完整數字，不顯示科學記號",
      "content"	 : "只要輸入，調整可顯示的位數options(scipen = 999)就可以改為顯示完整數字",
      "url": " /r/2017/06/27/R-%E9%A1%AF%E7%A4%BA%E5%AE%8C%E6%95%B4%E6%95%B8%E5%AD%97-%E4%B8%8D%E9%A1%AF%E7%A4%BA%E7%A7%91%E5%AD%B8%E8%A8%98%E8%99%9F/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2017-06-22-r-error-when-saving-xlsx-workbook-with-package-openxlsx": {
      "title": "[R]Error when saving xlsx workbook with package openxlsx",
      "content"	 : "如果在windows系統使用saveWorkbook()出現以下錯誤訊息Error: zipping up workbook failed. Please make sure Rtools is installed or a zip application is     available to R.Try installr::install.rtools() on Windows.installr::install.rtools()No need to install Rtools - You&#39;ve got the relevant version of Rtools installedsaveWorkbook(wb, file = &quot;dq&quot;, overwrite = TRUE)Error: zipping up workbook failed. Please make sure Rtools is installed or a zip application is available to R.Try installr::install.rtools() on Windows.1.安裝Rtools.exe2.找到Rtools底下的zip.exe路徑，並設定rools的zip.exe路徑即可解決此問題Sys.setenv(&quot;R_ZIPCMD&quot; = &quot;C:/Rtools/bin/zip.exe&quot;) ## path to zip.exe",
      "url": " /r/2017/06/22/R-Error-when-saving-xlsx-workbook-with-package-openxlsx/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-05-18-python-e7-88-ac-e8-9f-b2-e5-88-a9-e7-94-a8python-e4-b8-8b-e8-bc-89zip-e6-aa-94-e4-b8-a6-e8-a7-a3-e5-a3-93-e7-b8-ae": {
      "title": "[Python][爬蟲]利用python下載zip檔並解壓縮",
      "content"	 : "下載檔案是使用package urllib2解壓縮檔案則是使用package zipfile# 下載與解壓縮 財政部財政資訊中心-全國營業(稅籍)登記資料集 http://data.gov.tw/node/9400import urllib2 #urllib2.urlopen import zipfile #zipfile.ZipFiledef DownloadTWCompany():# 檔案下載print &quot;下載全國營業(稅籍)登記資料集壓縮擋...&quot;downloadurl = urllib2.urlopen(&#39;http://www.fia.gov.tw/opendata/bgmopen1.zip&#39;)zipcontent= downloadurl.read()with open(&quot;TWRAW.zip&quot;, &#39;wb&#39;) as f:    f.write(zipcontent)print &quot;下載完成!&quot;# 解壓縮檔案print &quot;資料解壓縮...&quot;with zipfile.ZipFile(open(&#39;TWRAW.zip&#39;, &#39;rb&#39;)) as f:f.extractall(&quot;.&quot;, pwd = &quot;1234&quot;)  # 解壓縮密碼1234print &quot;解壓縮完成!&quot;DownloadTWCompany()",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/05/18/Python-%E7%88%AC%E8%9F%B2-%E5%88%A9%E7%94%A8python%E4%B8%8B%E8%BC%89zip%E6%AA%94%E4%B8%A6%E8%A7%A3%E5%A3%93%E7%B8%AE/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-05-17-python-e7-88-ac-e8-9f-b2-e5-a6-82-e4-bd-95-e5-88-aa-e9-99-a4-e7-b6-b2-e9-a0-81-e4-b8-ad-e7-9a-84": {
      "title": "[Python][爬蟲]如何刪除網頁中的 &amp; nbsp;",
      "content"	 : "在爬取網頁時偶爾會碰到&amp;amp;nbsp;而且怎麼樣都刪不掉也取代不掉，使用strip()仍然會有空白。「&amp;amp;nbsp;」 是屬於 HTML 的特殊符號之一「空格符號」，其 nbsp 取自於英文 a non-breaking space 的英文簡稱，其原意是「不會被間斷的空白」假如現在有一個網頁內容包含&amp;lt;td&amp;gt;E601010&amp;amp;nbsp;電器承裝業&amp;lt;br&amp;gt;E601020&amp;amp;nbsp;電器安裝業&amp;lt;br&amp;gt;&amp;lt;/td&amp;gt;已經抓出td tag，接著可以使用td = td.encode(formatter=&quot;html&quot;)這時候td type會變成str，再使用replace取代就可以刪除空白了。",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/05/17/Python-%E7%88%AC%E8%9F%B2-%E5%A6%82%E4%BD%95%E5%88%AA%E9%99%A4%E7%B6%B2%E9%A0%81%E4%B8%AD%E7%9A%84/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "python-e7-88-ac-e8-9f-b2-2017-05-05-python-e7-88-ac-e8-9f-b2-e4-b8-8d-e5-90-8c-e7-9a-84content-type-application-json": {
      "title": "[Python][爬蟲]不同的 Content-Type (application/json)",
      "content"	 : "目標是爬取 http://waste.epa.gov.tw/WasteConfigure/VocationCode.asp所有的行業代碼與中文名稱。按下一頁發現會load一個post的網址接著想要在headers裡找到 “Form Data”，這裡面應會藏著post需要的參數。可是，這時候卻只有找到 “Requests Payload”，這個看起來很像payload的東西，它看起來是個json，且Response Headers的Content-Type正是application/json。所以我將 “Requests Payload”按下view source後的結果直接複製，然後requests結果再用json.loads就可以得到想要的結果了。程式碼如下，# -*- coding:utf-8 -*-# 爬取 http://waste.epa.gov.tw/WasteConfigure/VocationCode.asp 行業代碼(4碼)import requestsimport json# payload for requestspayload = &#39;{&quot;Cond&quot;:{&quot;KeyWord&quot;:&quot;&quot;,&quot;Paging&quot;:{&quot;Size&quot;:519,&quot;Current&quot;:1,&quot;Count&quot;:52,&quot;RecordCount&quot;:519,&quot;CanPrev&quot;:false,&quot;CanNext&quot;:true}}}&#39;headers = {&quot;Content-Type&quot;:&quot;application/json&quot;,   &quot;Referer&quot;:&quot;http://waste.epa.gov.tw/WasteConfigure/VocationCode.asp&quot;}url = &quot;http://waste.epa.gov.tw/NRS40/_ws/JsApI/CodeQuery.asmx/Vocation&quot;res = requests.post(url, data = payload, headers = headers)js = json.loads(res.text)for i in js[&quot;d&quot;][&quot;Result&quot;]:code = i[&quot;Code&quot;]name = i[&quot;Name&quot;].encode(&quot;utf-8&quot;, &quot;ignore&quot;)print code",
      "url": " /python/%E7%88%AC%E8%9F%B2/2017/05/05/Python-%E7%88%AC%E8%9F%B2-%E4%B8%8D%E5%90%8C%E7%9A%84Content-Type-application-json/",
      "author": "Shihs",
      "categories": "Python, 爬蟲"
    }
    ,
  

    "r-2017-04-24-r-e5-9c-a8r-e4-b8-ad-e4-bd-bf-e7-94-a8system-e5-91-bc-e5-8f-abpython-e7-b5-a6-e4-ba-88-e5-8f-83-e6-95-b8": {
      "title": "[R]在R中使用system呼叫python-給予參數",
      "content"	 : "之前介紹過在R中使用system呼叫python。system(&quot;python python_script.py&quot;)假如現在我想要帶入參數給python script要怎麼做呢？首先，在python程式碼的部分，要使用 sys.arg[] 讓python程式獲取參數。還有，在 sys.arg[0] 表示的是程式名稱，所以要使用 sys.arg[1] 才是表示要讀取的第一個參數。假如今天有支 python_script.py# -*- coding: utf-8 -*-import sysstring = &quot;Hello, &quot; + sys.argv[1]print string在cmf中呼叫這支python程式python python_script.py worldR裡的system()要打的指令就是cmf中打的指令。所以在R中就會變成，system(&quot;python python_script.py world&quot;)結果就會變成Hello, world最後，在使用system()必須要先setwd將路徑設成python_script.py所在位置。",
      "url": " /r/2017/04/24/R-%E5%9C%A8R%E4%B8%AD%E4%BD%BF%E7%94%A8system%E5%91%BC%E5%8F%ABpython-%E7%B5%A6%E4%BA%88%E5%8F%83%E6%95%B8/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2016-08-24-r-e8-a8-ad-e5-ae-9ar-e5-9c-96-e5-bd-a2-e5-ad-97-e9-ab-94": {
      "title": "[R]設定 R 圖形字體",
      "content"	 : "一開始碰到需要調整圖形字體是在使用windows的自動排程時字體變成框框，以下的解法是針對windows方能使用。  使用windowsFonts函數將要使用的字體賦予一個值。    windowsFonts(BL = windowsFont(&quot;微軟正黑體&quot;))        在圖形中設定family。(1)使用par()在最一開始設定。par(family = &quot;BL&quot;)sales &amp;lt;- c(11, 13, 16, 10, 19)plot(sales, main = &quot;RWEPA公司102年1月至6月銷售統計圖&quot;,      type = &quot;b&quot;, xlab = &quot;月份&quot;, ylab = &quot;銷售金額（萬元)&quot;)(2) 在plot中設定sales &amp;lt;- c(11, 13, 16, 10, 19)plot(sales, main = &quot;RWEPA公司102年1月至6月銷售統計圖&quot;,      type = &quot;b&quot;, xlab = &quot;月份&quot;, ylab = &quot;銷售金額（萬元)&quot;, family = &quot;BL&quot;)(3) 在ggplot中設定library(ggplot2)ggplot(data.frame(x = rnorm(100))) +    geom_histogram(aes(x), fill = &quot;purple&quot;, alpha = 0.6) +    labs(x = &quot;取值&quot;, y = &quot;頻數&quot;) +    theme(text = element_text(family = &quot;BL&quot;))其實，family後是可以直接放要設定的字體完整名稱，不需定windowsFonts，只是假如字體名稱很長，便不需要一再地打上那麼長的名稱，如此以來便也適用mac。",
      "url": " /r/2016/08/24/R-%E8%A8%AD%E5%AE%9AR%E5%9C%96%E5%BD%A2%E5%AD%97%E9%AB%94/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "r-2016-07-17-r-r-batch": {
      "title": "[R]R batch",
      "content"	 : "R batch因為.R檔無法點兩下就能執行，所以儲存一個R batch，再使用工作排程設定時間，就可以在固定時間自動執行程式。以下是在windows中的寫法，必須要先給R儲存的位置，後面放R script的位置。C:Program FilesRR-3.2.5binR.exe&quot; CMD BATCH &quot;C:UsersmypcDesktopmyrscript.R&quot;將上面的程式碼貼在記事本(確認R的版本和位置)，再將記事本副檔名存成.bat 就完成了。",
      "url": " /r/2016/07/17/R-R-batch/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "others-2016-07-17-windows7-e8-87-aa-e5-8b-95-e6-8e-92-e7-a8-8b": {
      "title": "Windows7 自動排程",
      "content"	 : "工作排程，讓程式自動執行開始 =&amp;gt; 附屬應用程式 =&amp;gt; 系統工具 =&amp;gt; 工作排程器建立基本工作 =&amp;gt; 建立基本工作、觸發程序、執行、完成",
      "url": " /others/2016/07/17/windows7%E8%87%AA%E5%8B%95%E6%8E%92%E7%A8%8B/",
      "author": "Shihs",
      "categories": "Others"
    }
    ,
  

    "r-2016-07-17-r-e4-bd-bf-e7-94-a8r-e7-99-bc-e9-80-81email": {
      "title": "[R]使用 R 發送gmail Email",
      "content"	 : "使用mailR package寫一個R的script，自動發信。以下幾個步驟，1.啟用安全性較低的應用程式存取2.使用mailR packagelibrary(mailR)send.mail(from = &quot;mymail@gmail.com&quot;,  # 寄件者          #收件者          to = c(&quot;receive1@gmail.com&quot;,                  &quot;receive2@gmail.com&quot;),          #標題          subject = &quot;測試&quot;,          #內文          body = &quot;這是一個測試&quot;,           encoding = &quot;utf-8&quot;,  # 編碼          #夾帶檔案          attach.files = c(&quot;attach.xlsx&quot;),          smtp = list(host.name = &quot;smtp.gmail.com&quot;,                       port = 465,                       user.name = &quot;mymail@gmail.com&quot;,                       passwd = &quot;mypasswd&quot;,                       ssl = TRUE),          authenticate = TRUE,          send = TRUE)另外，我其實還有查到gmailr這個package，但它有些bug，無法同時有信件內文又有夾帶檔案，所以目前找到最好的方式還是使用mailR。",
      "url": " /r/2016/07/17/R-%E4%BD%BF%E7%94%A8R%E7%99%BC%E9%80%81email/",
      "author": "Shihs",
      "categories": "R"
    }
    ,
  

    "python-2016-07-08-python-e4-bd-bf-e7-94-a8python-e4-b8-8b-e8-bc-89gmail-e9-99-84-e4-bb-b6": {
      "title": "[Python]使用 python 下載 gmail 附件",
      "content"	 : "每天都會收到信並且要利用信中的附件整理資料，但這樣我在跑程式前還要手動去下載檔案，覺得實在太麻煩，所以找到了這個辦法！因為我的mail是gamil，所以以下的程式碼是針對gmail，在執行前要先打開imap我主要是參考這裡import imaplib, inspectimport emailimport osfrom datetime import datetimefrom email.header import decode_headerinspect.getmro(imaplib.IMAP4_SSL)#與IMAP4 server連線，gmail要開啟IMAPimap = imaplib.IMAP4_SSL(&#39;imap.gmail.com&#39;) #登入imap.login(&#39;mymailaddress@gmail.com&#39;, &#39;mypasswd&#39;)#選擇信箱標籤imap.select(&quot;label&quot;)#找所有mailresp, mails = imap.search(None, &quot;ALL&quot;)#讀取信件內容，只抓取最新一封信件(len(mails[0].split())-1)resp, data = imap.fetch(mails[0].split()[len(mails[0].split())-1], &#39;(RFC822)&#39;)emailbody = data[0][1]mail = email.message_from_string(emailbody)#找出含有附件的部分for part in mail.walk():if part.get_content_maintype() == &#39;multipart&#39;:continueif part.get(&#39;Content-Disposition&#39;) is None:continue#附件檔名fileName = part.get_filename()  #修改檔名編碼&amp;lt;http://stackoverflow.com/questions/11206489/how-to-print-next-year-from-current-year-in-python&amp;gt;fileName = str(datetime.now().year - 1911) + str(decode_header(fileName)[0][0]).decode(decode_header(fileName)[0][1])if bool(fileName):filePath = os.path.join(&quot;C:UsersmypcDesktopdata&quot;, fileName)if not os.path.isfile(filePath) :fp = open(filePath, &#39;wb&#39;)fp.write(part.get_payload(decode=True))fp.close()print &quot;attachement is downloaded!&quot;else:print &quot;file is already exist!&quot;#關閉連線與登出imap.close()imap.logout()",
      "url": " /python/2016/07/08/Python-%E4%BD%BF%E7%94%A8python%E4%B8%8B%E8%BC%89gmail%E9%99%84%E4%BB%B6/",
      "author": "Shihs",
      "categories": "Python"
    }
    ,
  

    "r-2016-07-08-r-e5-9c-a8r-e4-b8-ad-e4-bd-bf-e7-94-a8system-e5-91-bc-e5-8f-abpython": {
      "title": "[R]在 R 中使用 system 呼叫 python",
      "content"	 : "我個人比較偏好使用R做所有的事情，但某些時候還是需要使用到python，所以希望可以在R上呼叫python程式碼。一開始我找到了rPython這個library，但它似乎無法在windows上使用……所以我又找到了另一個不需要安裝任何套件且可以在windows上執行的辦法！system(&quot;python python_script.py&quot;)這個辦法是呼叫系統函數，就像是在cmd上面打的指令一樣，而且在mac上也可以執行！",
      "url": " /r/2016/07/08/R-%E5%9C%A8R%E4%B8%AD%E4%BD%BF%E7%94%A8system%E5%91%BC%E5%8F%ABpython/",
      "author": "Shihs",
      "categories": "R"
    }
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
}