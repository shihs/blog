<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>M.C. Shih &middot; BLOG</title>  
  

  <!-- CSS -->
  <link rel="stylesheet" href="/blog/public/css/poole.css">
  <link rel="stylesheet" href="/blog/public/css/syntax.css">
  <link rel="stylesheet" href="/blog/public/css/hyde.css">
  <link rel="stylesheet" href="/blog/public/css/custom.css">
  <link rel="stylesheet" href="/blog/public/css/fontawesome-all.css">
  <link rel="stylesheet" href="/blog/public/css/fontawesome-all.min.css">
  <!-- <link href="https://use.fontawesome.com/releases/v5.0.8/css/all.css" rel="stylesheet"> -->


  <!--<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> -->

  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="16x16" href="/blog/public/apple-touch-icon-16-precomposed.png">
  <link rel="apple-touch-icon" sizes="24x24" href="/blog/public/apple-touch-icon-24-precomposed.png">
  <link rel="apple-touch-icon" sizes="32x32" href="/blog/public/apple-touch-icon-32-precomposed.png">
  <link rel="apple-touch-icon" sizes="48x48" href="/blog/public/apple-touch-icon-48-precomposed.png">
  <link rel="apple-touch-icon" sizes="57x57" href="/blog/public/apple-touch-icon-57-precomposed.png">
  <link rel="apple-touch-icon" sizes="64x64" href="/blog/public/apple-touch-icon-64-precomposed.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/blog/public/apple-touch-icon-72-precomposed.png"> 
  <link rel="apple-touch-icon" sizes="114x114" href="/blog/public/apple-touch-icon-114-precomposed.png"> 
  <link rel="apple-touch-icon" sizes="120x120" href="/blog/public/apple-touch-icon-120-precomposed.png"> 
  <link rel="apple-touch-icon" sizes="144x144" href="/blog/public/apple-touch-icon-144-precomposed.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/blog/public/apple-touch-icon-152-precomposed.png">
  <link rel="apple-touch-icon" sizes="512x512" href="/blog/public/apple-touch-icon-512-precomposed.png">
  <link rel="shortcut icon" href="/blog/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/blog/blog/atom.xml">
  <!-- 數學符號 -->
  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>


  <body>
  	
    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/blog/">
          M.C. Shih
        </a>
        <img src="/blog/img/headshot.png" alt="Author Image" class="headshot">
      </h1>
      <p class="lead">Just for learning.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/blog/">Blog</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/blog/about">About</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/blog/archive">Archives</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/blog/category">Category</a>
          
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/blog/search">Search</a>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

    </nav>
    <div class="links">
      <ul>
        <li><a href="https://shihs.github.io" class="homepage" target="_blank"><img src="/blog/img/link%20icon/iconmonstr-home-6-240.png"></a></li>
        <li><a href="https://github.com/shihs" class="github" target="_blank"><img src="/blog/img/link%20icon/iconmonstr-github-3-240.png"></a></li>
        <li><a href="https://www.linkedin.com/in/min-chun-shih-6647779a/" class="linkedin" target="_blank"><img src="/blog/img/link%20icon/iconmonstr-linkedin-3-240.png"></a></li>
        <li><a href="https://www.instagram.com/itakephotos_tw/" class="instagram" target="_blank"><img src="/blog/img/link%20icon/iconmonstr-instagram-8-240.png"></a></li>
        <li><a href="https://www.flickr.com/photos/mcshihs/" class="flickr" target="_blank"><img src="/blog/img/link%20icon/iconmonstr-flickr-3-240.png"></a></li>
      </ul>
    </div>
    

    <p class = "rights">&copy; 2023. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts" id="begin">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2021/01/javascript-callbac,-promise,-async,-and-await.html">
        [javascript]同步 v.s. 非同步與callback, promise, async, and await
      </a>
    </h1>

    <div class="post-info">
      <!-- <span class="post-date">Posted by Shihs on January 16, 2021</span> -->
      <i class="fas fa-calendar-alt"></i>
      <span class="post-date">January 16, 2021</span>
      <span class="post-categories">
      <!-- <i class="fas fa-tag"></i> -->
      <!-- <i class="far fa-book"></i> -->
      <i class="fas fa-box"></i>
      
      
        <a target="_blank" href="/blog//category/#javascript">javascript</a>
        
      
    </span>

    </div>
    <!-- <p>之前因為在學 node.js 寫過<a href="https://shihs.github.io/blog/javascript/node.js/2020/07/27/node.js-callback/">一篇文章</a>介紹同步非同步以及 callback，但之前沒有實際使用的經驗，有點懵懵懂懂，現在有了一些實際的應用的範例，所以想要再重新整理一次，並加上 promise、async, 與 await。</p>

<hr />

<p>JavaScript Engine 是以單執行緒（單線程/Single Thread）且同步（Synchronous）的方式執行。</p>

<h2 id="同步synchronous">同步（Synchronous）</h2>

<ul>
  <li>指程式必須等待前面的程式執行完才能執行。</li>
</ul>

<h2 id="非同步asynchronous">非同步（Asynchronous）</h2>

<ul>
  <li>指程式不須等待前面的程式執行完就能執行。</li>
</ul>

<p><strong>note</strong></p>
<ul>
  <li>
    <p>執行緒（thread）：執行緒是比程序（process）更小的單元，它是 CPU 的最小執行單元。是作業系統能夠進行運算排程的最小單位。一個程序（process），至少包含一個或多個執行緒。<a href="https://medium.com/@yining1204/javascript-核心篇-學習筆記-chap-15-執行緒與同步-非同步-107802469752">(source)</a></p>
  </li>
  <li>
    <p>單執行緒：單執行的特性是<strong>順序執行</strong>，當遇到比較耗時的任務時，還未執行的任務就會處於等待狀態，一定要等到前面的任務完成了，才會往後執行。<a href="https://medium.com/@yining1204/javascript-核心篇-學習筆記-chap-15-執行緒與同步-非同步-107802469752">(source)</a></p>
  </li>
</ul>

<p>因為 JavaScript 是以單執行緒且同步的方式去執行，它在執行程式碼的時候會按照順序將程式碼片段在堆疊中（stack）執行，而且一次只會執行一個程式碼片段（one thing at a time），只是當碰到非同步（Asynchronous）的任務時，會把它往後放，放到事件佇列(Event Queue)中，等所有的任務完成後才會回來執行。以下面程式碼為例，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// setTimeout(callbackFunction, timeToDelay)</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>印出來的結果會是</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b
a
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">setTimeout</code> 是一個非同步的 Web API，JavaScript 執行到這段的時候會將 <code class="language-plaintext highlighter-rouge">setTimeout</code> 放到 Event Queue 中等待，等 stack 中的任務都執行完才回來執行，所以會先印出<code class="language-plaintext highlighter-rouge">b</code>再印<code class="language-plaintext highlighter-rouge">a</code>。</p>

<hr />

<h2 id="callback">Callback</h2>

<p>callback 是 javascript 中很常見的一種使用方式，它讓函式可以當成參數傳進另一個參數中使用，讓我們可以控制程式碼的流程。看以下範例，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This test function is done.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">main</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This is main start.</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This is main end.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">main</span><span class="p">(</span><span class="nx">test</span><span class="p">);</span>
<span class="c1">// This is main start.</span>
<span class="c1">// This test function is done.</span>
<span class="c1">// This is main end.</span>
</code></pre></div></div>

<p>但其實更多時候 callback 會牽扯到非同步 API 的狀況，像是下面的例子，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 這邊模擬 test 這個 function 去 call 其他 API 要等待的情況</span>
    <span class="c1">// 等了一秒後才會執行 console.log 這個函式</span>
    <span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This test function is done.</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">main</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This is main start.</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This is main end.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">main</span><span class="p">(</span><span class="nx">test</span><span class="p">);</span>
<span class="c1">// This is main start.</span>
<span class="c1">// This is main end.</span>
<span class="c1">// This test function is done.</span>
</code></pre></div></div>

<p>這次<code class="language-plaintext highlighter-rouge">callback()</code>因為會有等待的情況，所以後面的 “This is main end.” 先被執行完。那假如想要<code class="language-plaintext highlighter-rouge">callback()</code>執行完才執行下一行該怎麼做呢？（譬如說，這個<code class="language-plaintext highlighter-rouge">callback()</code>在做的是使用<code class="language-plaintext highlighter-rouge">XMLHttpRequest()</code>送 request 給某個網頁，而下面的程式碼必須等待網頁的 response 才可以執行下面的程式碼。）這時候只要把，執行 “This is main end.” 這行程式碼也當成 callback() 傳進去就行了。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">test</span><span class="p">(</span><span class="nx">callback2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 這邊模擬 test 這個 function 去 call 其他 API 要等待的情況</span>
    <span class="c1">// 等了一秒後才會執行 console.log 這個函式</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This test function is done.</span><span class="dl">"</span><span class="p">);</span>
        <span class="nx">callback2</span><span class="p">();</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">main</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This is main start.</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This is main end.</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="nx">main</span><span class="p">(</span><span class="nx">test</span><span class="p">);</span>
<span class="c1">// This is main start.</span>
<span class="c1">// This test function is done.</span>
<span class="c1">// This is main end.</span>
</code></pre></div></div>

<p>所以 callback 可以用來解決非同步的問題，但是當 callback 越來越多，就會形成 <code class="language-plaintext highlighter-rouge">callback hell</code>，就像是下面這樣，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">api1</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Done with api1</span><span class="dl">"</span><span class="p">);</span>
        <span class="nx">callback</span><span class="p">();</span>
    <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">api2</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Done with api2</span><span class="dl">"</span><span class="p">);</span>
        <span class="nx">callback</span><span class="p">();</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">main</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">api1</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">api2</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">callback</span><span class="p">();</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="nx">main</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">All function is done.</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// "Done with api1"</span>
<span class="c1">// "Done with api2"</span>
<span class="c1">// "All function is done."</span>
</code></pre></div></div>

<p>甚至變成</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">api1</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">api2</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">api3</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">api4</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="c1">// bla bla bla</span>
            <span class="p">});</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div>

<hr />

<h2 id="promise">Promise</h2>

<p>Promise 也是一個可以用來處理非同步操作的東西。Promise 通常包括三種狀態：<code class="language-plaintext highlighter-rouge">resolve</code>、<code class="language-plaintext highlighter-rouge">reject</code>和<code class="language-plaintext highlighter-rouge">pending</code>。<code class="language-plaintext highlighter-rouge">resolve</code>代表成功，<code class="language-plaintext highlighter-rouge">rejetc</code>代表失敗，<code class="language-plaintext highlighter-rouge">pending</code>代表還在處理中, 結束狀態未知。<code class="language-plaintext highlighter-rouge">then()</code>方法可以回傳<code class="language-plaintext highlighter-rouge">Promise</code>物件。</p>

<p>例如，現在想要使用<code class="language-plaintext highlighter-rouge">XMLHttpRequest()</code> API傳送 request，我們需要等待 response 後才有後續動作。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sleep</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">sendHttp</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">url</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://www.google.com/</span><span class="dl">"</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">GET</span><span class="dl">"</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">document</span><span class="dl">"</span><span class="p">;</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>

	<span class="c1">// 如果沒等待 response，status 和 response 會是 0 和 null</span>
	<span class="c1">// console.log(xhr.status);</span>
	<span class="c1">// console.log(xhr.response);</span>

	<span class="nx">sleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">result</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span>
	<span class="p">});</span>
<span class="p">}</span>

<span class="nx">sendHttp</span><span class="p">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">then()</code> 其實是可以一直往後加，就是像<code class="language-plaintext highlighter-rouge">callback</code>，想要前面的事情做完，才做下面，形成 Promise Chain，但這樣就又會變成 then hell。所以這時候出現了 async 和 await，讓程式碼看起來更容易閱讀。</p>

<hr />

<h2 id="asyncawait">Async/Await</h2>

<p>async/await 還是會用到 promise，但不使用 then 去啟動。像剛剛上面的例子，可以改寫成下面這樣，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sleep</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">sendHttp</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">url</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://www.google.com/</span><span class="dl">"</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">GET</span><span class="dl">"</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">document</span><span class="dl">"</span><span class="p">;</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>

	<span class="k">await</span> <span class="nx">sleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
	<span class="c1">// 如果需要更多 sleep(2000)</span>
	<span class="c1">// await sleep(2000);</span>
		
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">sendHttp</span><span class="p">();</span>
</code></pre></div></div>

<p>在<code class="language-plaintext highlighter-rouge">sendHttp()</code>這個 function 前加上 async，並在<code class="language-plaintext highlighter-rouge">sleep(2000)</code>前加上 await 就好，整體畫面看起來是不是容易閱讀很多？如果需要更多的<code class="language-plaintext highlighter-rouge">sleep(2000)</code>，只需要多加 await 往下寫就好，整個畫面看起來容易閱讀很多。</p>

<hr />

<p><strong>Reference:</strong>
<br />
<a href="https://medium.com/@hyWang/%E9%9D%9E%E5%90%8C%E6%AD%A5-asynchronous-%E8%88%87%E5%90%8C%E6%AD%A5-synchronous-%E7%9A%84%E5%B7%AE%E7%95%B0-c7f99b9a298a">非同步(Asynchronous)與同步(Synchronous)的差異</a>
<br />
<a href="https://hsiangfeng.github.io/javascript/20191209/1271823341/">世界上誤解最大的語言 JavaScript 之 JS 到底是同步與非同步語言?!</a>
<br />
<a href="https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html">[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth）</a>
<br />
<a href="https://yu-jack.github.io/2018/07/22/promise/">callback, promise, async/await 使用方式教學以及介紹 Part I</a></p>

 -->
    
    <div class="post-excerpt"><p>之前因為在學 node.js 寫過<a href="https://shihs.github.io/blog/javascript/node.js/2020/07/27/node.js-callback/">一篇文章</a>介紹同步非同步以及 callback，但之前沒有實際使用的經驗，有點懵懵懂懂，現在有了一些實際的應用的範例，所以想要再重新整理一次，並加上 promise、async, 與 await。</p>
</div>

    <div class="bookmark">
      <!-- <i class="far fa-comments"></i> -->
      <i class="fas fa-comments"></i>
      <span>
        


<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
var disqus_config = function () {
        // this.page.url = '/blog///2021/01/javascript-callbac,-promise,-async,-and-await.html#disqus_thread';
        this.page.identifier = '/2021/01/javascript-callbac,-promise,-async,-and-await.html';
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://mcshihs.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>



        <a href="/blog///2021/01/javascript-callbac,-promise,-async,-and-await.html#disqus_thread" data-disqus-identifier="/2021/01/javascript-callbac,-promise,-async,-and-await.html">0 Comments</a>
      </span>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2020/12/javascript-Traversing-the-DOM.html">
        [javascript]Traversing the DOM
      </a>
    </h1>

    <div class="post-info">
      <!-- <span class="post-date">Posted by Shihs on December 3, 2020</span> -->
      <i class="fas fa-calendar-alt"></i>
      <span class="post-date">December 3, 2020</span>
      <span class="post-categories">
      <!-- <i class="fas fa-tag"></i> -->
      <!-- <i class="far fa-book"></i> -->
      <i class="fas fa-box"></i>
      
      
        <a target="_blank" href="/blog//category/#javascript">javascript</a>
        
      
    </span>

    </div>
    <!-- <p>整理 Treehouse 前端課程中 <a href="https://teamtreehouse.com/library/javascript-and-the-dom-2">JavaScript and the DOM</a> 的最後一節 Traversing the DOM 內容。</p>

<p>DOM Traversal 的意思是，可以透過一個 element 與這個 element 的關係去選取其他的 element。</p>

<hr />

<h2 id="parentnode">parentNode</h2>

<ul>
  <li><strong>parentNode</strong>：顧名思義，選取被選取的 element 的 parent node。</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 選取 id 為 myParagraph 的 node</span>
<span class="kd">let</span> <span class="nx">paragraph</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementbyId</span><span class="p">(</span><span class="dl">'</span><span class="s1">myParagraph</span><span class="dl">'</span><span class="p">);</span> 

<span class="c1">// 使用 paragraph 選取它的 parent node</span>
<span class="kd">let</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">paragraph</span><span class="p">.</span><span class="nx">parenNode</span><span class="p">;</span> 

<span class="c1">// 可以直接利用這個 parent node 做些事</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">paragraph</span><span class="p">);</span> <span class="c1">// 刪除 paragraph node</span>
</code></pre></div></div>

<hr />

<h2 id="previouselementsibling--insertbefore">previousElementSibling &amp; insertBefore</h2>

<ul>
  <li><strong>previousElementSibling</strong>：選取被選取的 element 前一個的 sibling。</li>
  <li><strong>insertBefore</strong>：將被選取的 element 插入在某一個 element 之前， <code class="language-plaintext highlighter-rouge">let insertedNode = parentNode.insertBefore(newNode, referenceNode)</code></li>
</ul>

<p><strong>previousSibling v.s. previousSibling</strong></p>

<p>為什麼 sibling 要特別加上 ‘Element’ 呢？因為如果使用 <code class="language-plaintext highlighter-rouge">previousSibling</code> 他會抓取前一個 sibling node，不管它是什麼。而我們<a href="https://shihs.github.io/blog/html/2020/11/13/HTML-%E6%96%87%E4%BB%B6%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B-Document-Object-Model/">前一篇</a>講過， node 包含 document、element、attribute 和 text。所以使用 <code class="language-plaintext highlighter-rouge">previousElementSibling</code> 我們就只會抓前面的 element sibling。</p>

<p>在課程的範例中，現在想要按了 Up 按鈕之後，該 &lt;li&gt; 就會上移。</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ul&gt;</span>
  <span class="nt">&lt;li&gt;</span>grapes 
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"up"</span><span class="nt">&gt;</span>Up<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"remove"</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;</span>amethyst 
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"up"</span><span class="nt">&gt;</span>Up<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"remove"</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;</span>lavender 
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"up"</span><span class="nt">&gt;</span>Up<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"remove"</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;</span>plums 
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"up"</span><span class="nt">&gt;</span>Up<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"remove"</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 選取 ul 的 tag</span>
<span class="kd">const</span> <span class="nx">listDiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.list</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">listUl</span> <span class="o">=</span> <span class="nx">listDiv</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 按下 up 按鈕之後，該 li tag 會往上移</span>
<span class="nx">listUl</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">className</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">up</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  	<span class="c1">// 被 click 的 button 的 parent node 就是 li</span>
    <span class="kd">let</span> <span class="nx">li</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">;</span> 
    <span class="c1">// 被選取的 li tag 的 previous element sibiling，也就是前一個 li tag</span>
    <span class="kd">let</span> <span class="nx">prevLi</span> <span class="o">=</span> <span class="nx">li</span><span class="p">.</span><span class="nx">previousElementSibling</span><span class="p">;</span> 
    <span class="c1">// 這個 li 的 parent node</span>
    <span class="kd">let</span> <span class="nx">ul</span> <span class="o">=</span> <span class="nx">li</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">;</span> 
    <span class="c1">// 如果 prevLi 不是 null，換句話說，不是第一個</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">prevLi</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 將被選取的 li tag 往前移</span>
      <span class="nx">ul</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">li</span><span class="p">,</span> <span class="nx">prevLi</span><span class="p">);</span> 
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">});</span>

</code></pre></div></div>

<hr />

<h2 id="nextelementsibling--insertbefore">nextElementSibling &amp; insertBefore</h2>

<p>按了 down button 之後，該 li 往下移。基本上概念和剛剛上面往前一是一樣的，只是現在使用 nextElementSibling，去選取後面的 element。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ul&gt;</span>
  <span class="nt">&lt;li&gt;</span>grapes 
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"up"</span><span class="nt">&gt;</span>Up<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"down"</span><span class="nt">&gt;</span>Down<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"remove"</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;</span>amethyst 
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"up"</span><span class="nt">&gt;</span>Up<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"down"</span><span class="nt">&gt;</span>Down<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"remove"</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;</span>lavender 
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"up"</span><span class="nt">&gt;</span>Up<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"down"</span><span class="nt">&gt;</span>Down<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"remove"</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;li&gt;</span>plums 
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"up"</span><span class="nt">&gt;</span>Up<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"down"</span><span class="nt">&gt;</span>Down<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"remove"</span><span class="nt">&gt;</span>Remove<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 選取 ul 的 tag</span>
<span class="kd">const</span> <span class="nx">listDiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.list</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">listUl</span> <span class="o">=</span> <span class="nx">listDiv</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 按下 up 按鈕之後，該 li tag 會往上移</span>
<span class="nx">listUl</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">className</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">down</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">li</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">nextLi</span> <span class="o">=</span> <span class="nx">li</span><span class="p">.</span><span class="nx">nextElementSibling</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">ul</span> <span class="o">=</span> <span class="nx">li</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">nextLi</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">ul</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">nextLi</span><span class="p">,</span> <span class="nx">li</span><span class="p">);</span>
    <span class="p">}</span>    
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<hr />

<h2 id="children">children</h2>

<p><code class="language-plaintext highlighter-rouge">.children</code> 可以選取該 element 底下所有的 child element。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">listDiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.list</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">listUl</span> <span class="o">=</span> <span class="nx">listDiv</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// lisUl 底下的 child，也就是 li tag</span>
<span class="kd">const</span> <span class="nx">lis</span> <span class="o">=</span> <span class="nx">listUl</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
</code></pre></div></div>
<hr />

<h2 id="firstchild--lastchild-vs-firstelementchild--lastelementchild">firstChild &amp; lastChild v.s. firstElementChild &amp; lastElementChild</h2>

<p>選取該 element 的第一個或最後一個 child。同樣的，firstElementChild &amp; lastElementChild 選取的會是 element。</p>

 -->
    
    <div class="post-excerpt"><p>整理 Treehouse 前端課程中 <a href="https://teamtreehouse.com/library/javascript-and-the-dom-2">JavaScript and the DOM</a> 的最後一節 Traversing the DOM 內容。</p>
</div>

    <div class="bookmark">
      <!-- <i class="far fa-comments"></i> -->
      <i class="fas fa-comments"></i>
      <span>
        


<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
var disqus_config = function () {
        // this.page.url = '/blog///2020/12/javascript-Traversing-the-DOM.html#disqus_thread';
        this.page.identifier = '/2020/12/javascript-Traversing-the-DOM.html';
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://mcshihs.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>



        <a href="/blog///2020/12/javascript-Traversing-the-DOM.html#disqus_thread" data-disqus-identifier="/2020/12/javascript-Traversing-the-DOM.html">0 Comments</a>
      </span>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2020/11/HTML-%E6%96%87%E4%BB%B6%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B-Document-Object-Model.html">
        [HTML]文件物件模型（Document Object Model）
      </a>
    </h1>

    <div class="post-info">
      <!-- <span class="post-date">Posted by Shihs on November 13, 2020</span> -->
      <i class="fas fa-calendar-alt"></i>
      <span class="post-date">November 13, 2020</span>
      <span class="post-categories">
      <!-- <i class="fas fa-tag"></i> -->
      <!-- <i class="far fa-book"></i> -->
      <i class="fas fa-box"></i>
      
      
        <a target="_blank" href="/blog//category/#HTML">HTML</a>
        
      
    </span>

    </div>
    <!-- <h3 id="dom-是什麼">DOM 是什麼？</h3>

<p>DOM 是 Document Object Model（文件物件模型）的縮寫，它是 HTML、XML 和 SVG 文件的程式介面（programming interface）；可以理解成 DOM 是文件和程式溝通的橋樑、介面，也可以說，DOM 是針對 HTML、XML 和 SVG 提供的一個 API，為了讓程式（ex. JavaScript）能夠操作文件的內容。DOM 將文件（HTML、XML 和 SVG）用樹狀結構表示（如下圖），樹中的每一個節點（node）皆為物件（object），DOM 定義了一些方法讓程式可以存取這些的節點（node）/ 物件（object）並改變文件架構、風格（CSS）和內容。</p>

<p><strong><a href="https://teamtreehouse.com/library/what-is-the-dom">Treehouse 的課程</a>這樣解釋：</strong></p>
<ul>
  <li>The DOM is a represenation (map) of a webpage that JavaScript can use.</li>
  <li>The DOM represents a web page as a tree-like structure.</li>
</ul>

<p>另外，寫網頁的時候常使用 JavaScript 來存取 DOM，但 DOM 並不屬於 JavaScript 語言的一部分，只是我們常用 JavaScript 去存取 DOM，換句話說，JavaScript 可以用其他語言取代，只是不常見。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="http://localhost:4000/blog/img/posts/DOM%20tree.png" alt="DOM tree.png" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><a href="https://teamtreehouse.com/library/what-is-the-dom">The DOM represents a web page as a tree-like structure</a></td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="http://localhost:4000/blog/img/posts/DOM.gif" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><a href="https://ithelp.ithome.com.tw/articles/10202689">Example of DOM hierarchy in an HTML document</a></td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="為什麼需要-dom">為什麼需要 DOM？</h3>

<p>為的是要讓不同的瀏覽器有一樣的文件物件模型標準，否則我們現在就都得針對不同的瀏覽器個別寫程式碼了。而這個標準是由 <a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91%E8%81%94%E7%9B%9F">W3C</a>（全球資訊網協會）所定義的。</p>

<hr />

<h3 id="dom-解析">DOM 解析</h3>

<p>DOM 的樹狀結構中最重要的就是<strong>節點</strong>（<strong>node</strong>），而節點可以分為下列四種（以 HTML 為例，看上圖）：</p>

<ul>
  <li>
    <p><strong>Document</strong>：Document 就是指這整份文件，就是這份 HTML 檔的開端，所有的 nodes 都會從 Document 開始往下。</p>
  </li>
  <li>
    <p><strong>Element</strong>：Element 是指文件內的各個標籤，像是 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;body&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> 等等各種 HTML Tag 都被歸類在 Element。</p>
  </li>
  <li>
    <p><strong>Attribute</strong>：Attribute 是指各個標籤內的相關屬性，像是 <code class="language-plaintext highlighter-rouge">name</code>、<code class="language-plaintext highlighter-rouge">class</code>、<code class="language-plaintext highlighter-rouge">href</code> 等等都是被歸類在 Attribute。</p>
  </li>
  <li>
    <p><strong>Text</strong>：Text 是指被各個標籤包起來的文字，像是 <code class="language-plaintext highlighter-rouge">&lt;h1&gt;Hi&lt;/h1&gt;</code> 中， Hi 被 <code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code> 這個 Element 包起來，因此 Hi 就是此 Element 的 Text。</p>
  </li>
</ul>

<hr />

<h3 id="api--dom--javascript">API = DOM + JavaScript</h3>

<p>這邊介紹一些常見的 DOM API，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">idName</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">tagName</span><span class="dl">'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByClassName</span><span class="p">(</span><span class="dl">'</span><span class="s1">className</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// selector 可以是 id:#idName, class:.className, tag:tagName, or CSS pseudo-class</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">selector</span><span class="dl">'</span><span class="p">);</span> 
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">selector</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<h3 id="補充bom--window">補充：BOM &amp; window</h3>

<p><strong>BOM</strong> 是 Browser Object Model（瀏覽器物件模型）的縮寫。DOM 是文件和程式溝通的接口，BOM 則是和瀏覽器溝通的接口。像是跳轉到其他頁面、螢幕大小的參數等等可以操作的方法或屬性。</p>

<p>同樣的 BOM 也有很多屬於它的 object，像是 <code class="language-plaintext highlighter-rouge">location</code>，下面這個程式碼可以讓瀏覽器跳轉到另一個頁面：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">http://www.xxxx.com</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>而 <strong>windows</strong> 也是 <strong>BOM</strong> 的一個 object。「關閉視窗」可以這樣寫，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
</code></pre></div></div>

<hr />

<p><strong>Reference:</strong>
<br />
<a href="https://ithelp.ithome.com.tw/articles/10202689">Day03-深入理解網頁架構：DOM</a>
<br />
<a href="https://www.wibibi.com/info.php?tid=379">W3C DOM</a>
<br />
<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Document_Object_Model">文件物件模型 (DOM)</a>
<br />
<a href="https://www.fooish.com/javascript/dom/">JavaScript DOM (Document Object Model)</a>
<br />
<a href="https://www.zhihu.com/question/33453164">DOM, DOCUMENT, BOM, WINDOW 有什么区别?</a></p>

 -->
    
    <div class="post-excerpt"><h3 id="dom-是什麼">DOM 是什麼？</h3>
</div>

    <div class="bookmark">
      <!-- <i class="far fa-comments"></i> -->
      <i class="fas fa-comments"></i>
      <span>
        


<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
var disqus_config = function () {
        // this.page.url = '/blog///2020/11/HTML-%E6%96%87%E4%BB%B6%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B-Document-Object-Model.html#disqus_thread';
        this.page.identifier = '/2020/11/HTML-%E6%96%87%E4%BB%B6%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B-Document-Object-Model.html';
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://mcshihs.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>



        <a href="/blog///2020/11/HTML-%E6%96%87%E4%BB%B6%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B-Document-Object-Model.html#disqus_thread" data-disqus-identifier="/2020/11/HTML-%E6%96%87%E4%BB%B6%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B-Document-Object-Model.html">0 Comments</a>
      </span>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2020/07/node.js-callback.html">
        [node.js]非同步（Asynchronous）、同步（Synchronous）、callback
      </a>
    </h1>

    <div class="post-info">
      <!-- <span class="post-date">Posted by Shihs on July 27, 2020</span> -->
      <i class="fas fa-calendar-alt"></i>
      <span class="post-date">July 27, 2020</span>
      <span class="post-categories">
      <!-- <i class="fas fa-tag"></i> -->
      <!-- <i class="far fa-book"></i> -->
      <i class="fas fa-box"></i>
      
      
        <a target="_blank" href="/blog//category/#javascript">javascript</a>
        &nbsp;
      
        <a target="_blank" href="/blog//category/#node.js">node.js</a>
        
      
    </span>

    </div>
    <!-- <p>簡單介紹 node.js 裡重要的「非同步（Asynchronous）」概念，那既然有「非同步（Asynchronous）」當然就會有「同步（Synchronous）」，以及因為「非同步（Asynchronous）」而衍伸出的重要 callback 概念。</p>

<hr />

<p>Node.js 是一個<strong>單執行緒</strong>且非同步的語言。</p>

<p><strong>note</strong></p>
<ul>
  <li>
    <p>執行緒：執行緒是比程序更小的單元，它是 cpu 的最小執行單元。是作業系統能夠進行運算排程的最小單位。一個程序，至少包含一個或多個執行緒。<a href="https://medium.com/@yining1204/javascript-核心篇-學習筆記-chap-15-執行緒與同步-非同步-107802469752">(source)</a></p>
  </li>
  <li>
    <p>單執行緒：單執行的特性是<strong>順序執行</strong>，當遇到比較耗時的任務時，還未執行的任務就會處於等待狀態，一定要等到前面的任務完成了，才會往後執行。<a href="https://medium.com/@yining1204/javascript-核心篇-學習筆記-chap-15-執行緒與同步-非同步-107802469752">(source)</a></p>
  </li>
</ul>

<p><strong>Asynchronous（非同步）&amp; Event queue（事件佇列）</strong></p>

<p>以上提到，單執行緒「還未執行的任務就會處於等待狀態」，所謂的「未執行任務」必須要是<strong>非同步（Asynchronous）</strong>function 才行，而「等待狀態」是指那些任務會被放到 Event queue，而 Event queue 的事件在所有事件完成前不會被執行。簡單的說，程式碼一行一行執行，當遇到<strong>非同步（Asynchronous）</strong>function 時，就會先執行下一行的任務，而這個還未被執行的<strong>非同步（Asynchronous）</strong>function 就會被放到 Event queue 中等到最後才執行。</p>

<hr />

<h3 id="同步synchronous">同步（Synchronous）</h3>

<ul>
  <li>指程式必須等待前面的程式執行完才能執行。</li>
</ul>

<p>如果 function 是<strong>同步(Synchronous)</strong>，那就不管如何都會等這行執行完才執行下一行程式碼。例如，<code class="language-plaintext highlighter-rouge">writeFileSync()</code>就是同步(Synchronous) function。但先等這行程式碼執行完再執行下一行有什麼問題呢？假如今天要寫的檔案內容超級大，那麼所有工作就會全部停擺，等到這行程式碼完成才能進行，而<strong>非同步（Asynchronous）</strong>function 便能解決這個問題。</p>

<h3 id="非同步asynchronous">非同步（Asynchronous）</h3>

<ul>
  <li>指程式不須等待前面的程式執行完就能執行。</li>
</ul>

<p>下面舉一個常見的非同步 function，<strong>setTimeout()</strong>（第一個參數為時間到時要被執行的函式，第二個參數為要延遲的時間（毫秒）），setTimeout() 會在第二個參數的延遲時間後執行第一個參數的函式。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Timer is done!</span><span class="dl">'</span><span class="p">)</span>
<span class="p">},</span> <span class="mi">1</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hi</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>以上程式碼印出來的結果會是，</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello
Hi
Timer is done!
</code></pre></div></div>

<p>因為 setTimeout() 裡的任務被放到 Event queue 中了，必須等到下面兩行程式碼跑完才接著跑 setTimeout() 裡的東西。</p>

<h3 id="callback">callback</h3>

<p>但假如果我們現在就是想要讓程式執行完，才接著下一個任務該怎麼辦呢？所以這時候有了 <strong>callback</strong>。</p>

<p>callback 讓我們把一個函式丟進另一個函式當參數，讓我們可以控制程式碼的流程。先看一個簡單的範例，</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">callbackSleepWorker</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">OK, Im wake up !</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">ICallYouWhenIDone</span><span class="p">(</span><span class="nx">callbackWorker</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">OK, Im first.</span><span class="dl">'</span><span class="p">)</span>
  <span class="nx">callbackWorker</span><span class="p">()</span>
<span class="p">}</span>
<span class="nx">ICallYouWhenIDone</span><span class="p">(</span><span class="nx">callbackSleepWorker</span><span class="p">)</span>
</code></pre></div></div>

<p>這個結果會先印出 ‘OK, Im first.’ 接著再印出 ‘OK, Im wake up !’。</p>

<p>上面這個例子大概還看不太出來為什麼需要 callback，如果現在這個函式是個非同步函式呢？</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">money</span> <span class="o">=</span> <span class="kc">null</span>
<span class="kd">function</span> <span class="nx">slower</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">money</span> <span class="o">=</span> <span class="mi">30</span>
  <span class="p">},</span> <span class="mi">200</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">faster</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I have </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">money</span><span class="p">)</span>
  <span class="p">},</span> <span class="mi">100</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">slower</span><span class="p">()</span>
<span class="nx">faster</span><span class="p">()</span>
</code></pre></div></div>

<p>以上程式碼印出來的會是：I have null。</p>

<p>明明是先跑了 slower() 但 money 卻沒先被負值，這是因為 setTimeout() 是個非同步 function，所以它會先被放到 event queue 中，faster() 就先執行了。那如果我們現在想要讓 slower() 百分之百先執行可以怎麼做呢？</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">money</span> <span class="o">=</span> <span class="kc">null</span>
<span class="kd">function</span> <span class="nx">slower</span><span class="p">(</span><span class="nx">callbackWorker</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">money</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="nx">callbackWorker</span><span class="p">()</span>
  <span class="p">},</span> <span class="mi">200</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">faster</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I have </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">money</span><span class="p">)</span>
  <span class="p">},</span> <span class="mi">100</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">slower</span><span class="p">(</span><span class="nx">faster</span><span class="p">)</span>
</code></pre></div></div>

<p>這時候印出來的結果就會是：I have 30</p>

<p>現在有個任務是，讀檔案並計算長度</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// fs.readFile(filename, callback(err, content))</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">test.txt</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">content</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">content</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">finish</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">not finish</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>本來 readFile() 這個 function 會先被放到 event queue 裡，然後接著印出 ‘not finish’，但我們現在把要讀檔案這個任務放在 callback 裡，所以變成只要讀完檔案就會立刻執行，’not finish’ 會等到檔案讀完才會進行。</p>

<hr />

<p><strong>Reference:</strong>
<br />
<a href="https://medium.com/@Whien/js20min-day-18-關於回呼生活化-callback-1a112db1a788">JS20min Day — 18 關於回呼生活化 (Callback)</a>
<br />
<a href="https://larry850806.github.io/2016/06/16/nodejs-async/">[Node.js] 理解 Node.js 事件驅動</a>
<br />
<a href="https://blog.techbridge.cc/2019/10/05/javascript-async-sync-and-callback/">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！</a>
<br />
<a href="https://wcc723.github.io/javascript/2017/12/07/javascript-event-queue/">鐵人賽：一次只能做一件事情的 JavaScript</a>
<br />
<a href="https://medium.com/@yining1204/javascript-核心篇-學習筆記-chap-15-執行緒與同步-非同步-107802469752">JavaScript 核心篇 學習筆記: Chap.15–執行緒與同步/非同步</a></p>

 -->
    
    <div class="post-excerpt"><p>簡單介紹 node.js 裡重要的「非同步（Asynchronous）」概念，那既然有「非同步（Asynchronous）」當然就會有「同步（Synchronous）」，以及因為「非同步（Asynchronous）」而衍伸出的重要 callback 概念。</p>
</div>

    <div class="bookmark">
      <!-- <i class="far fa-comments"></i> -->
      <i class="fas fa-comments"></i>
      <span>
        


<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
var disqus_config = function () {
        // this.page.url = '/blog///2020/07/node.js-callback.html#disqus_thread';
        this.page.identifier = '/2020/07/node.js-callback.html';
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://mcshihs.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>



        <a href="/blog///2020/07/node.js-callback.html#disqus_thread" data-disqus-identifier="/2020/07/node.js-callback.html">0 Comments</a>
      </span>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog/2020/02/Neural-Network-Neural-Network-3.html">
        [Neural Network]Neural Network 3 - Backpropagation
      </a>
    </h1>

    <div class="post-info">
      <!-- <span class="post-date">Posted by Shihs on February 13, 2020</span> -->
      <i class="fas fa-calendar-alt"></i>
      <span class="post-date">February 13, 2020</span>
      <span class="post-categories">
      <!-- <i class="fas fa-tag"></i> -->
      <!-- <i class="far fa-book"></i> -->
      <i class="fas fa-box"></i>
      
      
        <a target="_blank" href="/blog//category/#Neural Network">Neural Network</a>
        
      
    </span>

    </div>
    <!-- <p><a href="https://shihs.github.io/blog/neural%20network/2020/01/23/Neural-Network-Neural-Network-2/">前面</a>介紹了 neural network 使用 Gradient descent 來找 cost function 的最小值，那這篇要來介紹 neural network 如何使用 <strong>Backpropagation</strong> 這個演算法讓 neural network 訓練過程中更有效率。</p>

<p>這篇是<a href="https://www.youtube.com/watch?v=IHZwWFHWa-w&amp;list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&amp;index=2">Neural networks</a>的課程筆記。另外，覺得李宏毅老師的<a href="https://www.youtube.com/watch?v=ibJpTrp5mcE">課程</a>也講解的很清楚，所以我會搭配老師的課程內容。李宏毅老師和主要課程使用的符號不太ㄧ樣，但我還是使用他們原本各自的符號。</p>

<hr />

<h3 id="gradient-descent">Gradient Descent</h3>

<p>Gradient descent 的目的是要找到 neural network 的 parameters 的最佳解。</p>

<p>Network parameters: 
\(\theta = {\{w_1, w_2,..., b_1, b_2,...\}}\)</p>

<p>Gradient: 
\(\nabla L(\theta) = \begin{bmatrix}
    \partial L(\theta)/\partial w_1 \\
    \partial L(\theta)/\partial w_2 \\
    \vdots \\
    \partial L(\theta)/\partial b_1 \\
    \partial L(\theta)/\partial b_2 \\
    \vdots 
\end{bmatrix}\)</p>

<p>初始 parameters: \(\theta^0\)，計算 \(\nabla L(\theta^0)\)，則 \(\theta^1 = \theta^0 - \eta \nabla L(\theta^0)\)，接著可以再繼續算出 \(\theta_2, \theta_3...\)</p>

<p>在 neural network 裡 Gradient 的最大問題就是，neural network 有太多的參數，所以這裡我們要介紹的 Backpropagation 就是一個比較有效的計算 Gradient 的演算法。也就是說，Backpropagation 基本上就是 Gradient Descent，但是是一個有效率的演算法。</p>

<hr />

<p>前面我們舉的例子是手寫辨識，input 加上兩層的 hidden layers，總共的 weight 和 bias 加起來有 13,002 個參數。如下圖，</p>

<p><img src="http://localhost:4000/blog/img/posts/neural%20network%208.png" alt="" /></p>

<p>為了講解方便，我們現在把整個 nerual network 簡化成每層只有一個神經元。如下圖，第一個神經元是 input，最後一個神經元是 output，中間是兩層的 hidden layer，所以 cost function 可以寫成，\(C(w_1, b_1, w_2, b_2, w_3, b_3)\)</p>

<p><img src="http://localhost:4000/blog/img/posts/simple%20neural%20network.png" alt="" /></p>

<p>為了說明 Backpropagation 現在我們再把範圍縮小到最後一層的 hidden layer 和 output，如下圖。</p>

<p><img src="http://localhost:4000/blog/img/posts/Backpropagation.png" alt="" /></p>

<p>我們令最後的 output 為 \(a^{(L)}\) 表示它是在第 L 層，而 hidden layer 為  \(a^{(L-1)}\) 表示在第 L-1 層，所以上標就只是用來表達它們各自在哪一層而已。</p>

<p>在 \(a^{(L-1)}\) 後的 \(y\) 是我們期望的輸出結果，我們希望 \(y=1\)，也就是說，這裡的 cost 值會是，</p>

\[C_0(...) = (a^{(L)} - y)^ 2 .......... (1)\]

<p>以上圖的例子就會是，\((0.66 - 1)^2\)</p>

<p>接著我們來看每一個神經元的值。根據前面學過的，我們知道每一個神經元都是由前面的 weight 和 bias 算出來了，也就是說</p>

\[a^{(L)} = \sigma (w^{(L)} a^{(L-1)} + b^{(L)})\]

<p>那為了方便，我們把 sigmoid function 裡的式子用一個符號表示，</p>

\[z^{(L)} = w^{(L)} a^{(L-1)} + b^{(L)} .......... (2)\]

<p>而 \(a^{(L)}\) 就可以寫成，</p>

\[a^{(L)} = \sigma (z^{(L)}) .......... (3)\]

<hr />

<p>我們現在有了上面三個式子，</p>

<p>\(C_0(...) = (a^{(L)} - y)^ 2 .......... (1)\)
<br />
\(z^{(L)} = w^{(L)} a^{(L-1)} + b^{(L)} .......... (2)\)
<br />
\(a^{(L)} = \sigma (z^{(L)}) .......... (3)\)</p>

<p>那我們現在要如何<strong>計算權重 \(w^{(L)}\) 對於 cost function 的影響程度</strong>呢？換句話說，我們想要知道 cost function 對 \(w^{(L)}\) 的偏微分 \(\frac{\partial C_0}{\partial w^{(L)}}\)。</p>

<p>根據 <strong><a href="https://www.khanacademy.org/math/ap-calculus-ab/ab-differentiation-2-new/ab-3-1a/v/chain-rule-introduction">Chain rule</a></strong>，我們可以再將上式改寫成，</p>

\[\frac{\partial C_0}{\partial w^{(L)}} = \frac{\partial z^{(L)}}{\partial w^{(L)}} \frac{\partial a^{(L)}}{\partial z^{(L)}} \frac{\partial C_0}{\partial a^{(L)}}\]

<p>下一個步驟要來計算每一個值，我們可以根據上面式子得到的 (1)(2)(3) 得到，</p>

\[\frac{\partial C_0}{\partial a^{(L)}} = 2(a^{(L)} - y)\]

\[\frac{\partial a^{(L)}}{\partial z^{(L)}} = \sigma' (z^{(L)})\]

\[\frac{\partial z^{(L)}}{\partial w^{(L)}} = a^{(L-1)}\]

<p>所以可以將式子整理成，</p>

\[\begin{align}
\frac{\partial C_0}{\partial w^{(L)}} &amp; = \frac{\partial z^{(L)}}{\partial w^{(L)}} \frac{\partial a^{(L)}}{\partial z^{(L)}} \frac{\partial C_0}{\partial a^{(L)}} \\
&amp; = a^{(L-1)} \times \sigma' (z^{(L)}) \times 2(a^{(L)} - y)
\end{align}\]

<p>而這只是其中一個 training sample 算出來的 cost，而總代價函數應該是所有 training data 的平均，也就是</p>

\[\frac{\partial C}{\partial w^{(L)}} = \frac{1}{n} \sum_{k=0}^{n-1} \frac{\partial C_k}{\partial w^{(L)}}\]

<p>而這其實只是 gradient 裡其中的一個 compenent，</p>

<p>Gradient:</p>

\[\nabla C = \begin{bmatrix}
    \frac{\partial C}{\partial w^{(1)}} \\
    \frac{\partial C}{\partial b^{(1)}} \\
    \frac{\partial C}{\partial w^{(2)}} \\
    \frac{\partial C}{\partial b^{(2)}} \\
    \vdots \\
    \frac{\partial C}{\partial w^{(L)}} \\
    \frac{\partial C}{\partial b^{(L)}} \\
\end{bmatrix}\]

<p>如果要計算的是 bias 的偏微分，式子就會是，</p>

\[\begin{align}
\frac{\partial C_0}{\partial b^{(L)}} &amp; = \frac{\partial z^{(L)}}{\partial b^{(L)}} \frac{\partial a^{(L)}}{\partial z^{(L)}} \frac{\partial C_0}{\partial a^{(L)}} \\
&amp; = 1 \times \sigma' (z^{(L)}) \times 2(a^{(L)} - y)
\end{align}\]

<p>接下來，我們來看這個 cost function 對上一層 activation 的敏感度，</p>

\[\begin{align}
\frac{\partial C_0}{\partial a^{(L-1)}} &amp; = \frac{\partial z^{(L)}}{\partial a^{(L-1)}} \frac{\partial a^{(L)}}{\partial z^{(L)}} \frac{\partial C_0}{\partial a^{(L)}} \\
&amp; = w^{(L)} \times \sigma' (z^{(L)}) \times 2(a^{(L)} - y)
\end{align}\]

<hr />

<p>前面我們看的是只有一個神經元的狀況，回到真實的 neural network 結構。一個神經元是來自前面很多神經元與 weight 和 bias 的計算，且一個 training data 的 cost 值是每個 output 減 expected value 平方的和。</p>

<p><img src="http://localhost:4000/blog/img/posts/Backpropagation%20cost.png" alt="" /></p>

<p><img src="http://localhost:4000/blog/img/posts/Backpropagation%202.png" alt="" /></p>

<p>基本上，所有的式子都和只有一個神經元是一樣的，唯一有變化的是，\(\frac{\partial C_0}{\partial a_k^{(L-1)}}\)</p>

\[\frac{\partial C_0}{\partial a_k^{(L-1)}} = \sum_{j=0}^{n_L-1}\frac{\partial z_j^{(L)}}{\partial a_k^{(L-1)}} \frac{\partial a_j^{(L)}}{\partial z_j^{(L)}} \frac{\partial C_0}{\partial a_j^{(L)}}\]

<p>因為，一個神經元會向下影響其他所有與它連接的神經元，所以必須將它們全部加起來。</p>

<p>根據以上，只要不斷往回算就可以了。</p>

<hr />

<p><strong>Reference:</strong>
<br />
<a href="https://www.youtube.com/watch?v=ibJpTrp5mcE">ML Lecture 7: Backpropagation</a>
<br />
<a href="https://medium.com/ai-academy-taiwan/back-propagation-3946e8ed8c55">Back-propagation</a></p>

 -->
    
    <div class="post-excerpt"><p><a href="https://shihs.github.io/blog/neural%20network/2020/01/23/Neural-Network-Neural-Network-2/">前面</a>介紹了 neural network 使用 Gradient descent 來找 cost function 的最小值，那這篇要來介紹 neural network 如何使用 <strong>Backpropagation</strong> 這個演算法讓 neural network 訓練過程中更有效率。</p>
</div>

    <div class="bookmark">
      <!-- <i class="far fa-comments"></i> -->
      <i class="fas fa-comments"></i>
      <span>
        


<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
var disqus_config = function () {
        // this.page.url = '/blog///2020/02/Neural-Network-Neural-Network-3.html#disqus_thread';
        this.page.identifier = '/2020/02/Neural-Network-Neural-Network-3.html';
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://mcshihs.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>



        <a href="/blog///2020/02/Neural-Network-Neural-Network-3.html#disqus_thread" data-disqus-identifier="/2020/02/Neural-Network-Neural-Network-3.html">0 Comments</a>
      </span>
    </div>
  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/blog/page4">Older</a>
  
  
    <!--  -->
      <a class="pagination-item newer" href="/blog/page2">Newer</a>
    <!--  -->
  
</div>

    </div>
    <script id="dsq-count-scr" src="//mcshihs.disqus.com/count.js" async></script>
  </body>
</html>
